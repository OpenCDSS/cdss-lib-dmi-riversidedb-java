// RiversideDB_Export_JFrame -
//	Creates the GUI to manipulate RiversideDB_ExportProduct and
//	ExportConf objects for the RiverTrakAssistant.  This class is called by
//	the RTAssistant_Main_JFrame.
//
//--------------------------------------------------------------------------
// Copyright:	See the COPYRIGHT file.
//--------------------------------------------------------------------------
// History:
//
// 2003-06-05	Morgan Love, RTi	Initial Implementation- copied from
//					RTAssistant_Import_JFrame.
//
// 2003-06-08	AML, RTi		Security measures using fields:
//					DBUser, DBGroup, DBPermissions
//					implemented.
//
// 2003-06-10	AML, RTi		Added properties specific to
//					different Export types.
//
// 2003-06-17	AML, RTi		Added MeasLocGroup_num.
//
// 2003-06-30	AML, RTi		Code clean up
//
// 2004-01-14	AML, RTi		Pass around RiversideDB_ExportConf
//					and RiversideDB_ExportProduct
//					objects to/from main class instead
//					of simple String representations
//					of them.
//
//					Updated Time Series tab in GUI
//					to display selected Time Series
//					(RiversideDB_ExportConf objects)
//					in a JWorksheet.
//
// 2004-02-05	AML, RTi		Added properties to type: graph (jpg)
//
// 2004-04-13	AML, RTi		Added properties to type:
//					LAST_OBS_REPORT for:
//					FORMAT (HTML vs TXT) and
//					DELIMINTOR (for TXT files)
//
//					Added property: TIMESTAMP to
//					all export product properties tab
//					(comma deliminited and graph types
//					did not already have this prop).
//
// 2004_04_12	AML, RTi		Changed property string:
//					__props_reflines_graph_JLabel_str
//					from: "REFERENCELINES"
//					__props_annotationline_graph_JLabel_str
//					to: "ANNOTATION_LINE_Y"
//
//					Added property:
//					ANNOTATION_TEXT_Y
//					__props_annotationtext_graph_JLabel_str
//
//
// 2004_07_14	AML, RTi		*.setEnabled() and setBackgroundColor()
//					replaced by JGUIUtil.setEnabled().
//					*general code cleaning.
// 2004-10-25 Luiz Teixeira, RTi	Upgraded by moving it from the
//					main application (RiverTrak Assistant)
//					to the RiversideDB_DMI library.
// 2004_10_29 Luiz Teixeira, RTi	Created the class
//					RiversideDB_BaseEditor_JFrame.java to
// 					be used as base for all the editor
//					that needed to communicate back to the
//					calling classes. This is now done via
//					the RiversideDB_System_Listener which
//					is implemented in the base class
//					RiversideDB_BaseEditor_JFrame. The
//					base class also implements the
//					addRiversideDBSystemListener(...)
//					and the private array member
//					RiversideDB_System_Listener []
//					_listeners to keep the assingned
//					listeners. This class now extends
// 					from RiversideDB_BaseEditor_JFrame.
// 2004_10_29 Luiz Teixeira, RTi	Removed the definition and all
//					reference to all __calling_class.
//					From now on using the
//					RiversideDB_System_Listener implemen
//					ted in RiversideDB_BaseEditor_JFrame
// 2005-01-07 Luiz Teixeira, RTi 	Replaced the JWorksheet property names
//					by the new ones.
// 2005-02-03 Luiz Teixeira, RTi	Changed from dItemListener (this) to 
//					AddActionListener (this) for the 
//					following JComboBox(s)
//					__files_tab_dest_wild_JComboBox 
// 					Because what we want from this control
//					is to use the item clicked, even if it
//					is alread selected.
// 2005-04-11 J. Thomas Sapienza, RTi	The table model changed to use the
//					new version of row numbering, in which
//					the row numbers are not returned by the
//					table model but are generated by the
//					worksheet, so the properties for 
//					the worksheet in have been changedu
// 2005-08-22	JTS, RTi		* Added __originallyNewObject to detect
//					  how to close the form with the window
//					  manager, because the code that was in
//					  here was not working.
//					* Changed __type_graph_str to be 
//					  "GRAPH" by default and added 
//					  __type_graph_str_old as "GRAPH_JPEG"
//					  to support the old version.
//					* When selecting the export product type
//					  for a new export product, now uses
//					  a JComboBoxResponseJDialog so that
//					  the maximum row count can be set on
//					  the combo box.
// 2005-08-23	JTS, RTi		Added tool tip text to the filename 
//					text field that explains options for
//					file types when writing a GRAPH image.
//--------------------------------------------------------------------------

package RTi.DMI.RiversideDB_DMI;

import  java.awt.Color;
import  java.awt.Dimension;
import  java.awt.Font;
import  java.awt.GridBagConstraints;
import  java.awt.GridBagLayout;
import  java.awt.Insets;
import  java.awt.event.ActionEvent;
import  java.awt.event.ActionListener;
import  java.awt.event.ItemEvent;
import  java.awt.event.ItemListener;
import  java.awt.event.WindowEvent;
import  java.awt.event.WindowListener;
import  java.io.File;
import  java.util.Date;
import  java.util.Vector;

import 	javax.swing.BorderFactory;
import 	javax.swing.border.Border;
import 	javax.swing.border.TitledBorder;
import 	javax.swing.ButtonGroup;
import 	javax.swing.DefaultListModel;
import 	javax.swing.JCheckBox;
import 	javax.swing.JFileChooser;
import 	javax.swing.JFrame;
import 	javax.swing.JLabel;
import 	javax.swing.JList;
import 	javax.swing.JOptionPane;
import 	javax.swing.JPanel;
import 	javax.swing.JRadioButton;
import 	javax.swing.JScrollPane;
import 	javax.swing.JTabbedPane;
import 	javax.swing.JTextField;
import 	javax.swing.ListSelectionModel;

import  RTi.TS.TSIdent;

import  RTi.Util.GUI.JFileChooserFactory;
import RTi.Util.GUI.JComboBoxResponseJDialog;
import  RTi.Util.GUI.JGUIUtil;
import  RTi.Util.GUI.JWorksheet;
import  RTi.Util.GUI.ResponseJDialog;
import  RTi.Util.GUI.SimpleJButton;
import  RTi.Util.GUI.SimpleJComboBox;
import  RTi.Util.IO.PropList;
import	RTi.Util.Message.Message;
import  RTi.Util.String.StringUtil;
import  RTi.Util.Time.DateTime;
import  RTi.Util.Time.TimeUtil;

import 	RTi.DMI.DMIUtil;
import 	RTi.DMI.RiversideDB_DMI.RiversideDB_DMI;
import 	RTi.DMI.RiversideDB_DMI.RiversideDB_DBUser;
import 	RTi.DMI.RiversideDB_DMI.RiversideDB_DBUserMeasLocGroupRelation;
import 	RTi.DMI.RiversideDB_DMI.RiversideDB_ExportConf;
import 	RTi.DMI.RiversideDB_DMI.RiversideDB_ExportConf_CellRenderer;
import 	RTi.DMI.RiversideDB_DMI.RiversideDB_ExportConf_TableModel;
import 	RTi.DMI.RiversideDB_DMI.RiversideDB_ExportProduct;
import 	RTi.DMI.RiversideDB_DMI.RiversideDB_ExportType;
import 	RTi.DMI.RiversideDB_DMI.RiversideDB_MeasLocGroup;
import 	RTi.DMI.RiversideDB_DMI.RiversideDB_ProductGroup;
import 	RTi.DMI.RiversideDB_DMI.RiversideDB_MeasType;

/**

/**
<html><body>
RiversideDB_Export_JFrame.
This class is laid out similarly to the other RiverTrakAssistant classes.
The general format of the class is laid out below, with the major
methods listed with their key functions.  The main object types from
RiversideDB that are manipulated by this class are:<br><ul>
<li>RiversideDB_ExportProduct (abbreviated ExportProduct)</li>
<li>RiversideDB_ExportConf (abbreviated ExportConf)</li></ul><br>
<p><b>Constructor</b><br>
The constructor is called by an action in one of the JTrees of the
main application.  The main application passes to this class a
RiversideDB_ExportProduct.  This class is called in one of two cases: <br>
<ul><li>to view the properties of a current ExportProduct</li>
<li>to create a new ExportProduct</li></ul>
In the case of viewing a current ExportProduct, the ExportProduct object
passed to this class is already defined and all required properties
already known.  In the case of creating a totally new ExportProduct, the
ExportProduct passed in to this class is essentially an empty skeleton,
with only the ProductGroup (parent of the ExportProduct in the JTree)
filled in. <br>
It is Exportant to distinguish in the constructor, if we are dealing with
an existing ExportProduct and just changing some of its fields or if
we are creating a totally new ExportProduct.  If the ExportProduct_num
for the ExportProduct passed in is MISSING, then we know that we are
creating a new ExportProduct object.  In the constructor then, set
the <i>__bln_new_object = true </i> flag.  The <b><i>__bln_new_object</i></b>
flag is important because:<br>
<ul>
<li>we need to set up a dialog to ask the user what <b>type</b> of
ExportProduct they are creating (using <i>RiversideDB_ExportType</i>)
<li>we need to get an ExportProduct_num for the new ExportProduct and in
doing so, we need to actually write the ExportProduct to the database.
Once it is written to the database and the user "Cancels" out of the GUI
later without saving changes, we need to know to go back and delete the
ExportProduct</li>
<li>we can mark the object as dirty (using the <i>setDirty(true)</i> flag)
 since it is an entirely new object</li>
<li>we need to add the fields for <i>DBUser</i>, <i>DBGroup</i>, and
<i>DBPermissions</i> based on the information already known by the DMI for
this user.</li>
<li> we do not have to confirm changes made to a totally new object like we do
if the user is changing an existing object</li>
<li>we need to know to add a new node to the JTree</li></ul>
When creating a <b>new</b> ExportProduct, the most important field in
to fill in is the (autonum) ExportProduct_num field mentioned above since
we can not write any updates to the database for this ExportProduct or for
its related ExportConf objects without knowing the ExportProduct_num.  By
writing the object to the database and retrieving it we can get its
ExportProduct_num. <br><br>
At this point, whether we are creating a new ExportProduct or modifying an
existing one, we assign the ExportProduct to the variable known throughout
this class as: <b><i>__gui_RTi_ExportProduct</i></b>.  We also set up
the variable known throughout this class as: <b><i>
__gui_RTi_ExportConf_vect</i></b> which is a Vector of ExportConf objects that
are related to the <i>__gui_RTi_ExportProduct</i>.  If we have created
a totally new ExportProduct, the <i>__gui_RTi_ExportConf_vect</i> is an
empty Vector; otherwise, it is a Vector of ExportConf objects read directly
from the database, based on the ExportProduct_num of the (already existing)
ExportProduct.<br><br>
Finally, the constructor also:<ul><li> sets up Vectors of (static) reference data,
read directly from the database thay will be used throughout the class</li>
<li>calls method: <i>init_layout_GUI()</i> which creates and sets up the
GUI components</li></ul><br>
</p>
<p><b>init_layout_gui</b><br>
This method is called from the constructor to create and layout the
GUI components.  It calls the method: <i>create_main_panel</i>, which
in turn calls methods named such as: <i>assemble_tab_files()</i>,
<i>assemble_tab_timeseries</i>, etc.  These methods all create
GUI components and put them together in a <i>GridBagLayout</i>. They
do not worry about setting correct values in the components' fields, but just
gets the components set up.  The main components in the GUI consists of:
<ul><li>JPanel that contains general information pertinent to the ExportProduct
object at the top of the GUI</li>
<li>a series of tabs in a JTabbedPane with fields for the ExportProduct and a
tab (the "timeseries" tab) for the related ExportConf objects, seperated by
general topic. Tab topics include: <ul><li>automation </li> <li>file </li>
<li>security </li><li> timeseries</li><li>properties</li><li>archive</li>
</ul> </li>
<li>a panel added at the bottom that includes the standard buttons for:
<ul><li>apply</li><li>close</li><li>cancel</li></ul></li></ul>
At the end of <i>init_layout_gui</i>, a
call to <i>update_gui_fields</i> is made which fills in all the
fields of the GUI according to the ExportProduct and ExportConf objects
currently being worked with.
</p>
<p><b>update_gui_fields</b><br>
This method: <ul><li>determines if the current user, already known to the DMI,
has write permissions.  If the user does not have write permissions, the
<b>apply</b> and <b>close</b> buttons are disabled, leaving only the
<b>cancel</b> button enabled.</li><li>Fills in all the GUI fields according
to the data in the ExportProduct and related ExportConf objects.</li></ul>
</p><br>
At this point the GUI is essentially laid out and we wait for actions...  The
major methods triggered by actions include: <ul>
<li><i>checkRequiredInput()</i></li>
<li><i>update_RiversideDB_objects()</i></li>
<li><i>update_database()</i></li></ul>
Each of these will be detailed below.

<p><b>checkRequiredInput</b><br>
This method simply goes through all the fields in the GUI and checks that
each fields is: <ul> <li>filled in if it is a required field </li>
<li>contains valid values (for JTextFields, for example)</li>
</ul>If an invalid entry is encountered, the method displays a warning message,
indicating the fields with invalid values.
</ul>
</p>

<p><b>update_RiversideDB_objects</b><br>
This method:<ul>
<li><b>creates the <i>__gui</i> versions of the objects!</b> This includes: <ul><li>__gui_RTi_ExportProduct</li><li>__gui_RTi_ExportConf_vect</li></ul> The
<i>__gui</i> versions are created in this method by copying the <i>__db</i>
versions (which were originally created and set up in the constructor)</li>
<li>calls the <i>verify_xxx</i> methods. These include:<ul>
<li><i>verify_top_fields()</i></li>
<li><i>verify_archive_tab()</i></li>
<li><i>verify_automation_tab()</i></li>
<li><i>verify_files_tab()</i></li>
<li><i>verify_properties_tab()</i></li>
<li><i>verify_timeseries_tab()</i></li> </ul>
The <i>verify_xxx</i> methods:<ul><li> fill in the <i>__gui</i> verions of the objects
in memory with the values that are currently set in the GUI</li>
<li>compares the values in the <i>__gui</i> version of the objects to the
<i>__db</i> version of the objects.  If the <i>__gui</i> versions differ
from the <i>__db</i> verions:<ul>
<li>the <i>__gui</i> versions are marked dirty (<i>.setDirty(true)</i>)</li>
<li>messages are added to the <i>__dirty_vect</i> indicating how the
<i>__gui</i> differs from the <i>__db</i> version (the <i>__db</i> version
remember, represents how the object is in the database itself) </li></ul>
</li></ul></ul>
</p>
<p><b>update_database</b><br>
This method: <ul>
<li>makes a confirmation message to verify that the user wants to save the
changes (and lists out all the changes from the <i>__dirty_vect</i>) <b>if</b>
a new ExportProduct was <b>not</b> created (if a new ExportProduct was created,
we do not want to re-confirm every change)</li>
<li>writes the <i>__gui</i> version of the objects to the database</li>
<li>if the objects were successfully written to the database, the
<i>__gui</i> objects are marked as <b>not</b> dirty
( <i>setDirty(false)</i></li>
<li><i>__dirty_vect</i> is cleared out</li>
<li>if we created a new ExportProduct object (<i>__bln_new_object == true</i>),
add a new node on the JTree in the main application  - <b>or</b> -  update the
existing ExportProduct node on the JTree with the new changes.</li>
</ul>
</p>

<br>
<p><b>ACTIONS and the events they trigger</b><br>
The main actions in the GUI are fired off when the user selects one of the
following buttons:<ul><li>cancel</li><li>close</li><li>apply</li></ul>
<ul><li><b>cancel</b><br>
Items that are checked before the GUI is closed:<ul>
<li>if the user was creating a new ExportProduct ( <i>__bln_new_object == true </i> ), the ExportProduct is deleted from the database</li>
<li>if the user was changing the properties of an existing ExportProduct,

<ul><li><i>update_RiversideDB_objects()</i> is called to <b>create</b> and
update the <i><b>__gui_RTi_ExportProudct</b></i> and <i>
<b>__gui_RTi_ExportConf_vect</b></i> objects in memory, mark them dirty, and
add messages to the <i>__dirty_vect</i> Vector.</li><li>Print a confirmation
message, confirming the user wants to cancel the changes (that are stored
in the <i>__dirty_vect</i>) </li></ul> </li> </ul> </li>
<li><b>close</b> (close Button and "X" in application window bar)<br>
The method: <i>closeGUI()</i>is called which does the following:<ul>
<li>calls <i>checkRequiredInput</i> which makes sure all the required fields in the GUI are filled out and have valid entries</li>
<li>calls <i>update_RiversideDB_objects</i> which is called to
<b>create</b> and update the <i><b>__gui_RTi_ExportProudct</b></i> and
<i> <b>__gui_RTi_ExportConf_vect</b></i> objects in memory, mark them dirty,
and add messages to the <i>__dirty_vect</i> Vector.
</li>
<li>creates a confirmation message if the <i>__gui</i> versions are dirty,
prompting the user to verify if they want to save their changes
(all the changes are listed out from the <i>__dirty_vect</i>)</li>
<li>updates the database by calling, <i>update_database</i></li>
<li>closes the GUI and destroys it</li>
</ul> </li>
<li><b>apply</b><br>
After the <b>apply</b> button is pressed, methods are called that follow a
similar pattern as those called after the <b>close</b> button outlined above.
These methods are:<ul>
<li>checkRequired_input</li>
<li>update_RiversideDB_objects</li>
<li>update_database</li>
<li>Then, since the GUI is not being closed, the objects need to be updated
in memory to represent the new states.  Since the <i>__gui</i> objects have
been written to the database, the <i>__db</i> objects need to be updated to
represent the new database status.  To do so:<ul><li> the
<i>__db_RTi_ExportProudct</i> object is re-created, using the copy
constructor and passing in the <i>__gui_RTi_ExportProduct</i> object: <br>
<i>__db_RTi_ExportProduct = new RiversideDB_ExportProduct
( __gui_RTi_ExportProduct) </i> </li><li>the <i>__db_RTi_ExportConf_vect</i>
is cleared out and then re-filled with the ExportConf objects from the
<i>__gui_RTi_ExportConf_vect</i></li></ul> </li>
</ul>
</li>
</ul>
</body></html>
*/
public class RiversideDB_Export_JFrame
	extends    RiversideDB_EditorBase_JFrame
	implements ActionListener,
		   ItemListener,
		   WindowListener
{

// Class name
private static String __class = "RiversideDB_Export_JFrame";

//RiversideDB_DMI object - already opened
private RiversideDB_DMI __dmi = null;

//default string
String DEFAULT_str = "DEFAULT";

//layout components
GridBagLayout __gridbag = null;
Insets __insets = null;

//indicated what the action on the currently selected
//ExportProduct is- ie, if it is being added or just altered.
private boolean __bln_new_object = false;

/**
Whether the object was a new one, originally coming into the code.
*/
private boolean __originallyNewObject = false;

//components
private JPanel __main_JPanel = null;
private JPanel __top_group_JPanel = null;
private JPanel __product_info_JPanel = null;
private JPanel __close_JPanel = null;

private SimpleJButton __close_JButton = null;
private SimpleJButton __cancel_JButton = null;
private SimpleJButton __apply_JButton = null;

private JTextField __product_info_id_JTextField = null;
private SimpleJComboBox __product_info_group_JComboBox = null;

private SimpleJComboBox __product_info_type_JComboBox = null;
//REVISIT [LT] 2005-02-01 - Replace JComboBox by JTextField.
//ivate SimpleJComboBox __product_info_type_JTextField = null;
               
private JCheckBox __product_info_active_JCheckBox = null;
private SimpleJComboBox __product_info_measlocgroup_JComboBox = null;

//Tabbed pane itself
private JTabbedPane __info_JTabbedPane = null;

//FILE TAB
//string for tab - has to be short in length
private String __files_tab_str = "Files";

private JTextField __files_tab_dest_dir_JTextField = null;
private SimpleJButton __files_tab_dest_browse_JButton = null;
private JTextField __files_tab_dest_file_JTextField = null;
private SimpleJComboBox __files_tab_dest_wild_JComboBox = null;

//PROPERTY TAB
private String __props_tab_str = "Properties";

private SimpleJComboBox __props_tab_export_order_JComboBox = null;
private JCheckBox __props_tab_export_start_current_JCheckBox = null;
private SimpleJComboBox __props_tab_export_start_plusminus_JComboBox = null;
private SimpleJComboBox __props_tab_export_start_numb_JComboBox = null;
private SimpleJComboBox __props_tab_export_start_dayhr_JComboBox = null;
private JCheckBox __props_tab_export_end_current_JCheckBox = null;
private SimpleJComboBox __props_tab_export_end_plusminus_JComboBox = null;
private SimpleJComboBox __props_tab_export_end_numb_JComboBox = null;
private SimpleJComboBox __props_tab_export_end_dayhr_JComboBox = null;
private JTextField __props_tab_next_export_date_JTextField = null;
private JTextField __props_tab_last_export_date_JTextField = null;
private JTextField __props_tab_retries_JTextField = null;
private JTextField __props_tab_generic_props_JTextField = null;

//Properties specific to different exportProduct types:
//4 types: TABLE_REPORT, GRAPH_JPEG, LAST_OBS_REPORT, and SHEF.A
private String __type_table_str = "TABLE_REPORT";
private String __type_graph_str = "GRAPH";
// REVISIT (JTS - 2005-08-29)
// remove the following when the versioning transition is complete:
private String __type_graph_str_old = "GRAPH_JPEG";
private String __type_comma_str = "COMMA_DELIMITED";
private String __type_obsreport_str = "LAST_OBS_REPORT";
private String __type_shef_str = "SHEF.A";

//Comma Delimited
private String __props_dateformat_comma_JLabel_str = "DATE_FORMAT";
SimpleJComboBox __props_dateformat_comma_JComboBox = null;
private String __props_timestamp_comma_JLabel_str = "TIMESTAMP";
JCheckBox __props_timestamp_comma_JCheckBox = null;

//TABLE REPORT
private String __props_timestamp_table_JLabel_str = "TIMESTAMP";
private JCheckBox __props_timestamp_table_JCheckBox = null;
private String __props_hidemissing_table_JLabel_str = "HIDE_MISSING";
private JCheckBox __props_hidemissing_table_JCheckBox = null;
private String __props_dateformat_table_JLabel_str = "DATE_FORMAT";
private SimpleJComboBox __props_dateformat_table_JComboBox = null;
private String __props_listorder_table_JLabel_str = "LISTING_ORDER";
//private JCheckBox __props_listdesc_table_JCheckBox = null;
private SimpleJComboBox __props_listorder_table_JComboBox = null;

//GRAPH JPEG
private String __props_title_graph_JLabel_str = "TITLE";
private String __props_title_graph_JLabel_desc_str = "Title for plot";
private String __props_creationtime_graph_JLabel_str = "CREATIONTIME";
private String __props_creationtime_graph_JLabel_desc_str = "Check to add Creation Time to plot";
private String __props_timestamp_graph_JLabel_str = "TIMESTAMP";
private String __props_timestamp_graph_JLabel_desc_str = "Check to add time stamp to file name";
private String __props_windowdim_graph_JLabel_str = "WINDOWDIMENSION";
private String __props_windowdim_graph_JLabel_desc_str = "Assign window dimensions for plot (width, height in pixels)";
private String __props_dateformat_graph_JLabel_str = "DATE_FORMAT";
private String __props_dateformat_graph_JLabel_desc_str = "Choose date format";
private String __props_annotationline_graph_JLabel_str = "ANNOTATION_LINE_Y";
private String __props_annotationline_graph_JLabel_desc_str = "Add up to 2 annotation lines at specific (y) values";
private String __props_annotationtext_graph_JLabel_str = "ANNOTATION_TEXT_Y";
private String __props_annotationtext_graph_JLabel_desc_str = "Add up to 2 locations for annotation text at specific (y) values";
private String __props_range_graph_JLabel_str = "RANGE";
private String __props_range_graph_JLabel_desc_str = "Set extents for Y-axis (lower extent, upper extent)";
private JTextField __props_title_graph_JTextField = null;
private JCheckBox __props_creationtime_graph_JCheckBox = null;
private JCheckBox __props_timestamp_graph_JCheckBox = null;
private JTextField __props_windowdim_w_graph_JTextField = null;
private JTextField __props_windowdim_h_graph_JTextField = null;
private SimpleJComboBox __props_dateformat_graph_JComboBox = null;

private String __props_tsProduct_graph_JLabel_str = "TSProduct";
private SimpleJComboBox __props_tsProduct_graph_JComboBox   = null;

private JTextField __props_annotationline_1_graph_JTextField = null;
private JTextField __props_annotationline_2_graph_JTextField = null;
private JTextField __props_annotationtext_1_graph_JTextField = null;
private JTextField __props_annotationtext_2_graph_JTextField = null;
private JTextField __props_range_lo_graph_JTextField = null;
private JTextField __props_range_hi_graph_JTextField = null;

//LAST OBS REPORT
private String __props_timestamp_obsreport_JLabel_str = "TIMESTAMP";
private String __props_title_obsreport_JLabel_str = "TITLE";
private JCheckBox __props_timestamp_obsreport_JCheckBox = null;
private JTextField __props_title_obsreport_JTextField = null;
private String __props_format_obsreport_JLabel_str = "FORMAT";
private SimpleJComboBox __props_format_obsreport_JComboBox = null;
private String __props_dateformat_obsreport_JLabel_str = "DATE_FORMAT";
private SimpleJComboBox __props_dateformat_obsreport_JComboBox = null;
private String __props_deliminiter_obsreport_JLabel_str = "DELIMINITER";
private JTextField __props_deliminiter_obsreport_JTextField = null;

//SHEF.A
private String __props_timestamp_shef_JLabel_str = "TIMESTAMP";
private String __props_append_shef_JLabel_str = "APPEND";
private String __props_usehour_shef_JLabel_str = "USEHOUR24";
private JCheckBox __props_timestamp_shef_JCheckBox = null;
private JCheckBox __props_append_shef_JCheckBox = null;
private JCheckBox __props_usehour_shef_JCheckBox = null;
private String __props_dateformat_shef_JLabel_str = "DATE_FORMAT";
private SimpleJComboBox __props_dateformat_shef_JComboBox = null;

//Automation TAB
private String __automation_tab_str = "Automation";

private JCheckBox __automation_tab_automated_JCheckBox = null;
private JRadioButton __automation_tab_every_interval_JRadioButton = null;
private JRadioButton __automation_tab_at_time_JRadioButton = null;
private SimpleJComboBox __automation_tab_year_JComboBox = null;
private SimpleJComboBox __automation_tab_month_JComboBox = null;
private SimpleJComboBox __automation_tab_day_JComboBox = null;
private SimpleJComboBox __automation_tab_hour_JComboBox = null;
private SimpleJComboBox __automation_tab_minute_JComboBox = null;
private SimpleJComboBox __automation_tab_second_JComboBox = null;
private SimpleJComboBox __automation_tab_weekday_JComboBox = null;

//Security tab
//label for tab
private String __security_tab_str = "Security";

private JTextField __security_tab_user_login_JTextField = null;
private JTextField __security_tab_user_passwd_JTextField = null;
private JTextField __security_tab_firewall_login_JTextField = null;
private JTextField __security_tab_firewall_passwd_JTextField = null;

//Additional Files Tab
//private String __additFiles_tab_str = "Additional Files";
//private String __additFiles_tab_dir_str = "Directory";
//private String __additFiles_tab_browse_JButton_str = "Browse";
//private String __additFiles_tab_browse_title_str =
//"Select Directory for Additional Files";
//private String __additFiles_tab_file_str = "File";

//JTextField __additFiles_tab_dir_JTextField = null;
//JTextField __additFiles_tab_file_JTextField = null;
//SimpleJButton __additFiles_tab_browse_JButton = null;

private String __timeseries_tab_str = "Time Series";

//Units
private JList __timeseries_tab_allTS_JList = null;
private DefaultListModel __timeseries_tab_allTS_listModel = null;
JWorksheet __timeseries_tab_selTS_JWorksheet = null;
RiversideDB_ExportConf_TableModel __table_model = null;
PropList __worksheet_PropList = null;
Dimension __worksheet_dim = new Dimension( 600, 250 );
String [] __arrWorksheet_labels = null;
String [] __arrWorksheet_tooltips = null;

private SimpleJButton __timeseries_tab_clear_selected_JButton = null;
private SimpleJButton __timeseries_tab_move_right_JButton = null;

//New Group Tab
private JTextField __new_group_tab_name_JTextField = null;

//Holds RIVERSIDEDB OBJECTS and Vectors of the objects
//Holds all the ExportProduct Objects
private Vector __RTi_ExportProduct_vect = null;

//Holds the name of the Current ExportProduct Object being worked with!
RiversideDB_ExportProduct __db_RTi_ExportProduct = null;

//HOlds the ExportProduct_num of the CURRENT ExportProduct
long __db_ExportProduct_num = -999;

//Holds all the ExportConf objects
private Vector __db_RTi_ExportConf_vect = null;
private Vector __worksheet_RTi_ExportConf_vect = null;
RiversideDB_ExportConf __db_RTi_ExportConf = null;

//Holds all the MeasTypes
//private Vector __all_MeasType_vect = null;

//Holds all the MeasTypes WITH CREATE METHOD EXPORT!!!!!!!
private Vector __leftList_MeasType_vect = null;

//vector of ExportTypes
private Vector __RTi_ExportType_vect = null;

//holds text name of node being operated on
private String __db_tree_node_str = null;

private JPanel __files_tab_JPanel = null;
private JPanel __timeseries_tab_JPanel = null;
private JPanel __properties_tab_JPanel = null;
private JPanel __security_tab_JPanel = null;
private JPanel __automation_tab_JPanel = null;

//Holds objects with current, but uncommitted changes
RiversideDB_ExportProduct __gui_RTi_ExportProduct = null;
private Vector __gui_RTi_ExportConf_vect  = null;

//data type vect
private Vector __RTi_DataType_vect = null;
//MeasLocGroup vector
private Vector __RTi_MeasLocGroup_vect = null;

//HOlds the current ExportConf object selected in
//the Right-hand JList
RiversideDB_ExportConf __gui_RTi_ExportConf = null;

//Holds a Vector of status information-- each
//field that has been changed is recored in this vector.
private Vector __dirty_vect = new Vector();

//Flag to indicate if we are running in CAUTIOUS MODE---
//aka, if we prompt the user for confirmation of changes
private boolean __cautious_mode = true;

//Holds the export type used for the object in the GUI
private String __db_ExportProduct_type = null;

//DBUser
RiversideDB_DBUser __DBUser = null;
//flag to indicate if current user has write permissions.
private boolean __canWriteExportProduct = false;

/**
RiversideDB_Export_JFrame constructor.
The constructor is called by an action in one of the JTrees of the
main application.  The main application passes to this class a
RiversideDB_ExportProduct.  This class is called in one of two cases: <br>
<ul><li>to view the properties of a current ExportProduct</li>
<li>to create a new ExportProduct</li></ul>
In the case of viewing a current ExportProduct, the ExportProduct object
passed to this class is already defined and all required properties
already known.  In the case of creating a totally new ExportProduct, the
ExportProduct passed in to this class is essentially an empty skeleton,
with only the ProductGroup (parent of the ExportProduct in the JTree)
filled in. <br>
It is important to distinguish in the constructor, if we are dealing with
an existing ExportProduct and just changing some of its fields or if
we are creating a totally new ExportProduct.  If the ExportProduct_num
for the ExportProduct passed in is MISSING, then we know that we are
creating a new ExportProduct object.  In the constructor then, set
the <i>__bln_new_object = true </i> flag.  The <b><i>__bln_new_object</i></b>
flag is important because:<br>
<ul>
<li>we need to set up a dialog to ask the user what <b>type</b> of
ExportProduct they are creating (using <i>RiversideDB_ExportType</i>)
<li>we need to get an ExportProduct_num for the new ExportProduct and in
doing so, we need to actually write the ExportProduct to the database.
Once it is written to the database and the user "Cancels" out of the GUI
later without saving changes, we need to know to go back and delete the
ExportProduct</li>
<li>we can mark the object as dirty (using the <i>setDirty(true)</i> flag)
 since it is an entirely new object</li>
<li>we need to add the fields for <i>DBUser</i>, <i>DBGroup</i>, and
<i>DBPermissions</i> based on the information already known by the DMI for
this user.</li>
<li> we do not have to confirm changes made to a totally new object like we do
if the user is changing an existing object</li>
<li>we need to know to add a new node to the JTree</li></ul>
When creating a <b>new</b> ExportProduct, the most Exportant field in
to fill in is the (autonum) ExportProduct_num field mentioned above since
we can not write any updates to the database for this ExportProduct or for
its related ExportConf objects without knowing the ExportProduct_num.  By
writing the object to the database and retrieving it we can get its
ExportProduct_num. <br><br>
At this point, whether we are creating a new ExportProduct or modifying an
existing one, we assign the ExportProduct to the variable known throughout
this class as: <b><i>__gui_RTi_ExportProduct</i></b>.  We also set up
the variable known throughout this class as: <b><i>
__gui_RTi_ExportConf_vect</i></b> which is a Vector of ExportConf objects that
are related to the <i>__gui_RTi_ExportProduct</i>.  If we have created
a totally new ExportProduct, the <i>__gui_RTi_ExportConf_vect</i> is an
empty Vector; otherwise, it is a Vector of ExportConf objects read directly
from the database, based on the ExportProduct_num of the (already existing)
ExportProduct.<br><br>
Finally, the constructor also:<ul><li> sets up Vectors of (static) reference data,
read directly from the database thay will be used throughout the class</li>
<li>calls method: <i>init_layout_GUI()</i> which creates and sets up the
GUI components</li></ul><br>
@param dmi Instance of RiversideDB_DMI that has already been opened.
@param title String for title of JFrame.
@param ep RiversideDB_ExportProduct object to display in
this GUI. If a new ExportProduct is being created, the
ExportProduct_num field will be MISSING.
*/
public RiversideDB_Export_JFrame(
				RiversideDB_DMI dmi,
				RiversideDB_WindowManager windowManager,
				String title,
				RiversideDB_ExportProduct ep )
{
	super( title );

	String routine = __class + ".constructor";

	//rti icon
	JGUIUtil.setIcon( this, JGUIUtil.getIconImage() );

	// Make global
 	__dmi = dmi;
 	__db_RTi_ExportProduct =  ep;

	// Set protected member in the base RiversideDB_EditorBase_JFrame class.
 	_windowManager = windowManager;

	//get current user
	try {
 		__DBUser = __dmi.getDBUser();
	}
	catch ( Exception e ) {
		Message.printWarning( 2, routine, e );
	}


	//get vector of all ExportProduct objects...
	try {
 		__RTi_ExportProduct_vect = __dmi.readExportProductList();
	}
	catch ( Exception e ) {
		Message.printWarning( 2, routine, e );
		//create an empty vector
 		__RTi_ExportProduct_vect = new Vector();
	}

	//_RTi_ExportType_vect
	try {
 		__RTi_ExportType_vect = __dmi.readExportTypeList();
	}
	catch ( Exception e ) {
		Message.printWarning( 2, routine, e );
		Message.printWarning( 2, routine,
		"Unable to get a Vector of ExportType objects" );

 		__RTi_ExportType_vect = new Vector();
	}

	//RiversideDB_ExportProduct passed in will not be null, but if
	//we are creating a totally new ExportProduct object,
	//the ExportProduct_num will be missing
	//we are creating a totally new ExportProduct object,
	//the ExportProduct_num will be missing

	//ExportProduct_num
 	__db_ExportProduct_num = __db_RTi_ExportProduct.getExportProduct_num();
	//if ( __db_ExportProduct_num != DMIUtil.MISSING_LONG ) {}
	if ( ! DMIUtil.isMissing(__db_ExportProduct_num ) ) {
		// get the ExportType
 		__db_ExportProduct_type =
 		__db_RTi_ExportProduct.getProduct_type();

		//get list of ExportConf objects for this -save
		//in both the GUI and the DB vectors.
		try {
 			__db_RTi_ExportConf_vect = __dmi.
			readExportConfListForExportProduct_numByLocation(
			(int) __db_ExportProduct_num );

 			__worksheet_RTi_ExportConf_vect = __dmi.
			readExportConfListForExportProduct_numByLocation(
			(int) __db_ExportProduct_num );

 			__gui_RTi_ExportConf_vect = __dmi.
			readExportConfListForExportProduct_numByLocation(
			(int) __db_ExportProduct_num );
		}
		catch ( Exception e ) {
			Message.printWarning( 2, routine, e);
			Message.printWarning( 2, routine,
			"Unable to get list of ExportConf Objects");
		}

	}
	else { //we are creating a new ExportProduct
		//Create a JOptionPane with a list of choices for export
		//product TYPE... Once we have the Type, should be
		//able to assemble the GUI

		//Mark Flag to indicate we are Adding a new node.
 		__bln_new_object = true;
		__originallyNewObject = true;

		//ComboBox for Types ( ExportProduct.Product_type )
		int size= 0;
		size = __RTi_ExportType_vect.size();
		RiversideDB_ExportType et = null;
		Vector types_vect = new Vector();
		String type = null;
		String desc = null;
		for ( int i=0; i<size;i++ ) {
			et = ( RiversideDB_ExportType )
 			__RTi_ExportType_vect.elementAt(i);
			if ( et ==null ) {
				continue;
			}
			type = et.getName();
			desc = et.getComment();
			if ( (type + desc).length() > 50 ) {
				desc = desc.substring(
				0, 50-(type.length())) +
				"...";
			}
			types_vect.addElement( type + " - " + desc );
		}

		String selectedValue = (new JComboBoxResponseJDialog(this,
			"Export Product Type",
			"Choose the Export Product Type for new Export Product:"
			+ " " + ep.getProduct_name(),
			types_vect, ResponseJDialog.OK | ResponseJDialog.CANCEL,
			false, types_vect.size())).response();

		Message.printStatus( 50,routine,
		"selected value = "+selectedValue );
		if (selectedValue == null) {
			//cancel was pressed...
			//setVisible(false);
			//dispose();
			windowManagerClose();
		}

		String new_type = ( String )selectedValue;
		int index = -999;
		index = new_type.indexOf("-");
		if ( index > 0 ) {
 			__db_ExportProduct_type = new_type.
			substring( 0,index).trim();
		}

		//remove comment field.
		int ind = -999;
		ind = __db_ExportProduct_type.indexOf( " -");
		if ( ind > 0 ) {
 			__db_ExportProduct_type = __db_ExportProduct_type.
			substring( 0, ind ).trim();
		}

		if ( Message.isDebugOn ) {
			Message.printDebug( 3, routine,
			"_db_ExportProduct_type selected: " +
			__db_ExportProduct_type );
		}

		//set object to dirty so it will definitely be
		//written out to the database.
 		__db_RTi_ExportProduct.setDirty( true );

		//Make sure to set the NAME in the Object
 		__db_RTi_ExportProduct.setProduct_name ("");

		//fill in object with default choices and leave
		//product dirty so that we can write this object to
		//the database as is and get its ExportProduct number
 		__db_RTi_ExportProduct.setProduct_type( __db_ExportProduct_type);
 		__db_RTi_ExportProduct.setProduct_group( "GENERAL" );
 		__db_RTi_ExportProduct.setIsActive( "Y" );
 		__db_RTi_ExportProduct.setIsInterval( "N" );
 		__db_RTi_ExportProduct.setIsAutomated( "N" );
 		__db_RTi_ExportProduct.setExport_order( 99 );
		Date today = new Date();
 		__db_RTi_ExportProduct.setLast_export_date( today );
 		__db_RTi_ExportProduct.setNext_export_date( today );
 		
 		__db_RTi_ExportProduct.setTSProduct_num( 1 );

		//set User permissions since this is a new object.
 		__db_RTi_ExportProduct.
		setDBUser_num( __DBUser.getDBUser_num() );
 		__db_RTi_ExportProduct.
		setDBGroup_num( __DBUser.getPrimaryDBGroup_num());
 		__db_RTi_ExportProduct.setDBPermissions(
 		__DBUser.getDefault_DBPermissions() );

		//make new (empty) vector of ExportConf objects
 		__db_RTi_ExportConf_vect = new Vector();
 		__gui_RTi_ExportConf_vect = new Vector();
 		__worksheet_RTi_ExportConf_vect = new Vector();

		//In order to be able to create new ExportConf objects,
		//we need an ExportProduct number, a MeasType number,
		//and a MeasLocGroup_num
		//The MeasType num will come from the TimeSeries when
		//they are selected on the TimeSeries tab.
		//Since we have created a new ExportProduct, we need
		//to write it to the database before we can get its (autonum)
		//ExportProd_num
		if ( __RTi_MeasLocGroup_vect == null ) {
			try {
				__RTi_MeasLocGroup_vect =
				__dmi.readMeasLocGroupList();
			}
			catch ( Exception e ) {
				Message.printWarning( 2, routine, e );
				//create an empty vector
				__RTi_MeasLocGroup_vect = new Vector();
			}
		}
		int num = 0;
		if ( __RTi_MeasLocGroup_vect != null ) {
			num = __RTi_MeasLocGroup_vect.size();
		}
		RiversideDB_MeasLocGroup mlg = null;
		if ( num > 0 ) {
			mlg = 	(RiversideDB_MeasLocGroup)
			__RTi_MeasLocGroup_vect.elementAt(0);
			__db_RTi_ExportProduct.setMeasLocGroup_num(
			mlg.getMeasLocGroup_num() );
		}
		mlg = null;


		try {
			//write product (returns an ExportProduct object)
 			__db_RTi_ExportProduct =
 			__dmi.writeExportProduct( __db_RTi_ExportProduct );
			Message.printStatus( 15, routine,
			"ExportProduct written to database." );
		}
		catch ( Exception e ) {
			Message.printWarning( 2, routine, e );
		}
 		__db_ExportProduct_num = __db_RTi_ExportProduct.
		getExportProduct_num();
	}

	//see if user has permissions to change this ExportProduct
	try {
 		__canWriteExportProduct =
 		__dmi.canWrite( __db_RTi_ExportProduct.getDBUser_num(),
 		__db_RTi_ExportProduct.getDBGroup_num(),
 		__db_RTi_ExportProduct.  getDBPermissions() );
	}
	catch ( Exception e ) {
		Message.printWarning ( 2, routine, e);
	}
	//make shared layout paramaters
 	__gridbag =  new GridBagLayout();
 	__insets = new Insets( 2, 2, 2, 2 );

	// create/layout the GUI ...
	init_layout_GUI( );

	//add window listener
	addWindowListener ( this );

	//setup frame to do nothing on close so that we can take over
	//control of window events.
	setDefaultCloseOperation( JFrame.DO_NOTHING_ON_CLOSE );

	setResizable( false );
}

/**
Method adds all the components to a JPanel for the AUTOMATION tab.
@return JPanel with all the components.
*/
public JPanel assemble_tab_automation( ) {
	String routine = __class + ".assemble_tab_automation";

	JPanel auto_JPanel = new JPanel();
	auto_JPanel.setLayout( __gridbag );

	//isAutomated CheckBox WITH LABEL "Automated"
 	__automation_tab_automated_JCheckBox = new JCheckBox(
	"Export Is Automated");
 	__automation_tab_automated_JCheckBox.setToolTipText(
	"Required: Check if Export is automated");

	//give it a listener to listen for when it is clicked and unclicked
 	__automation_tab_automated_JCheckBox.addActionListener( this );

	//RadioButton WITH Label "every interval"
 	__automation_tab_every_interval_JRadioButton = new JRadioButton(
	"Export When Interval Matches" ) ;
 	__automation_tab_every_interval_JRadioButton.setToolTipText(
	"Required: Select to set automation interval" );

	//checkbox with LABEL "at time"
 	__automation_tab_at_time_JRadioButton = new JRadioButton(
	"Export at Time" );
 	__automation_tab_at_time_JRadioButton.setToolTipText(
	"Required: Select to set automation time" );

	//make button group to add these check boxes to so that
	//only 1 can be checked at a time
	ButtonGroup group = new ButtonGroup();
	group.add( __automation_tab_every_interval_JRadioButton );
	group.add( __automation_tab_at_time_JRadioButton );

	//year label "Year"
	JLabel automation_tab_year_JLabel = new JLabel( "Year:" );
	automation_tab_year_JLabel.setToolTipText(
	"Required if automated: Select year" );

	//year Combobox
	Vector yr_vect = new Vector();
	yr_vect.addElement( "* - All" );
 	__automation_tab_year_JComboBox = new SimpleJComboBox( yr_vect );

	//month label "month"
	JLabel automation_tab_month_JLabel = new JLabel( "Month: " );
	automation_tab_month_JLabel.setToolTipText(
	"Required if automated: Select month" );

	//month JComboBox
	Vector mo_vect = new Vector();
	mo_vect.addElement( "* - All" );
	for ( int i=1; i<=12; i++ ) {
		mo_vect.addElement( String.valueOf(i) + " - " +
		TimeUtil.monthAbbreviation( i ) );
	}
 	__automation_tab_month_JComboBox = new SimpleJComboBox( mo_vect );
 	__automation_tab_month_JComboBox.addItemListener( this );

	//day label "Day"
	JLabel automation_tab_day_JLabel = new JLabel( "Day: " );
	automation_tab_day_JLabel.setToolTipText(
	"Required if automated: Select day" );

	//day JComboBox
	Vector day_vect = new Vector();
	day_vect.addElement("* - All" );
	//default, fill with 31
	for ( int i=1; i<=31; i++ ) {
		day_vect.addElement( String.valueOf(i) );
	}
 	__automation_tab_day_JComboBox = new SimpleJComboBox( day_vect );

	//hour label "hour"
	JLabel automation_tab_hour_JLabel = new JLabel( "Hour: " );
	automation_tab_hour_JLabel.setToolTipText(
	"Required if automated: Select hour" );

	//hour JComboBox
	Vector hour_vect = new Vector();
	hour_vect.addElement("* - All" );
	for ( int i=0; i<=23; i++ ) {
		hour_vect.addElement( String.valueOf(i) );
	}
 	__automation_tab_hour_JComboBox = new SimpleJComboBox( hour_vect );

	//minute label "minute"
	JLabel automation_tab_minute_JLabel = new JLabel( "Minute: " );
	automation_tab_minute_JLabel.setToolTipText(
	"Required if automated: Select minute" );

	//minute JCombobox
	Vector min_vect = new Vector();
	min_vect.addElement("* - All" );
	for ( int i=0; i<=59; i++ ) {
		min_vect.addElement( String.valueOf(i) );
	}
 	__automation_tab_minute_JComboBox = new SimpleJComboBox( min_vect );

	//second label "second"
	JLabel automation_tab_second_JLabel = new JLabel( "Second: " );
	automation_tab_second_JLabel.setToolTipText(
	"Required if automated: Select second" );

	//second JComboBox
	Vector sec_vect = new Vector();
	sec_vect.addElement("* - All" );
	for ( int i=0; i<=59; i++ ) {
		sec_vect.addElement( String.valueOf(i) );
	}
 	__automation_tab_second_JComboBox = new SimpleJComboBox( sec_vect );

	//weedkay label "weekday"
	JLabel automation_tab_weekday_JLabel = new JLabel( "Weekday: " );
	automation_tab_weekday_JLabel.setToolTipText(
	"Required if automated: Select weekday" );

	//weekday combo box (days of week)
	String [] arr_days = null;
	arr_days = TimeUtil.DAY_NAMES;
	Vector days_vect = new Vector();
	days_vect.addElement( "* - All" );
	for ( int i=0; i<arr_days.length; i++ ) {
		days_vect.addElement( String.valueOf(i) + " - " + arr_days[i] );
	}
 	__automation_tab_weekday_JComboBox = new SimpleJComboBox( days_vect );
	JGUIUtil.setEnabled( __automation_tab_weekday_JComboBox, false );

	//Assemble
	try {
	//ADD isAutomated CheckBox with label "Automated"
	//top, left, bottom, right
	int y = 0;
	int x = 0;
	JGUIUtil.addComponent(
		auto_JPanel, __automation_tab_automated_JCheckBox,
		x, y, 3, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.EAST );

	//ADD Export checkbox With Label "when interval matches"
	JGUIUtil.addComponent(
		auto_JPanel, __automation_tab_every_interval_JRadioButton,
		x, ++y, 3, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.EAST );

	//ADD at time checkbox with Label "at time"
	++x;
	++x;
	JGUIUtil.addComponent(
		auto_JPanel, __automation_tab_at_time_JRadioButton,
		++x, y, 2, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

	//ADD year label "Year"
	//--x;
	x=0;
	JGUIUtil.addComponent(
		auto_JPanel, automation_tab_year_JLabel,
		x, ++y, 1, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.EAST );

	//ADD year textfield
	JGUIUtil.addComponent(
		auto_JPanel, __automation_tab_year_JComboBox,
		++x, y, 2, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

	//ADD month label "month"
	--x;
	JGUIUtil.addComponent(
		auto_JPanel, automation_tab_month_JLabel,
		x, ++y, 1, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.EAST );

	//ADD month textfield
	JGUIUtil.addComponent(
		auto_JPanel, __automation_tab_month_JComboBox,
		++x, y, 2, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

	--x;
	//ADD day label "Day"
	JGUIUtil.addComponent(
		auto_JPanel, automation_tab_day_JLabel,
		x, ++y, 1, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.EAST );

	//ADD day textfield
	JGUIUtil.addComponent(
		auto_JPanel, __automation_tab_day_JComboBox,
		++x, y, 2, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

	--x;
	//ADD hour label "hour"
	JGUIUtil.addComponent(
		auto_JPanel, automation_tab_hour_JLabel,
		x, ++y, 1, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.EAST );

	//ADD hour textfield
	JGUIUtil.addComponent(
		auto_JPanel, __automation_tab_hour_JComboBox,
		++x, y, 2, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

	--x;
	//ADD minute label "minute"
	JGUIUtil.addComponent(
		auto_JPanel, automation_tab_minute_JLabel,
		x, ++y, 1, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.EAST );

	//ADD minute textfield
	JGUIUtil.addComponent(
		auto_JPanel, __automation_tab_minute_JComboBox,
		++x, y, 2, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

	--x;
	//ADD second label "second"
	JGUIUtil.addComponent(
		auto_JPanel, automation_tab_second_JLabel,
		x, ++y, 1, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.EAST );

	//ADD second textfield
	JGUIUtil.addComponent(
		auto_JPanel, __automation_tab_second_JComboBox,
		++x, y, 2, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

	--x;
	//ADD weedkay label "weekday"
	JGUIUtil.addComponent(
		auto_JPanel, automation_tab_weekday_JLabel,
		x, ++y, 1, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.EAST );

	//ADD weekday combo box (days of week)
	JGUIUtil.addComponent(
		auto_JPanel, __automation_tab_weekday_JComboBox,
		++x, y, 2, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

	}
	catch ( Exception e ) {
		Message.printWarning( 2, routine, e);
		Message.printWarning( 2, routine,
		"Unable to create automation tab components." );
	}

	return auto_JPanel;
} //end assemble_tab_automation

/**
Method adds all the components to a JPanel for the Files tab.
@return JPanel with all the components.
*/
public JPanel assemble_tab_files( ) {

	JPanel files_JPanel = new JPanel();
	files_JPanel.setLayout( __gridbag );

	//make label for destination dir
	JLabel files_tab_dest_dir_JLabel = new JLabel(
 	"Destination Directory:" );
	files_tab_dest_dir_JLabel.setToolTipText(
	"Required: Type in or browse for Export Product's destination " +
	"directory (without file name)" );

	//make textfield for entering destination dir
 	__files_tab_dest_dir_JTextField = new JTextField( 30 );

	//make BUtton for browsing to destination dir
 	__files_tab_dest_browse_JButton = new SimpleJButton( "Browse", this );
 	__files_tab_dest_browse_JButton.setToolTipText(
	"Browse for directory" );

	//make label for destination file
	JLabel files_tab_dest_file_JLabel = new JLabel(
 	"Destination File(s):" );
	files_tab_dest_file_JLabel.setToolTipText(
	"Required: Type in name to save Export Product, using " +
	"wildcards if needed." );

	//make textfield for entering destination file
 	__files_tab_dest_file_JTextField = new JTextField( 15  );
	if (__db_ExportProduct_type.equalsIgnoreCase(__type_graph_str)
	    || __db_ExportProduct_type.equalsIgnoreCase(__type_graph_str_old)) {
		__files_tab_dest_file_JTextField.setToolTipText(
		"<html>Enter the name of the output graph image file to write."
		+ "<br>"
		+ "If the name ends with '.jpeg' or '.jpg', a JPEG image file "
		+ "will be written.<br>"
		+ "If the name ends in '.png', a PNG image file will be "
		+ "written.<br>"
		+ "PNG images tend to be smaller than similar JPEG images, and "
		+ "have no distortion or fuzziness.<br>"
		+ "<b>Note:</b> If no extension is added to the filename, a "
		+ "PNG file will be written.<br>"
		+ "<b>Note:</b> The extensions are not case-sensitive.  e.g, "
		+ "'.jpeg' and '.JPEG' will be treated the same.");
	}

	//Use wildcard to get destination file names
	JLabel files_tab_dest_wild_JLabel = new JLabel( "Wildcards:" );
	files_tab_dest_wild_JLabel.setToolTipText( "<HTML>" +
	"Optional: use wildcards to define file name for Export Product." +
	"<BR>Wildcards will be appended to file name</HTML>");

	//but make new SimpleJComboBox
	Vector wild_vect = new Vector();
	//EXPORTS do not have source files...
	//wild_vect.addElement("%F - Substitute file name, no extension, from Source File(s)");
	//wild_vect.addElement("%E - Substitute extension given in Source File(s)");
	wild_vect.addElement("%Y - Substitute current year (4 digits)" );
	wild_vect.addElement("%2Y - Substitute current year (2 digits)" );
	wild_vect.addElement("%M - Substitute current month (2 digits" );
	wild_vect.addElement("%D - Substitute current day (2 digits)" );
	wild_vect.addElement("%H - Substitute current hour (2 digits)" );
	wild_vect.addElement("%N - Substitute current minute (2 digits)" );
	wild_vect.addElement("%S - Substitute current second (2 digits)" );


 	__files_tab_dest_wild_JComboBox = new SimpleJComboBox( wild_vect );
 	JGUIUtil.setEnabled(__files_tab_dest_wild_JComboBox, true );
 	__files_tab_dest_wild_JComboBox.addActionListener( this );

	//now assemble panel
	int y =0;
	int x =0;
	//label for destination directory
	JGUIUtil.addComponent(
		files_JPanel, files_tab_dest_dir_JLabel,
		x, y, 1, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.EAST );

	//text field to enter name of destination directory
	JGUIUtil.addComponent(
		files_JPanel, __files_tab_dest_dir_JTextField,
		++x, y, 3, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

	//Button to browse for destination directory name
	++x;
	++x;
	JGUIUtil.addComponent(
		files_JPanel, __files_tab_dest_browse_JButton,
		++x, y, 1, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

	//label for destination file
	JGUIUtil.addComponent(
		files_JPanel, files_tab_dest_file_JLabel,
		0, ++y, 1, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.EAST );

	//text field to enter name of destination file
	JGUIUtil.addComponent(
		files_JPanel, __files_tab_dest_file_JTextField,
		1, y, 1, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

	//LABEL for ComboBox to select wildcard for destination file
	JGUIUtil.addComponent(
		files_JPanel, files_tab_dest_wild_JLabel,
		2, y, 1, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.EAST );

	//ComboBox to select wildcard for destination file
	JGUIUtil.addComponent(
		files_JPanel, __files_tab_dest_wild_JComboBox,
		3, y, 2, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

	return files_JPanel;

} //end assemble_tab_files

/**
Method adds all the components to a JPanel for the New GROUP tab.
@return JPanel with all the components.
*/
public JPanel assemble_tab_new_group( ) {

	//Make panel to hold everything.  This will be returned.
	JPanel newGroup_JPanel = new JPanel();
	newGroup_JPanel.setLayout( __gridbag );

	//Label for name of new product
	JLabel new_group_tab_name_JLabel = new JLabel ("Name of New Group: ");
	new_group_tab_name_JLabel.setToolTipText("Required: name of new group" );

	//TextField to enter actual name
 	__new_group_tab_name_JTextField = new JTextField( 20 );

	//assemble components
	//label
	JGUIUtil.addComponent(
		newGroup_JPanel, new_group_tab_name_JLabel,
		0, 0, 1, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.EAST );
		//GridBagConstraints.WEST );

	//text field
	JGUIUtil.addComponent(
		newGroup_JPanel, __new_group_tab_name_JTextField,
		1, 0, 1, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

	return newGroup_JPanel;

} //end assemble_tab_new_group

/**
Method adds all the components to a JPanel for the Properties tab.
@return JPanel with all the components.
*/
public JPanel assemble_tab_properties( ) {
	String routine = __class + ".assemble_tab_properties";

	//Make panel to hold everything.  This will be returned.
	JPanel props_JPanel = new JPanel();
	props_JPanel.setLayout( __gridbag );

	//Label for Export Order
	JLabel props_tab_export_order_JLabel = new JLabel( "Export Order: " );
	props_tab_export_order_JLabel.setToolTipText(
	"Required: Select export order (2 is recommended)" );

	//Description for Export Order
	JLabel props_tab_export_order_desc_JLabel = new JLabel(
 	"2 is recommended" );

	//TextField for Export Order
	Vector order_vect = new Vector();
	//Michael originally said to start at 2, but there is
	//data in the db that starts with 1...
	for ( int i=0;i<15;i++ ) {
		order_vect.addElement( String.valueOf(i) );
	}
	order_vect.addElement("99");
 	__props_tab_export_order_JComboBox = new SimpleJComboBox( order_vect );
 	__props_tab_export_order_JComboBox.setSelectedIndex(3);

	//Label for Export Start
	JLabel props_tab_export_start_JLabel = new JLabel(
 	"Export Start Date: ");
	props_tab_export_start_JLabel.setToolTipText(
	"Required: Create export start date by setting an interval or select \"current\" to use current date" );
	//Description for Export Start
	JLabel props_tab_export_start_desc_JLabel = new JLabel(
	"Select \"CURRENT\" check box or define an interval using choices" );

	//Components for for Export Start
	//JCheckBox for CURRENT
 	__props_tab_export_start_current_JCheckBox =
	new JCheckBox( "CURRENT" );
 	__props_tab_export_start_current_JCheckBox.addActionListener( this );
	__props_tab_export_start_current_JCheckBox.setToolTipText("<HTML>" +
	"Select \"CURRENT\" to set Export Date to start at current date." +
	"<BR>If \"CURRENT\" is selected, the fields to set interval " +
	" are disabled</HTML>");

	//JComboBox with choices: "+" and "-"
	Vector plus_minus_vect = new Vector();
	plus_minus_vect.addElement("+");
	plus_minus_vect.addElement("-");

 	__props_tab_export_start_plusminus_JComboBox = new SimpleJComboBox(
	plus_minus_vect );

	//Editable JComboBox with choices: 1-31
	Vector numb_vect = new Vector();
	for ( int i=1; i<=31; i++ ) {
		numb_vect.addElement( String.valueOf( i ) );
	}

 	__props_tab_export_start_numb_JComboBox = new SimpleJComboBox(
	numb_vect );
 	__props_tab_export_start_numb_JComboBox.setEditable( true );
 	__props_tab_export_start_numb_JComboBox.addActionListener( this );

	//JComboBox with choices: DAY and HOUR
	Vector day_hr_vect = new Vector();
	day_hr_vect.addElement( "DAY" );
	day_hr_vect.addElement( "HOUR" );

 	__props_tab_export_start_dayhr_JComboBox = new SimpleJComboBox(
	day_hr_vect );

	//Label for Export End
	JLabel props_tab_export_end_JLabel = new JLabel( "Export End Date: ");
	props_tab_export_end_JLabel.setToolTipText(
	"Required: Create export end date by setting an interval or select \"current\" to use current date" );
	//Description for Export Start
	//Description for Export END
	JLabel props_tab_export_end_desc_JLabel = new JLabel(
	"Select \"CURRENT\" check box or define an interval using choices" );

	//Components for for Export END
	//JCheckBox for CURRENT
 	__props_tab_export_end_current_JCheckBox =
	new JCheckBox( "CURRENT" );
 	__props_tab_export_end_current_JCheckBox.addActionListener( this );
	__props_tab_export_end_current_JCheckBox.setToolTipText("<HTML>" +
	"Select \"CURRENT\" to set Export Date to end at current date." +
	"<BR>If \"CURRENT\" is selected, the fields to set interval " +
	" are disabled</HTML>");

	//JComboBox with choices: "+" and "-"
 	__props_tab_export_end_plusminus_JComboBox = new SimpleJComboBox(
	plus_minus_vect );

	//Editable JComboBox with choices: 1-31
 	__props_tab_export_end_numb_JComboBox = new SimpleJComboBox(
	numb_vect );
 	__props_tab_export_end_numb_JComboBox.setEditable( true );
 	__props_tab_export_end_numb_JComboBox.addActionListener( this );

	//JComboBox with choices: DAY and HOUR
 	__props_tab_export_end_dayhr_JComboBox = new SimpleJComboBox(
	day_hr_vect );

	//set size of both start and end editable JComboBoxes
	//( otherwise these editable JComboBoxes are too wide )
	Dimension d = __props_tab_export_end_dayhr_JComboBox.
	getPreferredSize();
 	__props_tab_export_end_numb_JComboBox.setPreferredSize( d );
 	__props_tab_export_start_numb_JComboBox.setPreferredSize( d );

	//set size of +/- JComboBox to be slightly larger than what it
	//defaults to - have it match the size of the JComboBox above
	//it with the Order options.
	d = __props_tab_export_order_JComboBox.getPreferredSize();
 	__props_tab_export_end_plusminus_JComboBox.setPreferredSize( d );
 	__props_tab_export_start_plusminus_JComboBox.setPreferredSize( d );
	d = null;

	//Label for Last Export Date
	JLabel props_tab_last_export_date_JLabel = new JLabel(
 	"Last Export Date/Time: " );
	props_tab_last_export_date_JLabel.setToolTipText(
	"Uneditable: last export date and time (set from RiverTrak)" );

	//Description/Format label for Last Export Date
	JLabel props_tab_last_export_date_desc_JLabel = new JLabel(
	"(YYYY-MM-DD HH:mm:ss) " + "Set by RiverTrak Forecaster/Watcher" );

	//Label for Next Export Date
	JLabel props_tab_next_export_date_JLabel = new JLabel(
 	"Next Export Date/Time: " );
	props_tab_next_export_date_JLabel.setToolTipText(
	"Required: Set date and time for next export" );

	//Description/Format label for Next Export Date
	JLabel props_tab_next_export_date_desc_JLabel = new JLabel(
	"(YYYY-MM-DD HH:mm:ss) " + "Used/set by RiverTrak Forecaster/Watcher" );

	//TextField for Export Date
	//non - editable for LAST date
 	__props_tab_last_export_date_JTextField = new JTextField( 14 );
 	JGUIUtil.setEnabled( __props_tab_last_export_date_JTextField, false );
	//editable for next
 	__props_tab_next_export_date_JTextField = new JTextField( 14 );

	//Label for Retries
	JLabel props_tab_retries_JLabel = new JLabel( "Retries: " );
	props_tab_retries_JLabel.setToolTipText(
	"Uneditable: Number of retries for export (set by RiverTrak)" );

	//Description for Retries
	JLabel props_tab_retries_desc_JLabel = new JLabel(
	"Set by RiverTrak Forecaster/Watcher" );

	//JTextField for Retries - noneditable
 	__props_tab_retries_JTextField = new JTextField( 3 );
 	JGUIUtil.setEnabled(__props_tab_retries_JTextField, false );

	//all ExportProduct also have a property for
	//DATE_FORMAT
	Vector dateformats_vect = new Vector();
	dateformats_vect.addElement( DEFAULT_str );
	dateformats_vect.addElement( "FORMAT_MM_SLASH_DD_SLASH_YY - MM/DD/YY" );
	dateformats_vect.addElement(
	"FORMAT_MM_SLASH_DD_SLASH_YYYY - MM/DD/YYYY" );
	dateformats_vect.addElement(
	"FORMAT_MM_SLASH_DD_SLASH_YYYY_HH  - MM/DD/YYYY HH" );
	dateformats_vect.addElement( "FORMAT_MM_DD_YYYY_HH - MM-DD-YYYY HH" );
	dateformats_vect.addElement(
	"FORMAT_MM_SLASH_DD_SLASH_YYYY_HH_mm - MM/DD/YYYY HH:mm" );
	dateformats_vect.addElement( "FORMAT_YYYY_MM_DD_HH - YYYY-MM-DD HH" );
	dateformats_vect.addElement(
	"FORMAT_YYYY_MM_DD_HH_mm - YYYY-MM-DD HH:mm" );
	dateformats_vect.addElement(
	"FORMAT_YYYY_MM_DD_HHmm - YYYY-MM-DD HHmm" );

	//PROPERTIES...
	//LAST_OBS_REPORT Properties
	if (__db_ExportProduct_type.equalsIgnoreCase(__type_graph_str)
	    || __db_ExportProduct_type.equalsIgnoreCase(__type_graph_str_old)) {
		// TITLE
		__props_title_graph_JTextField = new JTextField( 25 );
		__props_title_graph_JTextField.setToolTipText(
		"Optional: Enter title for graph (default is blank)" );

		// TSProduct
		Vector tsProductString_vect = new Vector();
		try {
			Vector tsProduct_vect = __dmi.readTSProductList();
			if ( tsProduct_vect != null ) {
				int nP = tsProduct_vect.size();
				for ( int n=0; n<nP; n++) {
					RiversideDB_TSProduct rdb_tsp =
					   (RiversideDB_TSProduct)
						tsProduct_vect.elementAt(n);
					tsProductString_vect.addElement(rdb_tsp.getName() );	
				}
			}
		} catch ( Exception e ) {   
			Message.printWarning (1, routine, "Error reading TSProduct Table");
		}
		__props_tsProduct_graph_JComboBox = new SimpleJComboBox( tsProductString_vect );
		__props_tsProduct_graph_JComboBox.setToolTipText("Select TSProduct" );

		//creationtime
		__props_creationtime_graph_JCheckBox = new JCheckBox(
		__props_creationtime_graph_JLabel_str, true);
		__props_creationtime_graph_JCheckBox.setToolTipText(
		"Optional: Check to write creation time on graph " +
		"(Default is to have creation time on graph)" );

		//timestamp
		__props_timestamp_graph_JCheckBox = new JCheckBox(
		__props_timestamp_graph_JLabel_str, false);
		__props_timestamp_graph_JCheckBox.setToolTipText(
		"Optional: Check to add time stamp to file name" );

		//WINDOWDIMENSION
		__props_windowdim_w_graph_JTextField = new JTextField( 5 );
		__props_windowdim_w_graph_JTextField.setToolTipText(
		"Optional: Enter integer for width of graph" );
		__props_windowdim_h_graph_JTextField = new JTextField( 5 );
		__props_windowdim_h_graph_JTextField.setToolTipText(
		"Required (if value for width is entered): Enter integer for height of graph" );

		//DATE FORMAT
		__props_dateformat_graph_JComboBox = new SimpleJComboBox(
		dateformats_vect );
		__props_dateformat_graph_JComboBox.setToolTipText(
		"Optional: Select format date will appear on graph" );

		//Annotation LINES
		__props_annotationline_1_graph_JTextField =
		new JTextField( 5 );
		__props_annotationline_1_graph_JTextField.setToolTipText(
		"Optional: Enter number for one reference line to appear (horizontally) on graph" );
		__props_annotationline_2_graph_JTextField =
		new JTextField( 5 );
		__props_annotationline_2_graph_JTextField.setToolTipText(
		"Optional: Enter number for second reference line to appear (horizontally) on graph" );

		//Annotation Text position
		__props_annotationtext_1_graph_JTextField =
		new JTextField( 5 );
		__props_annotationtext_1_graph_JTextField.setToolTipText(
		"Optional: Enter number for one annotation text location on graph" );
		__props_annotationtext_2_graph_JTextField =
		new JTextField( 5 );
		__props_annotationtext_2_graph_JTextField.setToolTipText(
		"Optional: Enter number for second annotation text location on graph" );

		//RANGE
		__props_range_lo_graph_JTextField = new JTextField( 5 );
		__props_range_hi_graph_JTextField = new JTextField( 5 );
	}
	else if( __db_ExportProduct_type.equalsIgnoreCase( __type_comma_str ) ) {
		//make combobox
 		__props_dateformat_comma_JComboBox = new SimpleJComboBox(
		dateformats_vect );
 		__props_dateformat_comma_JComboBox.setToolTipText(
		"Optional: select date format displayed on export products.");

		//make JCheckBox for TimeStamp
 		__props_timestamp_comma_JCheckBox = new JCheckBox( );
 		__props_timestamp_comma_JCheckBox.setToolTipText(
		"Optional: Check to include time stamp in file name");

	}
	else if( __db_ExportProduct_type.equalsIgnoreCase( __type_obsreport_str ) ) {
		//TITLE
 		__props_title_obsreport_JTextField = new JTextField( 15 );
 		__props_title_obsreport_JTextField.setToolTipText(
		"Optional: Title for plot. Default is: \"Last Observations\"");

		//Timestamp
 		__props_timestamp_obsreport_JCheckBox = new JCheckBox(
 		__props_timestamp_obsreport_JLabel_str );
 		__props_timestamp_obsreport_JCheckBox.setToolTipText(
		"Optional: Check to add time stamp to file name");

		//Date Format
 		__props_dateformat_obsreport_JComboBox = new SimpleJComboBox(
		dateformats_vect );
 		__props_dateformat_obsreport_JComboBox.setToolTipText(
		"<html>Optional: Select date format for date display "+
		"next to title.<br>Default is: YYYY-MM-DD hh:mm:ss</html>");

		//format ascii text file or HTML
		Vector format_vect = new Vector();
		format_vect.addElement("HTML - HTML file");
		format_vect.addElement("TXT - ASCII text file");
		__props_format_obsreport_JComboBox = new SimpleJComboBox(
		format_vect );

		//add actionlistener to enable/disable delimiter field
		//depending on if TXT is selected (then need deliminiter)
		//or HTML is selected
 		__props_format_obsreport_JComboBox.addActionListener( this );
		__props_format_obsreport_JComboBox.setToolTipText(
		"Optional: Select format for output file.  HTML is " +
		"the default format.");

		//if text file, the deliminiter to use
		__props_deliminiter_obsreport_JTextField = new JTextField("TAB", 5);
		//since HTML is selected by default for format,
		//delimiter is not used.
		JGUIUtil.setEnabled(
		__props_deliminiter_obsreport_JTextField, false );
		__props_deliminiter_obsreport_JTextField.setToolTipText(
		"<html>Optional: Enter character(s) to use as a deliminiter " +
		"between values in TEXT file (TXT)." +
		"<br>Enter: the word \"TAB\" to "+
		"use tab as deliminter (default is to use TAB)<br>"+
		"Enter a comma (,) for comma deliminted files</html>" );
	}

	//TABLE PROPERTIES
	else if( __db_ExportProduct_type.equalsIgnoreCase( __type_table_str ) ) {
		//Timestamp
 		__props_timestamp_table_JCheckBox = new JCheckBox(
 		__props_timestamp_table_JLabel_str );
 		__props_timestamp_table_JCheckBox.setToolTipText(
		"Optional: Select to add a time stamp to file name." );

		//hideMISSING
 		__props_hidemissing_table_JCheckBox = new JCheckBox(
 		__props_hidemissing_table_JLabel_str );
 		__props_hidemissing_table_JCheckBox.setToolTipText(
		"Optional: Select to include Missing data in exported table data.");

		//DATE_FORMAT
 		__props_dateformat_table_JComboBox = new SimpleJComboBox(
		dateformats_vect );
 		__props_dateformat_table_JComboBox.setToolTipText(
		"Optional: select date format for date display in exported table data." );
		//LISTING_ORDER
		Vector list_vect = new Vector();
		list_vect.addElement( "DATE_DESCENDING" );
		list_vect.addElement( "DATE_ASCENDING" );
 		__props_listorder_table_JComboBox = new SimpleJComboBox( list_vect);
 		__props_listorder_table_JComboBox.setToolTipText( "<HTML>"+
		"Select \"DATE_DESCENDING\" to indicate that table lists " +
		"items in descending order.<BR> " +
		"Select \"DATE_ASCENDING\" to have items in ascending order." );
	}
	else if( __db_ExportProduct_type.equalsIgnoreCase( __type_shef_str ) ) {
		//TIMESTAMP
 		__props_timestamp_shef_JCheckBox = new JCheckBox(
 		__props_timestamp_shef_JLabel_str );
 		__props_timestamp_shef_JCheckBox.setToolTipText(
		"Select to add timestamp to exported shef product file name" );

		//APPEND
 		__props_append_shef_JCheckBox = new JCheckBox(
 		__props_append_shef_JLabel_str );
 		__props_append_shef_JCheckBox.setToolTipText(
		"Select to append shef data" );

		//USEHOUR24
 		__props_usehour_shef_JCheckBox = new JCheckBox(
 		__props_usehour_shef_JLabel_str );
 		__props_usehour_shef_JCheckBox.setToolTipText(
		"Select to use hour for export shef product" );

		//date format
 		__props_dateformat_shef_JComboBox = new SimpleJComboBox(
		dateformats_vect );
 		__props_dateformat_shef_JComboBox.setToolTipText(
		"Optional: select date format for date display in exported table data." );
	}
	else {
		//GENERIC PROPERTIES -- non-type specific
		//TextField for Properties
 		__props_tab_generic_props_JTextField = new JTextField( 40 );
	}

	//Assemble panel
	//Add Label for Export Window
	int y =0;
	int x =0;
	// Label for Export Order
	JGUIUtil.addComponent(
		props_JPanel, props_tab_export_order_JLabel,
		x, y, 1, 1, 0.0, 0.0,
		GridBagConstraints.NONE,
		GridBagConstraints.EAST );

	//Add ComboBox for Export Order
	JGUIUtil.addComponent(
		props_JPanel, __props_tab_export_order_JComboBox,
		++x, y, 2, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

	//Add Description for Export Order
//aml
	++x;
	JGUIUtil.addComponent(
		props_JPanel, props_tab_export_order_desc_JLabel,
		++x, y, 3, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

	x=0;
	//label for Export start
	JGUIUtil.addComponent(
		props_JPanel, props_tab_export_start_JLabel,
		x, ++y, 1, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.EAST );

	//JCheckBox for Export Start
	JGUIUtil.addComponent(
		props_JPanel, __props_tab_export_start_current_JCheckBox,
		++x, y, 2, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );
	//JComboBoxes for Export Start
	++x;
	JGUIUtil.addComponent(
		props_JPanel, __props_tab_export_start_plusminus_JComboBox,
		++x, y, 1, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );
	JGUIUtil.addComponent(
		props_JPanel, __props_tab_export_start_numb_JComboBox,
		++x, y, 1, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );
	JGUIUtil.addComponent(
		props_JPanel, __props_tab_export_start_dayhr_JComboBox,
		++x, y, 2, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );
	++x;
	JGUIUtil.addComponent(
		props_JPanel, props_tab_export_start_desc_JLabel,
		++x, y, 2, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

	x=0;
	//label for Export END
	JGUIUtil.addComponent(
		props_JPanel, props_tab_export_end_JLabel,
		x, ++y, 1, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.EAST );
	//JCheckBox for Export END
	JGUIUtil.addComponent(
		props_JPanel, __props_tab_export_end_current_JCheckBox,
		++x, y, 2, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

	//JComboBoxes for Export S ENDtart
	++x;
	JGUIUtil.addComponent(
		props_JPanel, __props_tab_export_end_plusminus_JComboBox,
		++x, y, 1, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );
	JGUIUtil.addComponent(
		props_JPanel, __props_tab_export_end_numb_JComboBox,
		++x, y, 1, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );
	JGUIUtil.addComponent(
		props_JPanel, __props_tab_export_end_dayhr_JComboBox,
		++x, y, 2, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );
	++x;
	JGUIUtil.addComponent(
		props_JPanel, props_tab_export_end_desc_JLabel,
		++x, y, 2, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );
	x=0;
	//Add Label for Retries
	JGUIUtil.addComponent(
		props_JPanel, props_tab_retries_JLabel,
		x, ++y, 1, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.EAST );

	//Add TextField for Retries
	JGUIUtil.addComponent(
		props_JPanel, __props_tab_retries_JTextField,
		++x, y, 1, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

	//Description for retries
	JGUIUtil.addComponent(
		props_JPanel, props_tab_retries_desc_JLabel,
		++x, y, 5, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

	//Add Label for Last Export Date
	x=0;
	JGUIUtil.addComponent(
		props_JPanel, props_tab_last_export_date_JLabel,
		x, ++y, 1, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.EAST );

	//Add TextField for Last Export Date
	JGUIUtil.addComponent(
		props_JPanel, __props_tab_last_export_date_JTextField,
		++x, y, 4, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

	//Add description (with date format)
	++x;
	++x;
	++x;
	JGUIUtil.addComponent(
		props_JPanel, props_tab_last_export_date_desc_JLabel,
		++x, y, 4, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

	//Add Label for NEXT Export Date
	x=0;
	JGUIUtil.addComponent(
		props_JPanel, props_tab_next_export_date_JLabel,
		x, ++y, 1, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.EAST );

	//Add TextField for NEXT Export Date
	JGUIUtil.addComponent(
		props_JPanel, __props_tab_next_export_date_JTextField,
		++x, y, 4, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

	//Add description (with date format)
	++x;
	++x;
	++x;
	JGUIUtil.addComponent(
		props_JPanel, props_tab_next_export_date_desc_JLabel,
		++x, y, 4, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );



	//add properties- specific to Product Type
	x=0;
	if( __db_ExportProduct_type.equalsIgnoreCase( __type_table_str ) ) {
		//TIMESTAMP
		JGUIUtil.addComponent(
			props_JPanel, __props_timestamp_table_JCheckBox,
			++x, ++y, 4, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.WEST );

		//hideMISSING
		JGUIUtil.addComponent(
			props_JPanel, __props_hidemissing_table_JCheckBox,
			x, ++y, 4, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.WEST );

		//DATEFORMAT
		x=0;
		JGUIUtil.addComponent(
			props_JPanel, new JLabel(
 			__props_dateformat_table_JLabel_str + ":" ),
			x, ++y, 1, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.EAST );
		JGUIUtil.addComponent(
			props_JPanel, __props_dateformat_table_JComboBox,
			++x, y, 7, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.WEST );

		//LISTING_ORDER
		JGUIUtil.addComponent(
			props_JPanel, new JLabel(
 			__props_listorder_table_JLabel_str + ":" ),
			x, ++y, 1, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.EAST );
		JGUIUtil.addComponent(
			props_JPanel, __props_listorder_table_JComboBox,
			++x, y, 6, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.WEST );
	}
	else if (__db_ExportProduct_type.equalsIgnoreCase(__type_graph_str)
	    || __db_ExportProduct_type.equalsIgnoreCase(__type_graph_str_old)) {
		
		// TSProduct
		x=0;
		JGUIUtil.addComponent(
			props_JPanel, new JLabel(
			__props_tsProduct_graph_JLabel_str + ": "),
			x, ++y, 1, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.EAST );
		JGUIUtil.addComponent(
			props_JPanel, __props_tsProduct_graph_JComboBox,
			++x, y, 7, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.WEST );
		
		// title
		x=0;
		JGUIUtil.addComponent(
			props_JPanel, new JLabel(
			__props_title_graph_JLabel_str + ": "),
			x, ++y, 1, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.EAST );
		JGUIUtil.addComponent(
			props_JPanel, __props_title_graph_JTextField,
			++x, y, 5, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.WEST );
		++x;
		++x;
		++x;
		++x;
		JGUIUtil.addComponent(
			props_JPanel, new JLabel(
			__props_title_graph_JLabel_desc_str) ,
			++x, y, 4, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.WEST );
		
			
		//creation time
		x=0;
		JGUIUtil.addComponent(
			props_JPanel, __props_creationtime_graph_JCheckBox,
			++x, ++y, 4, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.WEST );
		++x;
		++x;
		JGUIUtil.addComponent(
			props_JPanel, new JLabel (
			__props_creationtime_graph_JLabel_desc_str),
			++x, y, 4, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.WEST );

		//timestamp (added to file name)
		x=0;
		JGUIUtil.addComponent(
			props_JPanel, __props_timestamp_graph_JCheckBox,
			++x, ++y, 4, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.WEST );
		++x;
		++x;
		JGUIUtil.addComponent(
			props_JPanel, new JLabel (
			__props_timestamp_graph_JLabel_desc_str),
			++x, y, 4, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.WEST );

		//window dimension
		x=0;
		JGUIUtil.addComponent(
			props_JPanel, new JLabel(
			__props_windowdim_graph_JLabel_str + ":" ),
			x, ++y, 1, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.EAST );
		JGUIUtil.addComponent(
			props_JPanel, __props_windowdim_w_graph_JTextField,
			++x, y, 2, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.WEST );
		++x;
		JGUIUtil.addComponent(
			props_JPanel, __props_windowdim_h_graph_JTextField,
			++x, y, 2, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.WEST );
		++x;
		JGUIUtil.addComponent(
			props_JPanel, new JLabel(
			__props_windowdim_graph_JLabel_desc_str),
			++x, y, 4, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.WEST );
		
		//date format
		x=0;
		JGUIUtil.addComponent(
			props_JPanel, new JLabel(
			__props_dateformat_graph_JLabel_str + ": "),
			x, ++y, 1, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.EAST );
		JGUIUtil.addComponent(
			props_JPanel, __props_dateformat_graph_JComboBox,
			++x, y, 7, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.WEST );
		JGUIUtil.addComponent(
			props_JPanel, new JLabel(
			__props_dateformat_graph_JLabel_desc_str ),
			++x, y, 2, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.WEST );

		//annotation lines
		x=0;
		JGUIUtil.addComponent(
			props_JPanel, new JLabel(
			__props_annotationline_graph_JLabel_str + ": "),
			x, ++y, 1, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.EAST );
		JGUIUtil.addComponent(
			props_JPanel, __props_annotationline_1_graph_JTextField,
			++x, y, 2, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.WEST );
		++x;
		JGUIUtil.addComponent(
			props_JPanel, __props_annotationline_2_graph_JTextField,
			++x, y, 2, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.WEST );
		++x;
		JGUIUtil.addComponent(
			props_JPanel, new JLabel(
			__props_annotationline_graph_JLabel_desc_str),
			++x, y, 4, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.WEST );


		//annotation text
		x=0;
		JGUIUtil.addComponent(
			props_JPanel, new JLabel(
			__props_annotationtext_graph_JLabel_str + ": "),
			x, ++y, 1, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.EAST );
		JGUIUtil.addComponent(
			props_JPanel, __props_annotationtext_1_graph_JTextField,
			++x, y, 2, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.WEST );
		++x;
		JGUIUtil.addComponent(
			props_JPanel, __props_annotationtext_2_graph_JTextField,
			++x, y, 2, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.WEST );
		++x;
		JGUIUtil.addComponent(
			props_JPanel, new JLabel(
			__props_annotationtext_graph_JLabel_desc_str),
			++x, y, 4, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.WEST );

		//range
		x=0;
		JGUIUtil.addComponent(
			props_JPanel, new JLabel(
			__props_range_graph_JLabel_str + ": "),
			x, ++y, 1, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.EAST );
		JGUIUtil.addComponent(
			props_JPanel, __props_range_lo_graph_JTextField,
			++x, y, 2, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.WEST );
		++x;
		JGUIUtil.addComponent(
			props_JPanel, __props_range_hi_graph_JTextField,
			++x, y, 2, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.WEST );
		++x;
		JGUIUtil.addComponent(
			props_JPanel, new JLabel(
			__props_range_graph_JLabel_desc_str),
			++x, y, 4, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.WEST );

	}
	else if ( __db_ExportProduct_type.equalsIgnoreCase( __type_comma_str ) ) {
		//title for date format
		JGUIUtil.addComponent(
			props_JPanel, new JLabel(
 			__props_dateformat_comma_JLabel_str + ":" ),
			x, ++y, 1, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.EAST );
		JGUIUtil.addComponent(
			props_JPanel, __props_dateformat_comma_JComboBox,
			++x, y, 7, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.WEST );

		//time stamp
		x=0;
		JGUIUtil.addComponent(
			props_JPanel, new JLabel(
 			__props_timestamp_comma_JLabel_str + ":" ),
			x, ++y, 1, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.EAST );
		JGUIUtil.addComponent(
			props_JPanel, __props_timestamp_comma_JCheckBox,
			++x, y, 1, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.WEST );
	}
	else if ( __db_ExportProduct_type.equalsIgnoreCase( __type_obsreport_str ) ) {
		//TITLE
		JGUIUtil.addComponent(
			props_JPanel, new JLabel(
 			__props_title_obsreport_JLabel_str + ":" ),
			x, ++y, 1, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.EAST );
		JGUIUtil.addComponent(
			props_JPanel, __props_title_obsreport_JTextField,
			++x, y, 3, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.WEST );

		//TIMESTAMP
		x=0;
		JGUIUtil.addComponent(
			props_JPanel, __props_timestamp_obsreport_JCheckBox,
			++x, ++y, 4, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.WEST );

		//Date format
		x=0;
		JGUIUtil.addComponent(
			props_JPanel, new JLabel(
			__props_dateformat_obsreport_JLabel_str),
			x, ++y, 1, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.WEST );

		JGUIUtil.addComponent(
			props_JPanel, __props_dateformat_obsreport_JComboBox,
			++x, y, 7, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.WEST );


		//format
		x=0;
		JGUIUtil.addComponent(
			props_JPanel, new JLabel(
			__props_format_obsreport_JLabel_str),
			x, ++y, 1, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.WEST );

		JGUIUtil.addComponent(
			props_JPanel, __props_format_obsreport_JComboBox,
			++x, y, 3, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.WEST );

		//deliminiter
		x=0;
		JGUIUtil.addComponent(
			props_JPanel, new JLabel(
			__props_deliminiter_obsreport_JLabel_str),
			x, ++y, 1, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.WEST );

		JGUIUtil.addComponent(
			props_JPanel, __props_deliminiter_obsreport_JTextField,
			++x, y, 1, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.WEST );

	}
	else if ( __db_ExportProduct_type.equalsIgnoreCase( __type_shef_str ) ) {
		//TIMESTAMP
		JGUIUtil.addComponent(
			props_JPanel, __props_timestamp_shef_JCheckBox,
			++x, ++y, 4, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.WEST );

		//APPEND
		JGUIUtil.addComponent(
			props_JPanel, __props_append_shef_JCheckBox,
			x, ++y, 4, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.WEST );

		//USEHOUR24
		JGUIUtil.addComponent(
			props_JPanel, __props_usehour_shef_JCheckBox,
			x, ++y, 4, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.WEST );
		//date format
		x=0;
		JGUIUtil.addComponent(
			props_JPanel, new JLabel(
 			__props_dateformat_shef_JLabel_str + ":" ),
			x, ++y, 1, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.WEST );
		JGUIUtil.addComponent(
			props_JPanel, __props_dateformat_shef_JComboBox,
			++x, y, 7, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.WEST );
	}
	return props_JPanel;

} //end assemble_tab_properties

/**
Method adds all the components to a JPanel for the Security tab.
@return JPanel with all the components.
*/
public JPanel assemble_tab_security( ) {

	//Make panel to hold everything.  This will be returned.
	JPanel security_JPanel = new JPanel();
	security_JPanel.setLayout( __gridbag );

	//make subpanels- one to hold user info and the other for firewall
	JPanel user_JPanel = new JPanel();
	user_JPanel.setLayout( __gridbag );

	JPanel firewall_JPanel = new JPanel();
	firewall_JPanel.setLayout( __gridbag );

	//make titled borders to hold: user and to hold: firewall
	Border border = BorderFactory.createLineBorder( Color.black );
	Font title_font = new Font( "Arial", Font.BOLD, 12 );
	TitledBorder user_border = BorderFactory.createTitledBorder(
		border, "User", TitledBorder.TOP,
		TitledBorder.CENTER, title_font );

	TitledBorder firewall_border = BorderFactory.createTitledBorder(
		border, "Firewall", TitledBorder.TOP,
		TitledBorder.CENTER, title_font );

	//add borders to panels.
	user_JPanel.setBorder( user_border );
	firewall_JPanel.setBorder( firewall_border );

	//now make text fields: each sub panel gets
	//a login and a password textField.

	//USER PANEL
	JLabel user_login_JLabel = new JLabel( "Login: " );
	user_login_JLabel.setToolTipText( "Optional: add user login" );

 	__security_tab_user_login_JTextField = new JTextField( 10 );

	JLabel user_passwd_JLabel = new JLabel( "Password: " );
	user_passwd_JLabel.setToolTipText( "Optional: add user password" );

 	__security_tab_user_passwd_JTextField = new JTextField( 10 );

	//add items
	int y =0;
	//label for user login
	JGUIUtil.addComponent(
		user_JPanel, user_login_JLabel,
		0, y, 1, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.EAST );

	//textfield for user login
	JGUIUtil.addComponent(
		user_JPanel, __security_tab_user_login_JTextField,
		1, y, 1, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

	//label for user password
	JGUIUtil.addComponent(
		user_JPanel, user_passwd_JLabel,
		0, ++y, 1, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.EAST );

	//textfield for user password
	JGUIUtil.addComponent(
		user_JPanel, __security_tab_user_passwd_JTextField,
		1, y, 1, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

	//now work on firewall sub panel
	JLabel firewall_login_JLabel = new JLabel( "Login: " );
	firewall_login_JLabel.setToolTipText( "Optional: add firewall login" );

 	__security_tab_firewall_login_JTextField = new JTextField( 10 );

	JLabel firewall_passwd_JLabel = new JLabel( "Password: " );
	firewall_passwd_JLabel.setToolTipText( "Optional: add firewall password" );

 	__security_tab_firewall_passwd_JTextField = new JTextField( 10 );

	//add items
	y = 0;
	//label for firewall login
	JGUIUtil.addComponent(
		firewall_JPanel, firewall_login_JLabel,
		0, y, 1, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.EAST );

	//textfield for firewall login
	JGUIUtil.addComponent(
		firewall_JPanel, __security_tab_firewall_login_JTextField,
		1, y, 1, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

	//label for firewall password
	JGUIUtil.addComponent(
		firewall_JPanel, firewall_passwd_JLabel,
		0, ++y, 1, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.EAST );

	//textfield for firewall password
	JGUIUtil.addComponent(
		firewall_JPanel, __security_tab_firewall_passwd_JTextField,
		1, y, 1, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

	//now assemble overall panel by adding
	//the 2 subpanels
	//top, left, bottom, right
	Insets ins_l = new Insets( 2, 2, 2, 5 );
	Insets ins_r = new Insets( 2, 5, 2, 2 );
	JGUIUtil.addComponent(
		security_JPanel, user_JPanel,
		0, 0, 1, 1, 1, 0, ins_l,
		GridBagConstraints.NONE,
		GridBagConstraints.EAST );

	JGUIUtil.addComponent(
		security_JPanel, firewall_JPanel,
		1, 0, 1, 1, 1, 0, ins_r,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );


	ins_l = null;
	ins_r = null;
	title_font = null;
	border = null;

	return security_JPanel;

} //end assemble_tab_security

/**
Method adds all the components to a JPanel for the Time Series tab.
The tab consists of a JList, which lists all available MeasType
objects and a JWorksheet that contains the selected MeasTypes (time series)
to associate with this ExportProduct.  The "selected" time series are
the related ExportConf objects.
@return JPanel with all the components.
*/
public JPanel assemble_tab_timeSeries() {
	String routine = __class + ".assemble_tab_timeSeries";

	//Make panel to hold everything.  This will be returned.
	JPanel ts_JPanel = new JPanel();
	ts_JPanel.setLayout( __gridbag );

	//label for left list
	JLabel timeseries_tab_allTS_JLabel = new JLabel (
	"Time Series Defined as Exported: ");

	timeseries_tab_allTS_JLabel.setToolTipText("<HTML>"+
	"Select time series to include in this Export Product." +
	"<BR>Move time series to the right-hand worksheet using the \">\" button</HTML>");

	//label for right list
	JLabel timeseries_tab_selTS_JLabel = new JLabel (
	"Time Series to Export from File: " );

	timeseries_tab_selTS_JLabel.setToolTipText(
	"<HTML>Required: Worksheet to display time series included in " +
	"Export Product with data related to the time series. </HTML>");

	//LEFT LIST -
	//get list of all time series

	// get the items to put in the listmodel
	try {
 		__leftList_MeasType_vect =
 		__dmi.readMeasTypeListForTSIdentByLocation( "...." );
	}
	catch ( Exception e ) {
		Message.printWarning( 2, routine, e );
	}

	//now have a vector of ALL the measTypes
	int numb_all_MeasType = 0;
	if ( __leftList_MeasType_vect != null ) {
		numb_all_MeasType = __leftList_MeasType_vect.size();
	}
	if ( Message.isDebugOn ) {
		Message.printDebug( 5, routine,
		"Total number of MeasTypes to choose from: " +
		numb_all_MeasType );
	}

	//Create the listModel for the JList.
 	__timeseries_tab_allTS_listModel = new DefaultListModel();

	//now go through the vector and add the types to the list model
	RiversideDB_MeasType rti_mt = null;
	TSIdent tsid = null;
	for ( int i=0; i< numb_all_MeasType; i++ ) {
		rti_mt =  (RiversideDB_MeasType)
 		__leftList_MeasType_vect.elementAt(i);
		if ( rti_mt == null ) {
			continue;
		}
		try {
			tsid = rti_mt.toTSIdent();
		}
		catch ( Exception e) {
			Message.printWarning( 2, routine, e );
			tsid = null;
		}
		if ( tsid != null ) {
 			__timeseries_tab_allTS_listModel.addElement(
			tsid.toString() + " - " +
			rti_mt.getDescription() );
		}
	}

	rti_mt = null;

	//make the Left list - which is the  List of ALL measTypes
	//and add the listmodel to it!
 	__timeseries_tab_allTS_JList = new JList(
 	__timeseries_tab_allTS_listModel );

	//Multiple Selection allowed on LEFT list ( single on right )
 	__timeseries_tab_allTS_JList.setSelectionMode(
		ListSelectionModel.MULTIPLE_INTERVAL_SELECTION );
 	__timeseries_tab_allTS_JList.setVisibleRowCount( 15 );
 	__timeseries_tab_allTS_JList.setSelectedIndex(0);

	//add list to scroll pane
	JScrollPane timeseries_tab_allTS_JScrollPane = new JScrollPane(
 	__timeseries_tab_allTS_JList );
	//Dimension( width, height) of JScrollPane
	timeseries_tab_allTS_JScrollPane.setPreferredSize(
		new Dimension ( 200, 200 ) );
	timeseries_tab_allTS_JScrollPane.setMinimumSize(
		new Dimension ( 200, 200 ) );
	timeseries_tab_allTS_JScrollPane.setMaximumSize(
		new Dimension ( 200, 200 ) );

	//The list of all the Time Series does not need a listener.
	//The buttons trigger any action with items from this list
	//add ListSelectionListener to listen for changes

	//RIGHT JWorksheet -  selected ExportConf objects for this
	//ExportProduct.

	//data for list
	//need vector of ExportConf objects and MeasType objects ,
	//labels for worksheet and ImportProduct type
	Vector mt_vect = new Vector();

	//from the Vector of ExportConf objects, get the
	//the MeasType_nums for those objects.
	//Then, use the number to get the MeasType Object
	int numb_ec = 0;
	numb_ec = __db_RTi_ExportConf_vect.size();

	if ((  numb_ec == 0 ) && ( ! __bln_new_object ) ) {
		Message.printWarning( 2, routine,
		"No ExportConf Time Series defined for: \"\n" +
 		__db_RTi_ExportProduct.getProduct_name() + "\"." );
	}
	long mt_int = -999;
	RiversideDB_ExportConf rti_ec = null;
	rti_mt = null;

	for ( int i=0; i< numb_ec; i++ ) {
		rti_ec = ( RiversideDB_ExportConf )
 		__db_RTi_ExportConf_vect.elementAt( i );

		//now get the MeasType from the object...
		mt_int = rti_ec.getMeasType_num();
		//now we MeasType_num, use it to look up MeasType!
		//For
		if ( mt_int < 0 ) {
			continue;
		}
		//get the MeasTypeObject.
		try {
			rti_mt = (RiversideDB_MeasType)
 			__dmi.readMeasTypeForMeasType_num( mt_int );
		}
		catch ( Exception e ) {
			Message.printWarning( 2, routine, e );
			rti_mt = null;
		}
		if ( rti_mt == null ) {
			continue;
		}

		mt_vect.addElement( rti_mt );

		rti_mt = null;
		rti_ec = null;
	}

	//Labels for worksheet
	if ( __arrWorksheet_labels == null ) {
 		__arrWorksheet_labels = new String[3];
		//"TS Import Enabled"
 		__arrWorksheet_labels[0] =
		"Export \nEnabled";
		//"Export ID" for ExportConf field: export id
 		__arrWorksheet_labels[1] =
		"Export \nIdentifier";
		//"Export Units"
 		__arrWorksheet_labels[2] =
		"Export \nUnits";
	}
	//tooltips
	if ( __arrWorksheet_tooltips == null ) {
 		__arrWorksheet_tooltips = new String[5];
		__arrWorksheet_tooltips[0] = "Uneditable: Time " +
		"series identifier";
 		__arrWorksheet_tooltips[1] = "Uneditable: Time " +
		"series description";
		//"TS Import Enabled"
 		__arrWorksheet_tooltips[2] = "Required: " +
		"Is time series import enabled: Yes, N: No";
		//"Export ID" for ExportConf field: export id
 		__arrWorksheet_tooltips[3] = "(Usually) Required " +
		"Time Series Identifier";
		//"Export Units"
 		__arrWorksheet_tooltips[4] ="Required Units";
	}

	if ( __RTi_DataType_vect == null ) {
		try {
 			__RTi_DataType_vect =
 			__dmi.readDataTypeList();

		}
		catch ( Exception e ) {
			Message.printWarning( 2, routine, e);
 			__RTi_DataType_vect = new Vector();
		}
	}

	//make Table Model
	//RiversideDB_ExportConf_TableModel tmic = null;
	try {
		//pass in Vector of ExportConf objects,
		//Vector of MEasType objects, Arr of labels,
		//import type
		Vector v = new Vector();

		//NOTE:: if you pass in the actual vector:
		//_db_RTi_ExportConf_vect, it will get added to deleted
		//from from within the TableModel, which we do not want!
		v.addElement( __worksheet_RTi_ExportConf_vect );
		v.addElement( mt_vect);

 		__table_model = new RiversideDB_ExportConf_TableModel(
		v, __arrWorksheet_labels, __arrWorksheet_tooltips,
		__dmi, __RTi_DataType_vect );

		RiversideDB_ExportConf_CellRenderer crr =
		new RiversideDB_ExportConf_CellRenderer( __table_model);

 		__timeseries_tab_selTS_JWorksheet = new JWorksheet(
		crr, __table_model, __worksheet_PropList);
	}
	catch (Exception e) {
		//else make empty worksheet
		Message.printWarning(2, routine, e);
 		__timeseries_tab_selTS_JWorksheet = new JWorksheet(
		0, 0, __worksheet_PropList );
	}

	//set worksheet so it is known to TableModel and can
	//set it dirty is a value is changed!
 	__table_model.setWorksheet( __timeseries_tab_selTS_JWorksheet );
 	//__timeseries_tab_selTS_JWorksheet.setToolTipText("<html>Add values for " +
	//"selected time series.<br>All values are required.<br></html>");

	//add worksheet to scroll pane
 	JScrollPane timeseries_tab_selTS_JScrollPane = new JScrollPane(
 	__timeseries_tab_selTS_JWorksheet );
	//Set size of list
 	timeseries_tab_selTS_JScrollPane.setPreferredSize( __worksheet_dim);

 	timeseries_tab_selTS_JScrollPane.setMinimumSize( __worksheet_dim );
 	timeseries_tab_selTS_JScrollPane.setMaximumSize( __worksheet_dim );


	//2 buttuns go in between the 2 Jlists- for
	//moving items back and forth
 	__timeseries_tab_clear_selected_JButton = new SimpleJButton(
 	"Clear Selected", this );
 	__timeseries_tab_clear_selected_JButton.setToolTipText(
	"Remove entire row of data for selected worksheet cell(s)" );

 	__timeseries_tab_move_right_JButton = new SimpleJButton( ">", this );
 	__timeseries_tab_move_right_JButton.setToolTipText(
	"Move time series to list of selected time series for Export product" );

	//Label for left list
	JGUIUtil.addComponent(
		ts_JPanel, timeseries_tab_allTS_JLabel,
		0, 0, 1, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

	//add Left list with full list of TimeSeries
	JGUIUtil.addComponent(
		ts_JPanel, timeseries_tab_allTS_JScrollPane,
		0, 1, 1, 7, 0.0, 0.0, __insets,
		GridBagConstraints.BOTH,
		GridBagConstraints.WEST );

	//add button: move right arrow
	JGUIUtil.addComponent(
		ts_JPanel, __timeseries_tab_move_right_JButton,
		1, 3, 1, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

	//Label for Right list
	JGUIUtil.addComponent(
		ts_JPanel, timeseries_tab_selTS_JLabel,
		2, 0, 3, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

	//add Right list
	JGUIUtil.addComponent(
		ts_JPanel, timeseries_tab_selTS_JScrollPane,
		2, 1, 3, 3, 0.0, 0.0, __insets,
		GridBagConstraints.BOTH,
		GridBagConstraints.WEST );

	//Add clear selected button below the worksheet
	JGUIUtil.addComponent(
		ts_JPanel, __timeseries_tab_clear_selected_JButton,
		4, 5, 1, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

	return ts_JPanel;

} //end assemble_tab_timeSeries

/**
This method does the following:<ul>
<li>calls <i>checkRequiredInput</i> which makes sure all the required fields in the GUI are filled out and have valid entries</li>
<li>calls <i>update_RiversideDB_objects</i> which is called to
<b>create</b> and update the <i><b>__gui_RTi_ExportProudct</b></i> and
<i> <b>__gui_RTi_ExportConf_vect</b></i> objects in memory, mark them dirty,
and add messages to the <i>__dirty_vect</i> Vector.
</li>
<li>creates a confirmation message if the <i>__gui</i> versions are dirty,
prompting the user to verify if they want to save their changes
(all the changes are listed out from the <i>__dirty_vect</i>)</li>
<li>updates the database by calling, <i>update_database</i></li>
<li>closes the GUI and destroys it</li>
</ul>
*/
public void closeGUI() {
	String routine = __class + ".closeGUI";

	boolean blnUpdated=true;
	/*
	//update fields again since current ExportConf fields
	//may have changed.
	try {
		verify_timeseries_tab( false );
	}
	catch ( Exception e ) {
		Message.printWarning( 2, routine, e);
		blnUpdated= false;
	}
	*/

	//required fields
	try {
		checkRequiredInput();
	}
	catch ( Exception e ) {
		//then there was an error so do not
		//update object in memory or in database.
		Message.printWarning( 2, routine, e );
 		__dirty_vect.clear();

		blnUpdated= false;
	}

	//update the object in memory
	if ( blnUpdated ) {
		try {
			update_RiversideDB_objects();
		}
		catch( Exception e ) {
			Message.printWarning( 2, routine, e );
			blnUpdated=false;
		}
	}

	// see if __gui_RTi_ExportConf_vect has any dirty elements
// ----------------------------------------------------------------------------
// REVISIT [LT] 2004-12-22 (isDataDirty()) - The code needed to implement the 
// isDataDirty() for the Export can be extract from this block of code below. 	
	boolean dirty_exportconf = false;
	int size = 0;
	if ( __gui_RTi_ExportConf_vect != null ) {
		size = __gui_RTi_ExportConf_vect.size();
	}
	RiversideDB_ExportConf ec = null;
	for ( int i=0; i<size; i++ ) {
		ec = ( RiversideDB_ExportConf )
 		__gui_RTi_ExportConf_vect.elementAt(i);
		if ( ec == null ) {
			continue;
		}
		if ( ec.isDirty() ) {
			dirty_exportconf = true;
			break;
		}
		ec = null;
	}

	if( blnUpdated)  {
		if(( __gui_RTi_ExportProduct.isDirty()) || (dirty_exportconf)) {
// REVISIT [LT] 2004-12-22 (isDataDirty()) - The code needed to implement the 
// isDataDirty() for the Export can be extract from the block of code above. 			
// ----------------------------------------------------------------------------			
			//prompt user if they want to save their
			//changes to the database.
			int x = 0;
			x = new ResponseJDialog ( this,
				"Save Changes",
				"Save your changes before closing?",
				ResponseJDialog.YES | ResponseJDialog.NO
				| ResponseJDialog.CANCEL).response();

			if ( x == ResponseJDialog.YES ) {
				//update database itself
				try {
					//update database itself
					update_database();
				}
				catch( Exception e ) {
					Message.printWarning( 2, routine, e );
					blnUpdated=false;
				}

				//setVisible(false);
				//dispose();
				windowManagerClose();
			}
			else if ( x == ResponseJDialog.NO ) {
				windowManagerClose();
				//setVisible(false);
				//dispose();
			}
		}
		else { //no changes, so just close.
			windowManagerClose();
			//setVisible(false);
			//dispose();
		}
	}
	else {
		if ( blnUpdated ) {
			windowManagerClose();
			//setVisible(false);
			//dispose();
		}
	}

} //end closeGUI

/**
This method simply goes through all the fields in the GUI and checks that
each fields is: <ul> <li>filled in if it is a required field </li>
<li>contains valid values (for JTextFields, for example)</li>
</ul>If an invalid entry is encountered, the method displays a warning message,
indicating the fields with invalid values. (Prints one error message at the end indicating any fields that need to
be filled in before a save can occur.)
</ul>
@exception Exception thrown if a required filled does not
have a value.
</ul>
*/
protected void checkRequiredInput() throws Exception {
	String routine = __class + ".checkRequiredInput";

	StringBuffer buffer = new StringBuffer();
	//nothing can be null except the "Selected" input time series
	//since everything else is in a drop-down list.

	//Product Identifier
	String prodID= null;
	prodID= __product_info_id_JTextField.getText().trim();
	if( ( prodID == null ) || ( prodID.length() <= 0 ) ) {
		buffer.append( "Unable to update database " +
		"without a Product Indentifier.\n" );
	}

	//make sure it is not a repeat Product Identifier if we
	//are adding a new one.
	if ( __bln_new_object ) {
		int size=0;
		if ( __RTi_ExportProduct_vect != null ){
			size = __RTi_ExportProduct_vect.size();
		}
		RiversideDB_ExportProduct ep = null;
		for (int i=0; i<size; i++ ) {
			ep = (RiversideDB_ExportProduct)
 			__RTi_ExportProduct_vect.elementAt(i);
			if ( (ep.getProduct_name()).equalsIgnoreCase( prodID ) ) {
				//we found a product with that name already
				buffer.append( "ExportProduct named: \""
				+ prodID + "\" already exists. Unable to " +
				"update database.\n");
				break;
			}
		}
	}

	//Product Group - can't be null - is uneditable
	//Product Type - drop down list, so can't be null
	//get input Time Series.

	//Destination Directory
	String dest_dir = null;
	dest_dir = __files_tab_dest_dir_JTextField.getText().trim();
	if( ( dest_dir == null ) || ( dest_dir.length() <= 0 ) ) {
		buffer.append( "Unable to update database " +
		"without a Destination Directory (Files tab).\n" );
	}

	//Export Order - can't be null since is a JComboBox
	//Export Window - can't be null since are in a JComboBoxes

	//next Export date
	String gui_next_date_str = null;
	gui_next_date_str = ( __props_tab_next_export_date_JTextField.
	getText()).trim();
	boolean blnCheckDate = true;
	//make sure it is a valid date.
	if (( gui_next_date_str == null) || (gui_next_date_str.length() <= 0 )){
		//NEXT date can be null if it was null originally- ie,
		//a new ExportProduct is being defined.  It it had a date
		//originally, it can not be null.
		Date db_date = null;
		db_date = __db_RTi_ExportProduct.getNext_export_date();
		if ( db_date == null ) {
			//ok
			blnCheckDate=false;
		}
		else {
			buffer.append(
			"Unable to update database without a valid date for \""+
			"Next Export Date\" (Property Tab)\n" );
			blnCheckDate=false;
		}
	}
	//if the date entry is not null, make sure it is a valid date
	if ( blnCheckDate ) {
		try {
			DateTime.parse( gui_next_date_str);
		}
		catch (Exception e ) {
			Message.printWarning( 2, routine, e);
			buffer.append(
			"Unable to update database without a valid date for \""+
			"Next Export Date\" (Property Tab)\n" );
		}
	}

	//Time Series Defined as Import-list to select from- should not be null
	//Make sure there are ExportConf time series defined and
	//that every field in the worksheet is filled
	int table_size = __timeseries_tab_selTS_JWorksheet.getRowCount();
	if ( table_size <= 0 ) {
		buffer.append( "Unable to update database " +
		"without any Time Series to Export from File defined " +
		"(Time Series tab).\n" );
	}
	else {
		//get the ExportConf Objects out of the worksheet
		Vector table_data = __timeseries_tab_selTS_JWorksheet.
		getAllData();
		//should be the same size as above
		table_size = table_data.size();

		RiversideDB_ExportConf ec = null;
		//long mt_num = -999;
		for ( int i=0; i< table_size; i++ ) {
			ec = (RiversideDB_ExportConf)
			table_data.elementAt( i );
			if ( ec == null ) {
				continue;
			}

			//mt_num = ec.getMeasType_num();
			//if ( __leftList_MeasType_vect != null ) {
			//	mt_size = __leftList_MeasType_vect.size();
			//}
			//find MeasType with matching MeasType_num
			//String tsid_str = getTSIDForMeasType_num( mt_num );

			/*
			//Required in most cases, but not all.
			if ( ec.getExport_id().equalsIgnoreCase(
			DMIUtil.MISSING_STRING ) ) {
				buffer.append(
				"Unable to update database " +
				"without an Export Identifier "+
				"for time series:\n\"" + tsid_str +
				"\" (Time Series tab).\n" );
			}
			*/
			ec = null;
		}
	}

	if ( buffer.length() >0 ) {
		buffer.append( "Please specify all required fields or cancel.\n" );
		JOptionPane.showMessageDialog( this,
		buffer.toString(), "Warning", JOptionPane.WARNING_MESSAGE);

		throw new Exception (
		"Please specify all required fields or cancel." );
	}
	buffer = null;

}//end checkRequieredInput

/*
Checks the required properties for ExportProducts of type campbellscientific:
@return Vector containing Strings.  Each String represents an
error message encountered while checking the property fields.
*/
protected Vector checkRequired_campbellsci_props() {

	Vector error_vect = new Vector();
	//Julianday - can't be null because is in an JComboBox
	//TableID - can't be null because is in an JComboBox
	//TIME - can't be null because is in an JComboBox
	//YEAR - can't be null because is in an JComboBox

	return error_vect;
}

/**
Creates the overall GUI panels including the JTabbedPanes which
contain information regarding the product selected. The tabs
consist of the following topics:
Files, Properties, Automation, Archiving, Security, Additonal Files.
*/
private void create_main_panel( ) {
	String routine = __class + ".create_main_product_info_panel";

	//create the overall panel to hold things.
 	__product_info_JPanel = new JPanel();
 	__product_info_JPanel.setLayout( __gridbag );

	//label for ID
	JLabel product_info_id_JLabel = new JLabel( "Product Identifier: ");
	product_info_id_JLabel.setToolTipText(
	"Required: Export Product Identifier");

	//JTextField for id
 	__product_info_id_JTextField = new JTextField(25);

	//label for Group
	JLabel product_info_group_JLabel = new JLabel( "Product Group: ");
	product_info_group_JLabel.setToolTipText(
	"Required: Select Product Group" );

	Vector prodGrp_vect = null;
	try {
		prodGrp_vect =
 		__dmi.readProductGroupListForProductType( "EXPORT" );
	}
	catch (Exception e ) {
		Message.printWarning( 2, routine, e );
	}
	Vector grp_names_vect = new Vector();
	RiversideDB_ProductGroup pg = null;
	//go through vector and get list of just the Groups
	int size = 0;
	if ( prodGrp_vect != null ) {
		size = prodGrp_vect.size();
	}
	for ( int i=0; i<size; i++ ) {
		pg= (RiversideDB_ProductGroup) prodGrp_vect.elementAt(i);
		if ( pg == null ) {
			continue;
		}
		grp_names_vect.addElement( pg.getProductGroup_num() + " - " +
		pg.getName() );
	//	grp_names_vect.addElement( pg.getProductGroup_num() + " - " +
	//	pg.getIdentifier() );
	}

	//make JComboBox
 	__product_info_group_JComboBox = new SimpleJComboBox(grp_names_vect );
 	__product_info_group_JComboBox.setMaximumRowCount( 5 );

	//now create label for the JComboBox: "product type"
	JLabel product_info_type_JLabel = new JLabel( "Product Type:" );
	product_info_type_JLabel.setToolTipText(
	"Uneditable: Export Product type" );

	//create JComboBox
	//get vector of type names
	Vector type_vect = new Vector();
	RiversideDB_ExportType et = null;
	String type = null;
	for ( int i=0; i< __RTi_ExportType_vect.size(); i++ ) {
		et = (RiversideDB_ExportType)
 		__RTi_ExportType_vect.elementAt(i);
		if ( et == null ) {
			continue;
		}
		type = et.getName() + " - " + et.getComment();
		if ( type != null ) {
			if ( type.length() > 80 ) {
				type =
				(type.substring( 0, 80 ) + " ...").trim();
			}
			//add it to vector for drop-down list
			type_vect.addElement( type );
		}
		type = null;
		et = null;
	}
	//make ComboBox
	__product_info_type_JComboBox = new SimpleJComboBox( type_vect );
//REVISIT [LT] 2005-02-01 - Replace JComboBox by JTextField.
//      __product_info_type_JTextField = __product_info_id_JTextField = new JTextField(25);
	JGUIUtil.setEnabled(__product_info_type_JComboBox, false );
//REVISIT [LT] 2005-02-01 - Replace JComboBox by JTextField.
//      JGUIUtil.setEnabled(__product_info_id_JTextField, false );

	//MeasLocGroup JLabel and Description
	JLabel product_info_measlocgroup_JLabel = new JLabel( "Location Group:" );
	product_info_measlocgroup_JLabel.setToolTipText(
	"Required: Select Location Group for Export Product" );

	JLabel product_info_measlocgroup_desc_JLabel = new JLabel(
	"Location Group Export Product belongs to" );

	//Vector of MeasLocGroup objects that this user has access to
 	__dmi.setDumpSQLOnError(true );
	Vector dbmlg_vect = null;
	try {
		dbmlg_vect = __dmi.
		readDBUserMeasLocGroupRelationListForDBUser_num(
 		__DBUser.getDBUser_num() );
	}
	catch ( Exception e ) {
		Message.printWarning( 2, routine, e );
		dbmlg_vect = new Vector();
	}

	//vector of MeasLocGroup objects
	if ( __RTi_MeasLocGroup_vect == null ) {
		try {
			__RTi_MeasLocGroup_vect =
			__dmi.readMeasLocGroupList();
		}
		catch ( Exception e ) {
			Message.printWarning( 2, routine, e );
			//create an empty vector
			__RTi_MeasLocGroup_vect = new Vector();
		}
	}
	int size_dbmlg = dbmlg_vect.size();
	int size_mlg = __RTi_MeasLocGroup_vect.size();
	//go through vector to get MeasLocGroup objects that this user
	//can access to.
	RiversideDB_DBUserMeasLocGroupRelation dbmlg = null;
	RiversideDB_MeasLocGroup mlg = null;
	int mlg_num = -999;
	//vector to hold items that go into comboBox - will
	//have "MeasLocGroupNum - MeasLocGroup_ID - MeasLocGroup_Name"
	Vector measlocgroup_vect = new Vector();
	for ( int i=0; i<size_dbmlg; i++ ) {
		dbmlg = (RiversideDB_DBUserMeasLocGroupRelation)
		dbmlg_vect.elementAt(i);
		if ( dbmlg == null ) {
			continue;
		}
		//get MeasLocGroup num
		mlg_num = dbmlg.getMeasLocGroup_num();
		//now use that to get MeasLocGroup object
		for ( int j=0; j<size_mlg;j++ ) {
			mlg = (RiversideDB_MeasLocGroup)
			__RTi_MeasLocGroup_vect.elementAt(j);
			if ( mlg == null ) {
				continue;
			}
			if ( mlg.getMeasLocGroup_num() == mlg_num ) {
				//found one
				measlocgroup_vect.addElement(
				mlg.getMeasLocGroup_num() + " - " +
				mlg.getIdentifier() + " - " +
				mlg.getName() );
				mlg= null;
				break;
			}
			mlg = null;
		}

		mlg= null;
		mlg_num=-999;
	}

	//make combo box for MeasLocGroup
 	__product_info_measlocgroup_JComboBox = new SimpleJComboBox(
	measlocgroup_vect );

	//now make the check box  "active"
 	__product_info_active_JCheckBox = new JCheckBox(
 	"Export Product Is Enabled" );
 	__product_info_active_JCheckBox.setToolTipText(
	"Required: Check to enable Export Product");

	//create the tabbed panes
 	__info_JTabbedPane = new JTabbedPane();


	//FILES TAB - 1st tab (case 0)
	//Creates a panel to hold all the info for the files tab
 	__files_tab_JPanel = assemble_tab_files( );
	//add files panel to tab
 	__info_JTabbedPane.addTab( __files_tab_str, __files_tab_JPanel );

	//Time Series Tab - 2nd tab  (case 1)
	//based on the ExportConf object
	//creates panel to hold information about Time Series available
	//for Exporting
 	__timeseries_tab_JPanel = assemble_tab_timeSeries( );
 	__info_JTabbedPane.addTab( __timeseries_tab_str, __timeseries_tab_JPanel );

	//PROPERTIES TAB - 3rd tab ( case 2)
	//creates a panel to hold information for the properties tab
 	__properties_tab_JPanel = assemble_tab_properties( );
 	__info_JTabbedPane.addTab( __props_tab_str, __properties_tab_JPanel );

	//add security tab if Export Product Type is DIADVISOR or TSLOOKUP
	//Security Tab - 4th tab (case 3)
	//creates panel to hold information about Archiving
 	__security_tab_JPanel = assemble_tab_security( );
 	__info_JTabbedPane.addTab( __security_tab_str, __security_tab_JPanel );

	//creates panel to hold information about automation
 	__automation_tab_JPanel = assemble_tab_automation( );
 	__info_JTabbedPane.addTab( __automation_tab_str, __automation_tab_JPanel );

	//close panel
	JPanel close_JPanel = new JPanel();
	close_JPanel.setLayout( __gridbag );

 	__close_JButton = new SimpleJButton( "Close",  this );
 	__cancel_JButton = new SimpleJButton( "Cancel", this );
 	__apply_JButton = new SimpleJButton( "Apply", this );

	JGUIUtil.addComponent(
		close_JPanel, __apply_JButton,
		0, 0, 1, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.EAST );

	JGUIUtil.addComponent(
		close_JPanel, __close_JButton,
		1, 0, 1, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.CENTER );
	JGUIUtil.addComponent(
		close_JPanel, __cancel_JButton,
		2, 0, 1, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

	//ASSEMBLE this portion of GUI
	try {
		int x=0;
		int y=0;

		JPanel p = new JPanel();
		p.setLayout( __gridbag );
		
		//JLabel for: "Product Type"
		JGUIUtil.addComponent(
			p, product_info_type_JLabel,
			x, y, 1, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.EAST );

		//JComboBox with Types -
		JGUIUtil.addComponent(
			p, __product_info_type_JComboBox,
//REVISIT [LT] 2005-02-01 - Replace JComboBox by JTextField.			
//			p, __product_info_type_JTextFiled,
			++x, y, 2, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.WEST );

		x=0;
		//JLabel for ID
		JGUIUtil.addComponent(
			p, product_info_id_JLabel,
			x, ++y, 1, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.EAST );

		//JTextField for ID
		JGUIUtil.addComponent(
			p, __product_info_id_JTextField,
			++x, y, 1, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.WEST );

		//JCheckBox - "is Active" or not
		JGUIUtil.addComponent(
			p, __product_info_active_JCheckBox,
			++x, y, 1, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.WEST );
		x=0;
		//JLabel for group
		JGUIUtil.addComponent(
			p, product_info_group_JLabel,
			x, ++y, 1, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.EAST );

		//JComboBox for group
		JGUIUtil.addComponent(
			p, __product_info_group_JComboBox,
			++x, y, 1, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.WEST );

		x=0;
		
		//JLabel for: "MeasLocGroup"
		JGUIUtil.addComponent(
			p, product_info_measlocgroup_JLabel,
			x, ++y, 1, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.EAST );

		//JComboBox with MeasLocGroups
		JGUIUtil.addComponent(
			p, __product_info_measlocgroup_JComboBox,
			++x, y, 1, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.WEST );

		//Description for MeasLocGroups
		JGUIUtil.addComponent(
			p, product_info_measlocgroup_desc_JLabel,
			++x, y, 1, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.EAST );

		//now add p to main panel and add tabbed panes
		y=0;
		JGUIUtil.addComponent(
 		__product_info_JPanel, p,
			x, y, 1, 1, 0.0, 0.0, __insets,
			GridBagConstraints.HORIZONTAL,
			GridBagConstraints.WEST );

		//add tabbed pane to main panel
		JGUIUtil.addComponent(
 		__product_info_JPanel, __info_JTabbedPane,
			x, ++y, 1, 1, 0.0, 0.0, __insets,
			GridBagConstraints.BOTH,
			GridBagConstraints.EAST );

		//add close panel
		JGUIUtil.addComponent(
 		__product_info_JPanel, close_JPanel,
			x, ++y, 1, 1, 1.0, 0.0, __insets,
			GridBagConstraints.HORIZONTAL,
			GridBagConstraints.CENTER );

	}
	catch ( Exception e ) {
		Message.printWarning( 2, routine, e);
		Message.printWarning( 2, routine,
		"Error laying out main product information panel." );
	}

} //end create_main_panel

/**
Finalizes and cleans up.
*/
protected void finalize() throws Throwable
{
	if ( __RTi_ExportProduct_vect != null ) {
 		__RTi_ExportProduct_vect = null;
	}
	if ( __leftList_MeasType_vect != null ) {
 		__leftList_MeasType_vect = null;
	}
	if ( __insets != null ) {
 		__insets = null;
	}
	if ( __gridbag != null ) {
 		__gridbag = null;
	}

	// Finalize the base RiversideDB_EditorBase_JFrame class
	super.finalize();
}

/**
Searches through Vector of MeasType objects known to this class
(__leftList_MeasType_vect) to return the matching RiversideDB_MeasType object
for the MeasType_num passed in.
@param mt_num MeasType_num used to find RiversideDB_MeasType object.
@param return RiversideDB_MeasType object that matches the measType_num
passed in.
*/
protected RiversideDB_MeasType getMeasTypeForMeasType_num ( long mt_num ) {

	int mt_size = __leftList_MeasType_vect.size();
	RiversideDB_MeasType mt = null;
	for (int k=0; k<mt_size; k++ ) {
		mt = ( RiversideDB_MeasType) __leftList_MeasType_vect.
		elementAt(k);
		if ( mt == null ) {
			continue;
		}
		if ( mt.getMeasType_num() == mt_num ) {
			return mt;
		}
	}
	return (RiversideDB_MeasType)null;
}

/**
Searches through Vector of MeasType objects known to this class
(__leftList_MeasType_vect) to return the TSIdent, as a String, for the
MeasType object matching the MeasType_num passed in.
@param mt_num MeasType_num used to find RiversideDB_MeasType object.
@param return String representation of TSID for MeasType object that
matches the MeasType_num passed in.
*/
protected String getTSIDForMeasType_num ( long mt_num ) {
	String routine = __class + ".getMeasTypeForMeasType_num";

	int mt_size = __leftList_MeasType_vect.size();
	RiversideDB_MeasType mt = null;
	for (int k=0; k<mt_size; k++ ) {
		mt = ( RiversideDB_MeasType) __leftList_MeasType_vect.
		elementAt(k);
		if ( mt == null ) {
			continue;
		}

		if ( mt.getMeasType_num() == mt_num ) {
			break;
		}
		mt = null;
	}
	TSIdent tsid = null;
	if ( mt == null ) {
		return "";
	}
	try {
		tsid = mt.toTSIdent();
	}
	catch ( Exception e) {
		Message.printWarning( 2, routine, e );
		tsid = null;
	}
	if ( tsid == null ) {
		return "";
	}
	return tsid.toString();
}

/**
Method reads the properties for the ExportProduct object passed
in and returns the properties in a Vector of Vectors in the
format of: item at (0)="Property Name" and at (1)="Property Value".
@param RiversideDB_ExportProduct object to get properties from.
@return Vector of vectors containing the properties for the
RiversideDB_ExportProduct object passed in. Format of Vector:
item at (0)="Property Name" and at (1)="Property Value".
*/
protected Vector getVectorOfProperties( RiversideDB_ExportProduct ep ) {
	String routine = __class + ".getVectorOfProperties";

	//get the properties string for the MeasReduction object
	//for comparison to the CURRENT values set in the GUI
	String tmp_props_str = null;
	tmp_props_str = ep.getProperties();
	if ( Message.isDebugOn ){
		Message.printDebug( 4, routine, "Property string for selected ExportProduct object is: \"" +
		tmp_props_str + "\"." );
	}

	//the Properties string is a list of properties, seperated by
	// ";" and consisting of PropertyName=PropertyValue pairs:
	//For ex: "Prop1=Value1; Prop2=Value2; Prop3=Value3"

	//make Vector of Vectors to hold the properties for
	//the ExportProduct object -each item in the Vector is another
	//vector with PropertyName as element 0 and PropertyValue as element 1
	Vector all_props_vect = new Vector();
	Vector tmp_props_vect = null;
	if ( tmp_props_str != null ) {
		//break up string based on ";"s
		if ( tmp_props_str.indexOf( ";" ) >= 0 ) {
			//break it up based on ";"
			tmp_props_vect = StringUtil.breakStringList( tmp_props_str, ";", StringUtil.DELIM_SKIP_BLANKS );
		}
		else  {
			// Have just 1 property-- add it to vector as is.
			tmp_props_vect = new Vector();
			tmp_props_vect.addElement( tmp_props_str );
		}
	}
	else {
		// There are no properties set, so add an empty vector
	    tmp_props_vect = new Vector();
		tmp_props_vect.addElement( new Vector() );
	}

	//we have a vector containing Strings - each string in format : "Propertyname=PropertyValue"
	//Break this up further so that each string in turn is converted to its own vector where
	//vector.elementAt(0) = property name and vector.elmentAt(i) = property value.
	int tmp_num = 0;
	if ( tmp_props_vect != null ) {
		tmp_num = tmp_props_vect.size();
	}
	String str_with_eq = null;
	String str_name= null;
	String str_val= null;
	for ( int i=0; i<tmp_num; i++ )  {
		str_with_eq = ( String) tmp_props_vect.elementAt(i);
		//break this string up based on the equal sign
		int eq_ind = -999;
		eq_ind = str_with_eq.indexOf("=");
		if ( eq_ind > 0 ) {
			str_name = (str_with_eq.substring(0, eq_ind)).trim();
			str_val = (str_with_eq.substring(eq_ind+1)).trim();
		}
		//now make this a new vector
		Vector brokenup_vect = new Vector();
		brokenup_vect.addElement( str_name );
		brokenup_vect.addElement( str_val );
		//now add this vector to the all_props_vet
		all_props_vect.addElement( brokenup_vect );
	}
	return all_props_vect;
} //end getVectorOfProperties

/**
This method is called from the constructor to create and layout the
GUI components.  It calls the method: <i>create_main_panel</i>, which
in turn calls methods named such as: <i>assemble_tab_files()</i>,
<i>assemble_tab_timeseries</i>, etc.  These methods all create
GUI components and put them together in a <i>GridBagLayout</i>. They
do not worry about setting correct values in the components' fields, but just
gets the components set up.  The main components in the GUI consists of:
<ul><li>JPanel that contains general information pertinent to the ExportProduct
object at the top of the GUI</li>
<li>a series of tabs in a JTabbedPane with fields for the ExportProduct and a
tab (the "timeseries" tab) for the related ExportConf objects, seperated by
general topic. Tab topics include: <ul><li>automation </li> <li>file </li>
<li>security </li><li> timeseries</li><li>properties</li><li>archive</li>
</ul> </li>
<li>a panel added at the bottom that includes the standard buttons for:
<ul><li>apply</li><li>close</li><li>cancel</li></ul></li></ul>
At the end of <i>init_layout_gui</i>, a
call to <i>update_gui_fields</i> is made which fills in all the
fields of the GUI according to the ExportProduct and ExportConf objects
currently being worked with.
*/
private void init_layout_GUI( ) {
	String routine = __class + ".init_layout_GUI";

	//set up global worksheet Proplist
 	__worksheet_PropList = new PropList( "RTAdminAssistant.JWorksheet");
 	__worksheet_PropList.add("JWorksheet.CellFontName=Courier");
 	__worksheet_PropList.add("JWorksheet.CellFontStyle=Plain");
 	__worksheet_PropList.add("JWorksheet.CellFontSize=11");
 	__worksheet_PropList.add("JWorksheet.ColumnHeaderFontName=Arial");
 	__worksheet_PropList.add("JWorksheet.ColumnHeaderFontStyle=Plain");
 	__worksheet_PropList.add("JWorksheet.ColumnHeaderFontSize=11");
 	__worksheet_PropList.add("JWorksheet.ColumnHeaderBackground=LightGray");
 	__worksheet_PropList.add("JWorksheet.ShowRowHeader=false");
 	__worksheet_PropList.add("JWorksheet.ShowPopupMenu=true");
 	__worksheet_PropList.add("JWorksheet.SelectionMode=ExcelSelection");

	try {
 		__main_JPanel = new JPanel();
 		__main_JPanel.setLayout( __gridbag );

		//create the main gui that includes the
		//tabbed panes with additional info about the selected product
		create_main_panel( );

		//fill in the values for all the FIELDS!
		update_GUI_fields();

		//now assemble GUI
		int vcnt = 0;

		if ( __top_group_JPanel != null ) {
			JGUIUtil.addComponent(
 			__main_JPanel, __top_group_JPanel,
			0, vcnt, 1, 1, 0.0, 0.0, __insets,
			GridBagConstraints.BOTH,
			GridBagConstraints.CENTER );

			vcnt++;
		}

		if ( __product_info_JPanel != null ) {
			JGUIUtil.addComponent(
 			__main_JPanel, __product_info_JPanel,
			0, vcnt, 1, 1, 0.0, 0.0, __insets,
			GridBagConstraints.BOTH,
			GridBagConstraints.CENTER );

			vcnt++;
		}

		if ( __close_JPanel != null ) {
			JGUIUtil.addComponent(
 			__main_JPanel, __close_JPanel,
			0, vcnt, 1, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.CENTER );

			vcnt++;
		}

		//pack and set visible
		getContentPane().add( "Center", __main_JPanel );
		pack();
		JGUIUtil.center( this );
		setVisible( true );

		//finally, add the listener
	 	//_info_JTabbedPane.addChangeListener( this );
	}
	catch ( Exception e ) {
		Message.printWarning( 2, routine,
		"Error laying out GUI." );
		Message.printWarning( 2, routine, e );
	}

	//set Worksheet row size
	int widths[] = null;
	if ( __timeseries_tab_selTS_JWorksheet != null ) {
		widths = ( __timeseries_tab_selTS_JWorksheet.getCellRenderer()).
		getColumnWidths();
	}
	if ( widths != null  ) {
 		__timeseries_tab_selTS_JWorksheet.setColumnWidths( widths );
	}

} //end init_layout_GUI

/**
Method updates the days listed in the day JComboBox in the
automation tab, depending on the month selected in the month
JComboBox.
*/
protected void update_automation_days() {
	String mo_str = null;
	String yr_str = null;
	mo_str = (String ) __automation_tab_month_JComboBox.getSelected();
	yr_str = (String ) __automation_tab_year_JComboBox.getSelected();
	int yr_int = 2000;
	int mo_int = 1;
	int num_days = 31;

	if ( mo_str.startsWith( "*" ) ){
		//have 31 days in day combo
	}
	else {
		int ind = -999;
		ind = mo_str.indexOf(" -" );
		if ( ind > 0 ) {
			mo_str = mo_str.substring( 0, ind );
		}
		//year to integer
		if ( StringUtil.isInteger( yr_str ) ) {
			yr_int = StringUtil.atoi( yr_str );
		}
		if ( StringUtil.isInteger( mo_str ) ) {
			mo_int = StringUtil.atoi( mo_str );
		}
		//get number of days for month selected
		num_days = TimeUtil.numDaysInMonth( mo_int, yr_int );
	}

	//now update the day JComboBox
 	__automation_tab_day_JComboBox.removeAllItems();
 	__automation_tab_day_JComboBox.addItem( "* - All" );
	for ( int i=1; i<=num_days; i++ ) {
 		__automation_tab_day_JComboBox.addItem( String.valueOf(i) );

	}
}//end update_automation_days

/**
This method: <ul>
<li>makes a confirmation message to verify that the user wants to save the
changes (and lists out all the changes from the <i>__dirty_vect</i>) <b>if</b>
a new ExportProduct was <b>not</b> created (if a new ExportProduct was created,
we do not want to re-confirm every change)</li>
<li>writes the <i>__gui</i> version of the objects to the database</li>
<li>if the objects were successfully written to the database, the
<i>__gui</i> objects are marked as <b>not</b> dirty
( <i>setDirty(false)</i></li>
<li><i>__dirty_vect</i> is cleared out</li>
<li>if we created a new ExportProduct object (<i>__bln_new_object == true</i>),
add a new node on the JTree in the main application  - <b>or</b> -  update the
existing ExportProduct node on the JTree with the new changes.</li>
</ul>
@exception Exception thrown if error encountered.
*/
protected void update_database( ) throws Exception {
	String routine = __class + ".update_database";

	//holds messages from __dirty_vect
	StringBuffer b = new StringBuffer();
	for ( int i=0; i< __dirty_vect.size(); i++ ) {
		if ( i == ( __dirty_vect.size()-1) ) {
			b.append( (String) __dirty_vect.elementAt(i) );
		}
		else {
			b.append( (String) __dirty_vect.elementAt(i) + "\n" );
		}


	}

	//see if __gui_RTi_ExportConf_vect has any dirty elements
	int ec_size = 0;
	boolean dirty_exportconf = false;
	RiversideDB_ExportConf ec = null;
	if ( __gui_RTi_ExportConf_vect != null ) {
		ec_size = __gui_RTi_ExportConf_vect.size();
	}
	for ( int i=0; i<ec_size; i++ ) {
		ec = ( RiversideDB_ExportConf )
 		__gui_RTi_ExportConf_vect.elementAt(i);
		if ( ec == null ) {
			continue;
		}
		if ( ec.isDirty() ) {
			dirty_exportconf = true;
			break;
		}
		ec = null;
	}

	//if we are running in cautious mode and if we
	//are changing an already existing object ( not a completely new one),
	//then prompt the user before writing to the database
	if( ( __cautious_mode ) && ( ! __bln_new_object ) ) {
		if (( __gui_RTi_ExportProduct.isDirty()) ||
		( dirty_exportconf) ) {
			//write out a confirmation message.

			int x = new ResponseJDialog( this,
			"Confirm Changes to be saved to database",
			"Confirm Changes:\n" +b.toString(),
			ResponseJDialog.YES | ResponseJDialog.NO ).response();

			if ( x == ResponseJDialog.YES ) {
				Message.printStatus( 1, routine,
				"Saving changes to the database. ");

				//write to log file
				Message.printStatus( 5, routine,
				"User confirmed changes: " +b.toString() );
			}
			else {
				//write to log file
				Message.printStatus( 5, routine,
				"User denied changes: " +b.toString() );
				//empty out dirty vector
 				__dirty_vect.clear();
				throw new Exception (
				"User choose not to write changes "+
				"back to database." );
			}
		}
	}

	if ( __gui_RTi_ExportProduct.isDirty() ) {
		//update title - identifier may have changed for
		//a current ImportProduct Or, if we are adding a new
		//ExportProduct, need to update title from "New xx" to
		//use the identifier.
		this.setTitle( "RiverTrak Assistant - " +
		"Export Product - " +
 		__product_info_id_JTextField.getText().trim() );

		if ( Message.isDebugOn ) {
			Message.printDebug( 2, routine,
			"Trying to write ExportProduct with DBUser = \"" +
 			__gui_RTi_ExportProduct.getDBUser_num() + "\"," +
			"DBGroup= \"" + __gui_RTi_ExportProduct.getDBGroup_num()+
			"\", and DBPermissions= \"" +
 			__gui_RTi_ExportProduct.getDBPermissions() + "\"." );
		}
		try {
			//write product
 			__dmi.writeExportProduct( __gui_RTi_ExportProduct );
			Message.printStatus( 15, routine,
			"ExportProduct written to database." );
		}
		catch ( Exception e ) {
			Message.printWarning( 2, routine, e );
			Message.printWarning( 1, routine,
			"Error writing ExportProduct to database!", this );

 			__gui_RTi_ExportProduct.setDirty( true );

			throw new Exception(
			"Error writing ExportProduct to database" );
		}

		//update node on tree to reflect any changes
		String gui_name = null;
		gui_name = __product_info_id_JTextField.getText().trim();

		String gui_grp = null;
		gui_grp = (String) __product_info_group_JComboBox.
		getSelected();

		//format: "1 - Exports" - just need the Identifier(no number)
		int ind = -999;
		ind = gui_grp.indexOf( " -");
		if ( ind > 0 ) {
			gui_grp = gui_grp.substring( ind +2 ).trim();
		}

		if ( __bln_new_object ) {
			//now if we are ADDING a new ExportProduct,
			//tell the main application so a new node can be
			//added to the Export JTree
 			addExportProductNode(	gui_grp,
 						gui_name,
 						__gui_RTi_ExportProduct );

			//set Flag to false so hitting "Apply" repeatedly
			//won't keep on adding nodes to the JTree
 			__bln_new_object = false;
		}
		else { //we are updating a already present node
			updateExportProductNode (__gui_RTi_ExportProduct,
 						 __db_tree_node_str);
		}

		//since database has been updated, update dirty flag
 		__gui_RTi_ExportProduct.setDirty( false );
	}
	//also need to update ExportConf objects.
	//See if there has been an alteration to the original
	//vector of ExportConf objects. Do not try and delete though if we
	//are adding a completely new importProduct
	if ( dirty_exportconf ) {
		if ( ! __bln_new_object ) {
			//delete all the ExportConf items in the Database
			//using the current product number:_db_ExportProduct_num
			Message.printDebug( 5, routine,
			"ExportConf objects will be deleted from "+
			"the database for ExportProduct_num: " +
 			__db_ExportProduct_num );
			try {
 				__dmi.deleteExportConfForExportProduct_num(
				(int) __db_ExportProduct_num );
			}
			catch ( Exception e ) {
				Message.printWarning( 2, routine, e );
				Message.printWarning( 2, routine,
				"Unable to delete the current ExportConf " +
				"objects from the database." );
			}
		}

		ec = null;
		for ( int i=0; i<ec_size; i++ ) {
			ec = ( RiversideDB_ExportConf )
 			__gui_RTi_ExportConf_vect.elementAt(i);
			if ( ec == null ) {
				continue;
			}

			//write to database
			Message.printStatus( 15, routine,
			"Updating the ExportConf object with " +
			"with ExportProduct_num = " + __db_ExportProduct_num +
			" and MeasType_num: " + ec.getMeasType_num() +
			" to the database. " );
			try {
 				__dmi.writeExportConf( ec );
				ec.setDirty( false );
			}
			catch ( Exception e ) {
				Message.printWarning( 2, routine, e );
				Message.printWarning( 2, routine,
				"Unable to write the updated ExportConf " +
				"object with MeasType_num " +
				ec.getMeasType_num() + " to the database. " );

				ec.setDirty( true );
			}
		}//end loop
	}

	//empty out dirty vector
 	__dirty_vect.clear();

} //end update_database

/**
Sets Export Date Start and End fields enabled or disabled
depending on whether the JCheckBox for using "CURRENT" date,
is checked or unchecked.  This is called by the ItemEvent
caused by a change in the "checked" status of the
__props_tab_export_start_current_JCheckBox or
__props_tab_export_end_current_JCheckBox.  If the JCheckBoxes
are selected, then the JCombBoxes for selecting: +/-, number, and
DAY/HOUR, used to format the interval for setting the start or
end export dates, are not enabled.  If the JCheckBoxes are not
selected, then the JComboBoxes are activated.
@param s String representing whether the event was fired by
the __props_tab_export_start_current_JCheckBox ("start") or by the
__props_tab_export_end_current_JCheckBox ("end").
*/
protected void update_export_date_fields( String s ) {
	boolean checked = false;
	if ( s.equalsIgnoreCase( "start" ) ) {
		checked = __props_tab_export_start_current_JCheckBox.
		isSelected();
		if ( checked ) {
			JGUIUtil.setEnabled(
			__props_tab_export_start_plusminus_JComboBox, false );
			JGUIUtil.setEnabled(
			__props_tab_export_start_numb_JComboBox, false );
			JGUIUtil.setEnabled(
			__props_tab_export_start_dayhr_JComboBox, false );
		}
		else { //JCheckBox is not selected
			JGUIUtil.setEnabled(
			__props_tab_export_start_plusminus_JComboBox, true);
			JGUIUtil.setEnabled(
			__props_tab_export_start_numb_JComboBox, true );
			JGUIUtil.setEnabled(
			__props_tab_export_start_dayhr_JComboBox, true );
		}

	}
	else if ( s.equalsIgnoreCase( "end" ) ) {
		checked = __props_tab_export_end_current_JCheckBox.
		isSelected();
		if ( checked ) {
			JGUIUtil.setEnabled(
			__props_tab_export_end_plusminus_JComboBox, false );
			JGUIUtil.setEnabled(
			__props_tab_export_end_numb_JComboBox, false );
			JGUIUtil.setEnabled(
			__props_tab_export_end_dayhr_JComboBox, false );
		}
		else { //JCheckBox is not selected
			JGUIUtil.setEnabled(
			__props_tab_export_end_plusminus_JComboBox, true );
			JGUIUtil.setEnabled(
			__props_tab_export_end_numb_JComboBox, true );
			JGUIUtil.setEnabled(
			__props_tab_export_end_dayhr_JComboBox, true );
		}
	}
}

/**
This method:<ul>
<li><b>creates the <i>__gui</i> versions of the objects!</b> This includes: <ul><li>__gui_RTi_ExportProduct</li><li>__gui_RTi_ExportConf_vect</li></ul> The
<i>__gui</i> versions are created in this method by copying the <i>__db</i>
versions (which were originally created and set up in the constructor)</li>
<li>calls the <i>verify_xxx</i> methods. These include:<ul>
<li><i>verify_top_fields()</i></li>
<li><i>verify_archive_tab()</i></li>
<li><i>verify_automation_tab()</i></li>
<li><i>verify_files_tab()</i></li>
<li><i>verify_properties_tab()</i></li>
<li><i>verify_timeseries_tab()</i></li> </ul>
The <i>verify_xxx</i> methods:<ul><li> fill in the <i>__gui</i> verions of the objects
in memory with the values that are currently set in the GUI</li>
<li>compares the values in the <i>__gui</i> version of the objects to the
<i>__db</i> version of the objects.  If the <i>__gui</i> versions differ
from the <i>__db</i> verions:<ul>
<li>the <i>__gui</i> versions are marked dirty (<i>.setDirty(true)</i>)</li>
<li>messages are added to the <i>__dirty_vect</i> indicating how the
<i>__gui</i> differs from the <i>__db</i> version (the <i>__db</i> version
remember, represents how the object is in the database itself) </li></ul>
</li></ul></ul>
@param Exception thrown if error encountered.

*/
protected void update_RiversideDB_objects( ) throws Exception {
	String routine = __class + ".update_RiversideDB_objects";

	//create the "_gui" version of the objects to manipulate
 	__gui_RTi_ExportProduct = new RiversideDB_ExportProduct(
 	__db_RTi_ExportProduct );

	int s = 0;
	if ( __db_RTi_ExportConf_vect != null ){
		s = __db_RTi_ExportConf_vect.size();
	}

	//clearn out GUI version and refill it
 	__gui_RTi_ExportConf_vect.clear();
	for ( int i=0; i<s; i++ ) {
 		__gui_RTi_ExportConf_vect.addElement(
 		__db_RTi_ExportConf_vect.elementAt(i) );
	}

	boolean blnContinue = true;

	//get the Top values and then verify the tabs
	try {
		verify_top_fields();
	}
	catch (Exception e) {
		Message.printWarning( 2, routine, e);
		blnContinue = false;
	}
	if ( blnContinue ) {
		verify_tab_info(); //this will get the time series tab too.
	}

} //end update_RiversideDB_objects


/**
This method: <ul><li>determines if the current user, already known to the DMI,
has write permissions.  If the user does not have write permissions, the
<b>apply</b> and <b>close</b> buttons are disabled, leaving only the
<b>cancel</b> button enabled.</li><li>Fills in all the GUI fields according
to the data in the ExportProduct and related ExportConf objects.</li></ul>
*/
protected void update_GUI_fields( ) {
	String routine = __class + ".update_GUI_fields";

	//create rest of GUI using specific info from the product chosen.
	if ( Message.isDebugOn ) {
		Message.printDebug( 5, routine,
		"Selected product from the list of available " +
		"products: \"" + __product_info_id_JTextField.getText() );
	}

	//check to see which buttons should be enabled
	if ( ! __canWriteExportProduct ) {
 		JGUIUtil.setEnabled(__apply_JButton, false );
 		JGUIUtil.setEnabled(__close_JButton, false );
	}

	//change title in titled border to reflect new product selected
	//_titled_border.setTitle( __product_info_id_JTextField.getText() );
 	__product_info_JPanel.repaint( 200 );
	///////// ID //////////////////
	String db_id = null;
	db_id = __db_RTi_ExportProduct.getProduct_name();
 	__product_info_id_JTextField.setText( db_id );

	///////// GROUP //////////////////
	int db_grp_num = -999;
	db_grp_num = __db_RTi_ExportProduct.getProductGroup_num();
	if ( Message.isDebugOn ) {
		Message.printDebug( 15, routine,
		"ProductGroup_num for ExportProduct is:\"" +db_grp_num+ "\"." );
	}
	try {
		JGUIUtil.selectTokenMatches(
 		__product_info_group_JComboBox, true, " - ", 0, 0,
		String.valueOf( db_grp_num), "" );
	}
	catch ( Exception e ) {
		Message.printWarning( 20, routine, e);
	}

	///////// TYPE //////////////////
	//The Type Combo box has the type, followed by a brief
	//description.  For instance, one item might be:
	//"TSLOOKUP - File contianing time series data", where
	//the Type itself is the "TSLOOKUP"

	//Find the RiversideDB_ExportType object that matches...
	//Go through list of ExportType objects
	//No "none" option for type

	String db_type = null;
	db_type = __db_ExportProduct_type;
	if ( Message.isDebugOn ) {
		Message.printDebug( 15, routine,
		"Type for ExportProduct is:\"" + db_type + "\"." );
	}
	if ( db_type != null ) {
		//try and select the specific type from the list of types...
		//_product_info_type_JComboBox.setSelectedItem( db_type );
		try {
			JGUIUtil.selectTokenMatches(
 			__product_info_type_JComboBox, true,
			" - ", 0, 0, db_type, "" );
		}
		catch (	Exception e ) {
			Message.printWarning( 5, routine, e );
		}
		//REVISIT [LT] 2005-02-01 - Replace JComboBox by JTextField.
		//__product_info_type_JTextField.setText(???);
	}

	////////MeasLocGroup
	int measlocgrp_num = -999;
	measlocgrp_num = __db_RTi_ExportProduct.getMeasLocGroup_num();
	//might be -999 if creating a new ExportProduct
	if ( Message.isDebugOn ) {
		Message.printDebug( 15, routine,
		"MeasLocGroup_num for ExportProduct is:\"" + measlocgrp_num +
		"\"." );
	}
	if ( measlocgrp_num > 0 ) {
		//try and select the specific type from the list of types...
		try {
			JGUIUtil.selectTokenMatches(
 			__product_info_measlocgroup_JComboBox, true,
			" - ", 0, 0, String.valueOf(measlocgrp_num), "" );
		}
		catch (	Exception e ) {
			Message.printWarning( 5, routine, e );
		}
	}
	//else- let it default to the first item in the list


	///////////////// isActive /////////////////
	//get the state for the isActive CheckBox
	String db_isActive_str = null;
	boolean isActive_bool = false;
	db_isActive_str = __db_RTi_ExportProduct.getIsActive();
	if ( Message.isDebugOn ) {
		Message.printDebug( 5, routine,
		"isActive parameter for Export Product is: \"" +
		db_isActive_str + "\"." );
	}

	//make sure it is Y or N
	if ( db_isActive_str.equalsIgnoreCase( "Y" ) ) {
		isActive_bool = true;
	}
	else {
		//set it to No
		isActive_bool = false;
	}
	//now set the button
 	__product_info_active_JCheckBox.setSelected( isActive_bool );

	//////////////// FILES TAB /////////////////
	if ( __files_tab_JPanel != null ) {
		update_GUI_fields_filesTab();
	}

	//////////////// Properties TAB /////////////////
	if ( __properties_tab_JPanel != null ) {
		update_GUI_fields_propertiesTab();
	}
	//////////////// AUTOMATION TAB /////////////////
	if ( __automation_tab_JPanel != null ) {
		update_GUI_fields_automationTab();
	}
	////////////// SECURITY TAB /////////////////
	if ( __security_tab_JPanel != null ) {
		update_GUI_fields_securityTab();
	}

	//////// TIME SERIES /////////////
	//JWorksheet set up at GUI creation time and then
	//is updated via the move_right and clear buttons

	validate();
} //end update_GUI_fields


/**
Fills in the components of the automation tab in the GUI with the
parameters for the current RiversideDB_Export object
*/
protected void update_GUI_fields_automationTab( ) {
	String routine = __class + ".update_GUI_fields_automationTab";

	String automated = null;
	boolean isAuto = true;
	try {
		automated = __db_RTi_ExportProduct.getIsAutomated();
		if ( Message.isDebugOn ) {
			Message.printDebug( 5, routine,
			"Value for isAutomated is: \"" +
			automated + "\"." );
		}
	}
	catch ( Exception e ) {
		Message.printWarning( 2, routine, e );
	}

	//now we have the Y or N string - change to boolean...
	if ( automated.equalsIgnoreCase( "N" ) ) {
		isAuto = false;
		//if isAutomated is false, the other fields should be
		//disabled.
	}
	//else Leave as is: isAuto = true

	//set checkBox
 	__automation_tab_automated_JCheckBox.setSelected( isAuto );

	//all the other fields should be active.
	//If the checkbox is checked or not, make sure
	//the year, month, day, etc text fields are active.
 	JGUIUtil.setEnabled(__automation_tab_year_JComboBox, isAuto );

	//IF "every ith interval" is checked
 	JGUIUtil.setEnabled(__automation_tab_month_JComboBox, isAuto );
 	JGUIUtil.setEnabled(__automation_tab_day_JComboBox, isAuto );
 	JGUIUtil.setEnabled(__automation_tab_hour_JComboBox, isAuto );
 	JGUIUtil.setEnabled(__automation_tab_minute_JComboBox, isAuto );
 	JGUIUtil.setEnabled(__automation_tab_second_JComboBox, isAuto );

	String interv = null;
	//since these two checkboxes are in a ButtonGroup,
	//only 1 can be checked at a time...
	boolean isInterval = true;

	try {
		interv = __db_RTi_ExportProduct.getIsInterval();
		if ( Message.isDebugOn ) {
			Message.printDebug( 5, routine,
			"Value for isInteval is: \"" +
			interv + "\"." );
		}
		if ( interv.equalsIgnoreCase( "Y" ) ){
			isInterval = true;
		}
		else {
			isInterval = false;
		}
	}
	catch ( Exception e ) {
		Message.printWarning( 2, routine, e );
	}
 	__automation_tab_every_interval_JRadioButton.setSelected( isInterval );
 	__automation_tab_at_time_JRadioButton.setSelected( !isInterval );

	String yr = null;
	try {
		yr = __db_RTi_ExportProduct.getExport_year();
		if ( Message.isDebugOn ) {
			Message.printDebug( 5, routine,
			"Value for Export year is: \"" +
			yr + "\"." );
		}
	}
	catch ( Exception e ) {
		Message.printWarning( 2, routine, e );
	}
	//For defining a New ExportProduct
		if (( yr == null ) || ( DMIUtil.isMissing(yr) ) ) {
		yr = "*";
	}

	//No choice for year- only choice is "* - All"

	String mo = null;

	try {
		mo = __db_RTi_ExportProduct.getExport_month();
		if ( Message.isDebugOn ) {
			Message.printDebug( 5, routine,
			"Value for Export month is: \"" +
			mo + "\"." );
		}
	}
	catch ( Exception e ) {
		Message.printWarning( 2, routine, e );
	}

	//For defining a New ExportProduct
	if (( mo == null ) || ( DMIUtil.isMissing(mo) ) ) {
		mo = "*";
	}

	try {
		JGUIUtil.selectTokenMatches(
 		__automation_tab_month_JComboBox, true,
		" - ", 0, 0, mo, "" );
	}
	catch (Exception e ) {
		Message.printWarning( 5, routine, e );
		}
	//update days vector to have correct number of days for
	//month selected
	update_automation_days();

	String day = null;
	try {
		day = __db_RTi_ExportProduct.getExport_day();
		if ( Message.isDebugOn ) {
			Message.printDebug( 5, routine,
			"Value for Export day is: \"" +
			day + "\"." );
		}
	}
	catch ( Exception e ) {
		Message.printWarning( 2, routine, e );
	}

	//For defining a New ExportProduct
	if (( day == null ) || ( DMIUtil.isMissing(day ) ) ) {
		day = "*";
	}
	if ( day.equalsIgnoreCase("*" ) ) {
		try {
			JGUIUtil.selectTokenMatches(
 			__automation_tab_day_JComboBox, true,
			" - ", 0, 0, day, "" );
		}
		catch (Exception e ) {
			Message.printWarning( 5, routine, e );
		}
	}
	else {
 		__automation_tab_day_JComboBox.setSelectedItem( day);
	}

	String hr = null;
	try {
		hr = __db_RTi_ExportProduct.getExport_hour();
		if ( Message.isDebugOn ) {
			Message.printDebug( 5, routine,
			"Value for Export hour is: \"" +
			hr + "\"." );
		}
	}
	catch ( Exception e ) {
		Message.printWarning( 2, routine, e );
	}

	//For defining a New ExportProduct
	if (( hr == null ) || ( DMIUtil.isMissing(hr) ) ) {
		hr = "*";
	}

 	__automation_tab_hour_JComboBox.setSelectedItem( hr );

	String min = null;
	try {
		min = __db_RTi_ExportProduct.getExport_minute();
		if ( Message.isDebugOn ) {
			Message.printDebug( 5, routine,
			"Value for Export minute is: \"" +
			min + "\"." );
		}
	}
	catch ( Exception e ) {
		Message.printWarning( 2, routine, e );
	}

	//For defining a New ExportProduct
	if (( min == null ) || ( DMIUtil.isMissing(min) ) ) {
		min = "15";
	}

 	__automation_tab_minute_JComboBox.setSelectedItem( min );

	String sec = null;
	try {
		sec = __db_RTi_ExportProduct.getExport_second();
		if ( Message.isDebugOn ) {
			Message.printDebug( 5, routine,
			"Value for Export second is: \"" +
			sec + "\"." );
		}
	}
	catch ( Exception e ) {
		Message.printWarning( 2, routine, e );
	}

	//For defining a New ExportProduct
	if (( sec == null ) || ( DMIUtil.isMissing(sec ) ) ) {
		sec = "*";
	}

 	__automation_tab_second_JComboBox.setSelectedItem( sec );

	String weekday = null;
	try {
		weekday = __db_RTi_ExportProduct.getExport_weekday();
		if ( Message.isDebugOn ) {
			Message.printDebug( 5, routine,
			"Value for Export weekday is: \"" +
			weekday + "\"." );
		}
	}
	catch ( Exception e ) {
		Message.printWarning( 2, routine, e );
	}

	//For defining a New ExportProduct
	if (( weekday == null ) || ( DMIUtil.isMissing(weekday) ) ) {
		weekday = "*";
	}

	try {
		JGUIUtil.selectTokenMatches(
 		__automation_tab_weekday_JComboBox, true,
		" - ", 0, 0, mo, "" );
	}
	catch (Exception e ) {
		Message.printWarning( 5, routine, e );
	}

} //end update_GUI_fields_automationTab

/**
Fills in the components of the files tab in the GUI with the
parameters for the current RiversideDB_Export object
*/
protected void update_GUI_fields_filesTab( ) {
	String routine = __class + ".update_GUI_fields_filesTab";

	//get current destination DIRECTORY
	String db_dest_dir = null;
	db_dest_dir = __db_RTi_ExportProduct.getDestination_dir();
	if ( Message.isDebugOn ) {
		Message.printDebug( 5, routine,
		"Destination directory is: \"" + db_dest_dir + "\"." );
	}
 	__files_tab_dest_dir_JTextField.setText( db_dest_dir );

	//get current destination FILE
	String db_dest_file = null;
	db_dest_file = __db_RTi_ExportProduct.getDestination_file();
	if ( Message.isDebugOn ) {
		Message.printDebug( 5, routine,
		"Destination file is: \"" + db_dest_file + "\"." );
	}

 	__files_tab_dest_file_JTextField.setText( db_dest_file );
}//end update_GUI_fields_filesTab

/**
Fills in the components of the properties tab in the GUI
with the parameters for the current RiversideDB_Export object
*/
protected void update_GUI_fields_propertiesTab( ) {
	String routine = __class + ".update_GUI_fields_propertiesTab";

	//get the current Export order - REQUIRED FIELD
	long db_exp_order_long = -999;
	db_exp_order_long = __db_RTi_ExportProduct.getExport_order();
	if ( Message.isDebugOn ) {
		Message.printDebug( 5, routine,
		"Export Order = \"" +
		String.valueOf( db_exp_order_long )+ "\"." );
	}
	//default to 2
	if ( ( db_exp_order_long < 0 ) ||
	( DMIUtil.isMissing(db_exp_order_long) ) ) {
 		__props_tab_export_order_JComboBox.setSelectedItem( "2" );
	}
	else {
 		__props_tab_export_order_JComboBox.setSelectedItem(
		String.valueOf( db_exp_order_long ) );
	}

	//export Start date
	String db_start_str = __db_RTi_ExportProduct.getExport_start();
	if ( Message.isDebugOn ) {
		Message.printDebug( 3, routine,
		"db_start_str = \"" + db_start_str + "\"" );
	}
	if ( ( db_start_str == null ) || ( db_start_str.length() <= 0 )) {
		//we have a new ExportProduct. Default start to -10 Days
		__props_tab_export_start_plusminus_JComboBox.
		setSelectedItem( "-" );
		__props_tab_export_start_numb_JComboBox.
		setSelectedItem( "10" );
		__props_tab_export_start_dayhr_JComboBox.
		setSelectedItem( "DAY" );
	}
	else if ( db_start_str.equalsIgnoreCase( "CURRENT" ) ) {
		__props_tab_export_start_current_JCheckBox.setSelected( true );
		update_export_date_fields( "start" );
	}
	else {
		int ind = -999;
		//break String into: 1)"+"or"-", 2) number, 3) "DAY" or "HOUR"
		// 1) get "+" or "-"
		ind = db_start_str.indexOf( "-" );
		if ( ind >= 0 ) {
			__props_tab_export_start_plusminus_JComboBox.
			setSelectedItem( "-" );
			db_start_str = db_start_str.substring( ind +1 );
		}
		else {
			ind = db_start_str.indexOf( "+" );
			if ( ind >= 0 ) {
				//"+" is selected by default since it is
				//first in the JComboBox list
			//	__props_tab_export_start_plusminus_JComboBox.
			//	setSelectedItem( "-" );
				db_start_str = db_start_str.substring( ind +1 );
			}
		}

		// 2) get number and at same time,
		// 3) get DAY or HOUR
		String num_str = null;
		ind = db_start_str.indexOf( "HOUR" );
		if ( ind >= 0 ) {
			//set HOUR selected
			__props_tab_export_start_dayhr_JComboBox.
			setSelectedItem( "HOUR");
			num_str = db_start_str.substring( 0, ind ).trim();
			if ( StringUtil.isInteger( num_str ) ) {
				//set the number selected if it is
				//in the list. IF not, add it.
				__props_tab_export_start_plusminus_JComboBox.
				setSelectedItem( num_str );
			}

		}
		else {
			ind = db_start_str.indexOf( "DAY" );
			if ( ind >= 0 ) {
				//set DAY selected
				__props_tab_export_start_dayhr_JComboBox.
				setSelectedItem( "DAY");

				//get value for Number to select
				num_str = db_start_str.substring( 0, ind ).
				trim();
				if ( StringUtil.isInteger( num_str ) ) {
					boolean boolFoundMatch = false;
					//set the number selected if it
					//exists in the list. If it does
					//not, add it.
					int cnt =
					__props_tab_export_start_numb_JComboBox.
					getItemCount();
					String tmp_str = null;
					for ( int i=0; i<cnt;i++ ) {
						tmp_str = (String)
						__props_tab_export_start_numb_JComboBox.
						getItemAt( i );
						if ( tmp_str.equalsIgnoreCase( num_str ) ) {
							//match, so set it
							//selected
							__props_tab_export_start_numb_JComboBox.
							setSelectedIndex(i);
							boolFoundMatch = true;
							break;

						}
					}
					if ( ! boolFoundMatch ) {
						//add num_str to JComboBox
						__props_tab_export_start_numb_JComboBox.
						addItem( num_str );
						__props_tab_export_start_numb_JComboBox.
						setSelectedItem( num_str );
					}
				}
			}
		}
	}

	//export end date
	String db_end_str = __db_RTi_ExportProduct.getExport_end();
	if ( Message.isDebugOn ) {
		Message.printDebug( 3, routine,
		"db_end_str = \"" + db_end_str + "\"" );
	}
	if ( ( db_end_str == null ) || ( db_end_str.length() <= 0 )) {
		//we have a new ExportProduct. Default end to CURRENT
		__props_tab_export_end_current_JCheckBox.setSelected( true );
		update_export_date_fields( "end" );
	}
	else if ( db_end_str.equalsIgnoreCase( "CURRENT" ) ) {
		__props_tab_export_end_current_JCheckBox.setSelected( true );
		update_export_date_fields( "end" );
	}
	else {
		int ind = -999;
		//break String into: 1)"+"or"-", 2) number, 3) "DAY" or "HOUR"
		// 1) get "+" or "-"
		ind = db_end_str.indexOf( "-" );
		if ( ind >= 0 ) {
			__props_tab_export_end_plusminus_JComboBox.
			setSelectedItem( "-" );
			db_end_str = db_end_str.substring( ind +1 );
		}
		else {
			ind = db_end_str.indexOf( "+" );
			if ( ind >= 0 ) {
				//"+" is selected by default since it is
				//first in the JComboBox list
			//	__props_tab_export_end_plusminus_JComboBox.
			//	setSelectedItem( "-" );
				db_end_str = db_end_str.substring( ind +1 );
			}
		}

		// 2) get number and at same time,
		// 3) get DAY or HOUR
		String num_str = null;
		ind = db_end_str.indexOf( "HOUR" );
		if ( ind >= 0 ) {
			//set HOUR selected
			__props_tab_export_end_plusminus_JComboBox.
			setSelectedItem( "HOUR");
			num_str = db_end_str.substring( 0, ind ).trim();
			if ( StringUtil.isInteger( num_str ) ) {
				//set the number selected if it is
				//in the list. IF not, add it.
				__props_tab_export_end_plusminus_JComboBox.
				setSelectedItem( num_str );
			}

		}
		else {
			ind = db_end_str.indexOf( "DAY" );
			if ( ind >= 0 ) {
				//set DAY selected
				__props_tab_export_end_dayhr_JComboBox.
				setSelectedItem( "DAY");

				//get value for Number to select
				num_str = db_end_str.substring( 0, ind ).
				trim();
				if ( StringUtil.isInteger( num_str ) ) {
					boolean boolFoundMatch = false;
					//set the number selected if it
					//exists in the list. If it does
					//not, add it.
					int cnt =
					__props_tab_export_end_numb_JComboBox.
					getItemCount();
					String tmp_str = null;
					for ( int i=0; i<cnt;i++ ) {
						tmp_str = (String)
						__props_tab_export_end_numb_JComboBox.
						getItemAt( i );
						if ( tmp_str.equalsIgnoreCase( num_str ) ) {
							//match, so set it
							//selected
							__props_tab_export_end_numb_JComboBox.
							setSelectedIndex(i);
							boolFoundMatch = true;
							break;

						}
					}
					if ( ! boolFoundMatch ) {
						//add num_str to JComboBox
						__props_tab_export_end_numb_JComboBox.
						addItem( num_str );
						__props_tab_export_end_numb_JComboBox.
						setSelectedItem( num_str );
					}
				}
			}
		}
	}


	//current value for last Export date is uneditable
	Date d = null;
	try {
		d = __db_RTi_ExportProduct.getLast_export_date();
	}
	catch ( Exception e ) {
		Message.printWarning( 2, routine, e );
	}
	if ( d != null ) {
		if ( Message.isDebugOn ) {
			Message.printDebug( 5, routine,
			"Last Export Date = \"" + d.toString() + "\"." );
		}
		//now try and change it to a DateTime
		DateTime last_rti_date = null;
		last_rti_date = new DateTime ( d );
		last_rti_date.setPrecision( DateTime.PRECISION_SECOND );

		StringBuffer date_buf = new StringBuffer();
		date_buf.append( (String.valueOf(last_rti_date.getYear())) );
		date_buf.append( "-" );
		date_buf.append(StringUtil.formatString(
			last_rti_date.getMonth(), "%02d") );
		date_buf.append( "-" );
		date_buf.append(StringUtil.formatString(
			last_rti_date.getDay(), "%02d") );
		date_buf.append( " " );
		date_buf.append(StringUtil.formatString(
			last_rti_date.getHour(), "%02d" ) );
		date_buf.append( ":" );
		date_buf.append(StringUtil.formatString(
			last_rti_date.getMinute(), "%02d" ) );
		date_buf.append( ":" );
		date_buf.append(StringUtil.formatString(
			last_rti_date.getSecond(), "%02d" ) );
		date_buf.append("\n");

		if ( date_buf != null ) {
			if ( __props_tab_last_export_date_JTextField != null ) {
 			__props_tab_last_export_date_JTextField.setText(
	 			date_buf.toString() );
			}
		}

		d = null;
		last_rti_date = null;
		date_buf = null;
	}
	//For defining a New ExportProduct
	else {
		if ( __props_tab_last_export_date_JTextField != null ) {
 		__props_tab_last_export_date_JTextField.setText( "" );
		}
	}

	//get current value for next Export date.
	try {
		d = __db_RTi_ExportProduct.getNext_export_date();
	}
	catch ( Exception e ) {
		Message.printWarning( 2, routine, e );
	}

	if ( d != null ) {
		if ( Message.isDebugOn ) {
			Message.printDebug( 5, routine,
			"Next Export Date = \"" + d.toString() + "\"." );
		}
		//now try and change it to a DateTime
		DateTime next_rti_date = null;
		next_rti_date = new DateTime ( d );
		next_rti_date.setPrecision( DateTime.PRECISION_SECOND );

		StringBuffer date_buf = new StringBuffer();
		date_buf.append( (String.valueOf(next_rti_date.getYear())) );
		date_buf.append( "-" );
		date_buf.append(StringUtil.formatString(
			next_rti_date.getMonth(), "%02d") );
		date_buf.append( "-" );
		date_buf.append(StringUtil.formatString(
			next_rti_date.getDay(), "%02d") );
		date_buf.append( " " );
		date_buf.append(StringUtil.formatString(
			next_rti_date.getHour(), "%02d" ) );
		date_buf.append( ":" );
		date_buf.append(StringUtil.formatString(
			next_rti_date.getMinute(), "%02d" ) );
		date_buf.append( ":" );
		date_buf.append(StringUtil.formatString(
			next_rti_date.getSecond(), "%02d" ) );
		date_buf.append("\n");
		if ( date_buf != null ) {
			if ( __props_tab_next_export_date_JTextField != null ) {
 			__props_tab_next_export_date_JTextField.setText(
		 		date_buf.toString() );
			}
		}
		d = null;
		date_buf= null;
		next_rti_date = null;
	}
	//For defining a New ExportProduct
	else {
 		__props_tab_next_export_date_JTextField.setText( "" );
	}

	//get current retries
	long db_retries = 0;
	try {
		db_retries = __db_RTi_ExportProduct.getRetries();
		if ( Message.isDebugOn ) {
			Message.printDebug( 5, routine,
			"Retries: \"" + db_retries + "\"." );
		}
	}
	catch ( Exception e ) {
		Message.printWarning ( 2, routine, e );
	}

	//For defining a New ExportProduct
	if (( DMIUtil.isMissing(db_retries ) ) || ( db_retries < 0 ) ) {
		db_retries = 0;
	}
 	__props_tab_retries_JTextField.setText( String.valueOf(db_retries) );

	//get current properties.
	//As it is in the database, the properties are in one long string
	//with individual property-value sets seperated by ";"s
	//Use getVectorOfProperties to get a Vector of Vectors where
	//each Vector within the main Vector contains the property
	//key at position 0 and value at position 1.
	Vector props_vect = null;
	props_vect = getVectorOfProperties( __db_RTi_ExportProduct );

	//set properties in GUI
	if ( __db_ExportProduct_type.equalsIgnoreCase( __type_comma_str )) {
		update_GUI_fields_propertiesTab_comma_props( props_vect );
	}
	else if (__db_ExportProduct_type.equalsIgnoreCase(__type_graph_str)
	    || __db_ExportProduct_type.equalsIgnoreCase(__type_graph_str_old)) {
		
		
	// TSProduct Need to update the TSProduct with
	//REVISIT TSProduct	
	// The TSProduct control was added to the interface so we could get
	// a output for the documentation, but the code is not yet capable 
	// of set the selection, using the information from the database and 
	// also the machaninsm for retrieve the information from the 
	// control, the checks if the database need to be update and so on
	// was not implemeted.
		
		
		update_GUI_fields_propertiesTab_graph_props( props_vect );
	}
	else if ( __db_ExportProduct_type.equalsIgnoreCase( __type_obsreport_str )) {
		update_GUI_fields_propertiesTab_obsreport_props( props_vect );
	}
	else if ( __db_ExportProduct_type.equalsIgnoreCase( __type_shef_str )) {
		update_GUI_fields_propertiesTab_shef_props( props_vect );
	}
	else if ( __db_ExportProduct_type.equalsIgnoreCase( __type_table_str )) {
		update_GUI_fields_propertiesTab_table_props( props_vect );
	}
	else {
		if ( __props_tab_generic_props_JTextField != null ) {
			update_GUI_fields_propertiesTab_generic_props(
			props_vect );
		}
	}

}//end update_GUI_fields_propertiesTab

/**
Fills in the properties components on the properties tab in the GUI
with the parameters for the current RiversideDB_ExportProduct object
of type COMMA_DELIMINATED.
@param all_props_vect Vector containing all the properties for
this ExportProduct.
*/
protected void update_GUI_fields_propertiesTab_comma_props(
				Vector all_props_vect ) {
	String routine = __class +
	".update_GUI_fields_propertiesTab_comma_props";

	int size = 0;
	if ( all_props_vect != null ) {
		size = all_props_vect.size();
	}
	//go through each and set the appropriate components
	String prop_str = null;
	String prop_value_str = null;
	Vector v = null;
	for ( int i=0; i<size; i++ ) {
		v = (Vector) all_props_vect.elementAt(i);
		prop_str = (String) v.elementAt(0);
		if ( prop_str == null ) {
			continue;
		}
		//DATE FORMAT
		else if ( prop_str.equalsIgnoreCase(
 		__props_dateformat_comma_JLabel_str ) ) {
			//then get its value to set in the combobox/
			prop_value_str = (String)v.elementAt(1);
			try {
				JGUIUtil.selectTokenMatches(
 				__props_dateformat_comma_JComboBox, true,
				" - ", 0, 0, prop_value_str, DEFAULT_str );
			}
			catch ( Exception e ) {
				Message.printWarning( 5, routine, e );
			}
		}
		else if ( prop_str.equalsIgnoreCase(
 		__props_timestamp_comma_JLabel_str ) ) {
			//then get its value to set in the combobox/
			prop_value_str = (String)v.elementAt(1);
			boolean blnTimeStamp = false;
			if (( prop_value_str.equalsIgnoreCase( "Y" ) ) |
			( prop_value_str.equalsIgnoreCase( "true" ) ) ) {
				blnTimeStamp = true;
			}
 			__props_timestamp_obsreport_JCheckBox.
			setSelected( blnTimeStamp );
		}
	}

}//end update_GUI_fields_propertiesTab_comma_props

/**
Fills in the properties components on the properties tab in the GUI
with the parameters for the current RiversideDB_Export object
of type generic.
@param all_props_vect Vector containing all the properties for
this ExportProduct.
*/
protected void update_GUI_fields_propertiesTab_generic_props(
				Vector all_props_vect ) {

	//For now, the generic ExportProduct type just has
	//one JTextField with props seperated by ";" just like in db
	String props_str = null;
	props_str = __db_RTi_ExportProduct.getProperties();
 	__props_tab_generic_props_JTextField.setText( props_str );
}//end update_GUI_fields_propertiesTab_generic_props

/**
Fills in the properties components on the properties tab in the GUI
with the parameters for the current RiversideDB_ExportProduct object
of type GRAPH_JPEG.
@param all_props_vect Vector containing all the properties for
this ExportProduct.
*/
protected void update_GUI_fields_propertiesTab_graph_props(
				Vector all_props_vect ) {
	String routine = __class +
	".update_GUI_fields_propertiesTab_graph_props";
	
	// Set the TSProduct
	int tsProductNum = __db_RTi_ExportProduct.getTSProduct_num();
	try {
		Vector tsProduct_vect = __dmi.readTSProductList();
		if ( tsProduct_vect != null ) {
			int nP = tsProduct_vect.size();
			for ( int n=0; n<nP; n++) {
				RiversideDB_TSProduct rdb_tsp = (RiversideDB_TSProduct)
					tsProduct_vect.elementAt(n);
				if( rdb_tsp.getTSProduct_num() == tsProductNum ) {
					String TSProductName = rdb_tsp.getName();	
					__props_tsProduct_graph_JComboBox.select(
							TSProductName );
					break;
				}	
			}
		}
	} catch ( Exception e ) {   
		Message.printWarning (1, routine, "Error reading TSProduct Table");
	}
	
	// Set the properties
	int size = 0;
	if ( all_props_vect != null ) {
		size = all_props_vect.size();
	}
	//go through each and set the appropriate components
	String prop_str = null;
	String prop_value_str = null;
	Vector v = null;
	for ( int i=0; i<size; i++ ) {
		v = (Vector) all_props_vect.elementAt(i);
		prop_str = (String) v.elementAt(0);
		if ( prop_str == null ) {
			continue;
		}
	
		//title
		else if ( prop_str.equalsIgnoreCase(
 		__props_title_graph_JLabel_str ) ) {
			//set title in GUI if there is one
			prop_value_str = (String)v.elementAt(1);
 			__props_title_graph_JTextField.setText(
			prop_value_str );
		}

		//CREATIONTIME
		else if ( prop_str.equalsIgnoreCase(
 		__props_creationtime_graph_JLabel_str ) ) {
			//then get its value to set in the JCheckBox
			prop_value_str = (String)v.elementAt(1);
			if (( prop_value_str != null ) &&
			( prop_value_str.equalsIgnoreCase( "false" ) ) ) {
 				__props_creationtime_graph_JCheckBox.
				setSelected( false );
			}
			else {
 				__props_creationtime_graph_JCheckBox.
				setSelected( true );
			}
		}
		//Timestamp
		else if ( prop_str.equalsIgnoreCase(
 		__props_timestamp_graph_JLabel_str ) ) {
			//then get its value to set in the JCheckBox
			prop_value_str = (String)v.elementAt(1);
			if ( prop_value_str.equalsIgnoreCase( "true" ) ) {
 				__props_timestamp_graph_JCheckBox.
				setSelected( true );
			}
			else {
 				__props_timestamp_graph_JCheckBox.
				setSelected( false );
			}
		}
		//window dimension
		else if ( prop_str.equalsIgnoreCase(
 		__props_windowdim_graph_JLabel_str ) ) {
			//then get its value to set in the JTextFields
			prop_value_str = (String)v.elementAt(1);
			//this can be nothing or 2 values
			if ( prop_value_str.length() > 0 ) {
				//break it up into 2 values
				Vector tmp_v = null;
				tmp_v = StringUtil.breakStringList(
				prop_value_str, ",",
				StringUtil.DELIM_SKIP_BLANKS );
				if ( tmp_v.size() == 2 ) {
 					__props_windowdim_w_graph_JTextField.
					setText( (String) tmp_v.elementAt(0 ));
 					__props_windowdim_h_graph_JTextField.
					setText( (String) tmp_v.elementAt(1 ));
				}

			}
		}

		//DATE FORMAT
		else if ( prop_str.equalsIgnoreCase(
 		__props_dateformat_graph_JLabel_str ) ) {
			prop_value_str = (String)v.elementAt(1);
			//then get its value to set in the combobox
			try {
				JGUIUtil.selectTokenMatches(
 				__props_dateformat_graph_JComboBox, true,
				" - ", 0, 0, prop_value_str, DEFAULT_str );
			}
			catch ( Exception e ) {
				Message.printWarning( 5, routine, e );
			}
		}

		//annotation lines
		else if ( prop_str.equalsIgnoreCase(
 		__props_annotationline_graph_JLabel_str ) ) {
			prop_value_str = (String)v.elementAt(1);
			if ( prop_value_str == null ) {
				//nothing to set
			}
			else {
				//get value value which will be 1 or 2 numbers
				//If it is 2 numbers, they will be
				//separated by a comma
				int ind = -999;
				ind = prop_value_str.indexOf(",");
				if ( ind > 0 ) {
					Vector tmp_vect = null;
					//break up the numbers
					tmp_vect = StringUtil.breakStringList(
					prop_value_str, ",",
					StringUtil.DELIM_SKIP_BLANKS );
					if ( tmp_vect.size() == 2 ) {
						__props_annotationline_1_graph_JTextField.
						setText( (String) tmp_vect.
						elementAt(0) );
						__props_annotationline_2_graph_JTextField.
						setText( (String) tmp_vect.
						elementAt(1) );
					}
				}
				else {
					//1 value only
						__props_annotationline_1_graph_JTextField.
						setText( prop_value_str );
				}
			}
		}

		//annotation text
		else if ( prop_str.equalsIgnoreCase(
 		__props_annotationtext_graph_JLabel_str ) ) {
			prop_value_str = (String)v.elementAt(1);
			if ( prop_value_str == null ) {
				//nothing to set
			}
			else {
				//get value value which will be 1 or 2 numbers
				//If it is 2 numbers, they will be
				//separated by a comma
				int ind = -999;
				ind = prop_value_str.indexOf(",");
				if ( ind > 0 ) {
					Vector tmp_vect = null;
					//break up the numbers
					tmp_vect = StringUtil.breakStringList(
					prop_value_str, ",",
					StringUtil.DELIM_SKIP_BLANKS );
					if ( tmp_vect.size() == 2 ) {
						__props_annotationtext_1_graph_JTextField.
						setText( (String) tmp_vect.
						elementAt(0) );
						__props_annotationtext_2_graph_JTextField.
						setText( (String) tmp_vect.
						elementAt(1) );
					}
				}
				else {
					//1 value only
						__props_annotationtext_1_graph_JTextField.
						setText( prop_value_str );
				}
			}
		}

		//RANGE
		else if ( prop_str.equalsIgnoreCase(
 		__props_range_graph_JLabel_str ) ) {
			//then get its value to set in the JTextFields
			prop_value_str = (String)v.elementAt(1);
			//this can be nothing or 2 values
			if ( prop_value_str.length() > 0 ) {
				//break it up into 2 values
				Vector tmp_v = null;
				tmp_v = StringUtil.breakStringList(
				prop_value_str, ",",
				StringUtil.DELIM_SKIP_BLANKS );
				if ( tmp_v.size() == 2 ) {
 					__props_range_lo_graph_JTextField.
					setText( (String) tmp_v.elementAt(0 ));
 					__props_range_hi_graph_JTextField.
					setText( (String) tmp_v.elementAt(1 ));
				}

			}
		}

	}

}//end update_GUI_fields_propertiesTab_graph_props

/**
Fills in the properties components on the properties tab in the GUI
with the parameters for the current RiversideDB_ExportProduct object
of type LAST_OBS_REPORT.
@param all_props_vect Vector containing all the properties for
this ExportProduct.
*/
protected void update_GUI_fields_propertiesTab_obsreport_props(
				Vector all_props_vect ) {
	String routine = __class +
	".update_GUI_fields_propertiesTab_obsreport_props";

	int size = 0;
	if ( all_props_vect != null ) {
		size = all_props_vect.size();
	}
	//go through each and set the appropriate components
	String prop_str = null;
	String prop_value_str = null;
	Vector v = null;
	for ( int i=0; i<size; i++ ) {
		v = (Vector) all_props_vect.elementAt(i);
		prop_str = (String) v.elementAt(0);
		if ( prop_str == null ) {
			continue;
		}
		//TIMESTAMP
		else if ( prop_str.equalsIgnoreCase(
 		__props_timestamp_obsreport_JLabel_str ) ) {
			//then get its value to set in the combobox/
			prop_value_str = (String)v.elementAt(1);
			boolean blnTimeStamp = false;
			if (( prop_value_str.equalsIgnoreCase( "Y" ) ) ||
			(prop_value_str.equalsIgnoreCase("true" ) ) ) {
				blnTimeStamp = true;
			}
 			__props_timestamp_obsreport_JCheckBox.
			setSelected( blnTimeStamp );
		}
		//TITLE
		else if ( prop_str.equalsIgnoreCase(
 		__props_title_obsreport_JLabel_str ) ) {
			//then get its value to set in the JTextField
			prop_value_str = (String)v.elementAt(1);
			if ( prop_value_str != null ) {
 				__props_title_obsreport_JTextField.
				setText( prop_value_str );
			}
		}
		//DATE_FORMAT
		else if ( prop_str.equalsIgnoreCase(
 		__props_dateformat_obsreport_JLabel_str ) ) {
			//then get its value to set in the JComboBox
			prop_value_str = (String)v.elementAt(1);
			if ( prop_value_str != null ) {
				try {
					JGUIUtil.selectTokenMatches(
 					__props_dateformat_obsreport_JComboBox,
					true, " - ", 0, 0, prop_value_str,
					DEFAULT_str );
				}
				catch ( Exception e ) {
					Message.printWarning( 5, routine, e );
				}
			}
		}
		else if ( prop_str.equalsIgnoreCase(
 		__props_format_obsreport_JLabel_str ) ) {
			//then get its value to set in the JComboBox
			prop_value_str = (String)v.elementAt(1);
			if ( prop_value_str != null ) {
				try {
					JGUIUtil.selectTokenMatches(
 					__props_format_obsreport_JComboBox,
					true, " - ", 0, 0, prop_value_str,
					"HTML" );
				}
				catch ( Exception e ) {
					Message.printWarning( 5, routine, e );
				}
			}
		}
		else if ( prop_str.equalsIgnoreCase(
 		__props_deliminiter_obsreport_JLabel_str ) ) {
			//then get its value to set in the JComboBox
			prop_value_str = (String)v.elementAt(1);
			if ( prop_value_str != null ) {
 				__props_deliminiter_obsreport_JTextField.
				setText( prop_value_str );
			}
		}
	}

}//end update_GUI_fields_propertiesTab_obsreport_props

/**
Fills in the properties components on the properties tab in the GUI
with the parameters for the current RiversideDB_ExportProduct object
of type SHEF.A.
@param all_props_vect Vector containing all the properties for
this ExportProduct.
*/
protected void update_GUI_fields_propertiesTab_shef_props(
				Vector all_props_vect ) {
	String routine = __class +
	".update_GUI_fields_propertiesTab_shef_props";

	int size = 0;
	if ( all_props_vect != null ) {
		size = all_props_vect.size();
	}
	//go through each and set the appropriate components
	String prop_str = null;
	String prop_value_str = null;
	Vector v = null;
	for ( int i=0; i<size; i++ ) {
		v = (Vector) all_props_vect.elementAt(i);
		prop_str = (String) v.elementAt(0);
		if ( prop_str == null ) {
			continue;
		}
		//TIMESTAMP
		else if ( prop_str.equalsIgnoreCase(
 		__props_timestamp_shef_JLabel_str ) ) {
			//then get its value to set in the combobox/
			prop_value_str = (String)v.elementAt(1);
			boolean blnTimeStamp = false;
			if ( ( prop_value_str.equalsIgnoreCase( "Y" ) ) |
			( prop_value_str.equalsIgnoreCase( "true" ) ) ) {
				blnTimeStamp = true;
			}
 			__props_timestamp_shef_JCheckBox.
			setSelected( blnTimeStamp );
		}
		//USEHOUR24
		else if ( prop_str.equalsIgnoreCase(
 		__props_usehour_shef_JLabel_str ) ) {
			//then get its value to set in the combobox/
			prop_value_str = (String)v.elementAt(1);
			boolean blnUseHour = true;
			if ( prop_value_str.equalsIgnoreCase( "N" ) ) {
				blnUseHour = false;
			}
 			__props_usehour_shef_JCheckBox.
			setSelected( blnUseHour );
		}

		//APPEND
		else if ( prop_str.equalsIgnoreCase(
 		__props_append_shef_JLabel_str ) ) {
			//then get its value to set in the combobox/
			prop_value_str = (String)v.elementAt(1);
			boolean blnAppend = true;
			if ( prop_value_str.equalsIgnoreCase( "false" ) ) {
				blnAppend = false;
			}
 			__props_append_shef_JCheckBox.
			setSelected( blnAppend );
		}
		//DATE FORMAT
		else if ( prop_str.equalsIgnoreCase(
 		__props_dateformat_shef_JLabel_str ) ) {

			prop_value_str = (String)v.elementAt(1);
			//then get its value to set in the combobox/
			try {
				JGUIUtil.selectTokenMatches(
 				__props_dateformat_shef_JComboBox, true,
				" - ", 0, 0, prop_value_str, DEFAULT_str );
			}
			catch ( Exception e ) {
				Message.printWarning( 5, routine, e );
			}
		}
	}

}//end update_GUI_fields_propertiesTab_shef_props

/**
Fills in the properties components on the properties tab in the GUI
with the parameters for the current RiversideDB_ExportProduct object
of type TABLE_REPORT.
@param all_props_vect Vector containing all the properties for
this ExportProduct.
*/
protected void update_GUI_fields_propertiesTab_table_props(
				Vector all_props_vect ) {
	String routine = __class +
	".update_GUI_fields_propertiesTab_table_props";

	int size = 0;
	if ( all_props_vect != null ) {
		size = all_props_vect.size();
	}
	//go through each and set the appropriate components
	String prop_str = null;
	String prop_value_str = null;
	Vector v = null;
	for ( int i=0; i<size; i++ ) {
		v = (Vector) all_props_vect.elementAt(i);
		prop_str = (String) v.elementAt(0);
		if ( prop_str == null ) {
			continue;
		}
		//TIMESTAMP
		else if ( prop_str.equalsIgnoreCase(
 		__props_timestamp_table_JLabel_str ) ) {
			//then get its value to set in the combobox/
			prop_value_str = (String)v.elementAt(1);
			boolean blnTimeStamp = false;
			if ( prop_value_str.equalsIgnoreCase( "true" ) ) {
				blnTimeStamp = true;
			}
 			__props_timestamp_table_JCheckBox.
			setSelected( blnTimeStamp );
		}
		//SHOW_MISSING
		else if ( prop_str.equalsIgnoreCase(
 		__props_hidemissing_table_JLabel_str ) ) {
			//then get its value to set in the combobox/
			prop_value_str = (String)v.elementAt(1);

			boolean blnhideMissing = true;
			if (prop_value_str.equalsIgnoreCase("false" ) ) {
				blnhideMissing = false;
			}
 			__props_hidemissing_table_JCheckBox.
			setSelected( blnhideMissing );
		}
		//DATE FORMAT
		else if ( prop_str.equalsIgnoreCase(
 		__props_dateformat_table_JLabel_str ) ) {
			prop_value_str = (String)v.elementAt(1);
			//then get its value to set in the combobox/
			try {
				JGUIUtil.selectTokenMatches(
 				__props_dateformat_table_JComboBox, true,
				" - ", 0, 0, prop_value_str, DEFAULT_str );
			}
			catch ( Exception e ) {
				Message.printWarning( 5, routine, e );
			}
		}
		//LIST DESC
		else if ( prop_str.equalsIgnoreCase(
 		__props_listorder_table_JLabel_str ) ) {
			prop_value_str = (String)v.elementAt(1);
			//then get its value to set in the combobox/
			try {
				JGUIUtil.selectTokenMatches(
 				__props_listorder_table_JComboBox, true,
				" - ", 0, 0, prop_value_str, DEFAULT_str );
			}
			catch ( Exception e ) {
				Message.printWarning( 5, routine, e );
			}
			/*
			//then get its value to set in the checkbox
			boolean blnListDesc = true;
			if (prop_value_str.equalsIgnoreCase("false" ) ) {
				blnListDesc = false;
			}
 			__props_listdesc_table_JCheckBox.setSelected( blnListDesc);
			*/
		}
	}

}//end update_GUI_fields_propertiesTab_table_props

/**
Fills in the components of the security tab in the GUI with the
parameters for the current RiversideDB_Export object
*/
protected void update_GUI_fields_securityTab( ) {
	String routine = __class + ".update_GUI_fields_securityTab";

	String db_user_log = null;
	db_user_log = __db_RTi_ExportProduct.getUser_login();
	if ( Message.isDebugOn ) {
		Message.printDebug( 5, routine,
		"Value for User Login is: \"" +
		db_user_log + "\"." );
	}

 	__security_tab_user_login_JTextField.setText( db_user_log );

	String db_user_pass = null;
	db_user_pass = __db_RTi_ExportProduct.getUser_PWD();
	if ( Message.isDebugOn ) {
		Message.printDebug( 5, routine,
		"Value for User Password is: \"" +
		db_user_pass + "\"." );
	}

 	__security_tab_user_passwd_JTextField.setText( db_user_pass );

	String fire_log = null;
	try {
		fire_log = __db_RTi_ExportProduct.getFirewall_user();
		if ( Message.isDebugOn ) {
			Message.printDebug( 5, routine,
			"Value for Firewall Login is: \"" +
			fire_log + "\"." );
		}
	}
	catch ( Exception e ) {
		Message.printWarning( 2, routine, e );
	}

	//For defining a New ExportProduct
	if (( fire_log == null ) || ( DMIUtil.isMissing(fire_log) ) ) {
		fire_log = DMIUtil.MISSING_STRING;
	}

 	__security_tab_firewall_login_JTextField.setText( fire_log );

	String fire_pass = null;
	try {
		fire_pass = __db_RTi_ExportProduct.getFirewall_user_PWD();
		if ( Message.isDebugOn ) {
			Message.printDebug( 5, routine,
			"Value for Firewall Password is: \"" +
			fire_pass + "\"." );
		}
	}
	catch ( Exception e ) {
		Message.printWarning( 2, routine, e );
	}

	//For defining a New ExportProduct
	if (( fire_pass == null ) || ( DMIUtil.isMissing(fire_pass) ) ) {
		fire_pass = DMIUtil.MISSING_STRING;
	}

 	__security_tab_firewall_passwd_JTextField.setText( fire_pass );
}//end update_GUI_fields_securityTab

/**
Verifies and stores all the information on the AUTOMATION tab.
The method <ul><li> fills in the <i>__gui</i> verions of the objects
in memory with the values that are currently set in the GUI</li>
<li>compares the values in the <i>__gui</i> version of the objects to the
<i>__db</i> version of the objects.  If the <i>__gui</i> versions differ
from the <i>__db</i> verions:<ul>
<li>the <i>__gui</i> versions are marked dirty (<i>.setDirty(true)</i>)</li>
<li>messages are added to the <i>__dirty_vect</i> indicating how the
<i>__gui</i> differs from the <i>__db</i> version (the <i>__db</i> version
remember, represents how the object is in the database itself) </li></ul>
</li></ul></ul>
@exception Exception thrown if error encountered
*/
public void verify_automation_tab() throws Exception {
	String routine = __class + ".verify_automation_tab";

	//if isAutomated is selected - all fields can be active,
	//if is in not selected, no fields can be active.
	//isAutomated - REQUIRED
	String gui_isAuto_str = "Y";
	String gui_everyInt_str = "Y";
	String gui_year_str = "*";
	String gui_month_str = "*";
	String gui_day_str = "*";
	String gui_hour_str = "*";
	String gui_minute_str = "15";
	String gui_second_str = "*";
	String gui_weekday_str = "*";
	String db_isAuto_str = null;
	String db_everyInt_str = null;
	String db_year_str = null;
	String db_month_str = null;
	String db_day_str = null;
	String db_hour_str = null;
	String db_minute_str = null;
	String db_second_str = null;
	String db_weekday_str = null;
	db_isAuto_str = __db_RTi_ExportProduct.getIsAutomated();
	db_everyInt_str = __db_RTi_ExportProduct.getIsInterval();
	db_year_str = __db_RTi_ExportProduct.getExport_year();
	db_month_str = __db_RTi_ExportProduct.getExport_month();
	db_day_str = __db_RTi_ExportProduct.getExport_day();
	db_hour_str = __db_RTi_ExportProduct.getExport_hour();
	db_minute_str  = __db_RTi_ExportProduct.getExport_minute();
	db_second_str = __db_RTi_ExportProduct.getExport_second();
	db_weekday_str = __db_RTi_ExportProduct.getExport_weekday();

	if ( __automation_tab_automated_JCheckBox.isSelected() ) {
		gui_isAuto_str = "Y";
		//check that that matches what was originally in DB
		if ( ! db_isAuto_str.equalsIgnoreCase( gui_isAuto_str ) ) {
			//mark as dirty
 			__gui_RTi_ExportProduct.setDirty( true );
 			__dirty_vect.addElement(
			"Change IsAutomated from \"" + db_isAuto_str +
			"\" to \"" + gui_isAuto_str + "\"");

 			__gui_RTi_ExportProduct.setIsAutomated(
			gui_isAuto_str );
		}

		//if the "At Time" checkBox is checked, then
		//check to validate all the date fields.
		//Validate all the fields (year, month, day, etc )
		if ( __automation_tab_at_time_JRadioButton.isSelected() ) {
			//store the value as "N" since
			//that is what goes into the DB
			//for the value of isInterval
			gui_everyInt_str = "N";
		}
		else {
			gui_everyInt_str = "Y";
		}
		if ( Message.isDebugOn ) {
			Message.printDebug( 5, routine,
			"At Time checkbox on Automation " +
			"tab is selected." );
		}
		//compare it to the original value in DB
		if ( ! db_everyInt_str.equalsIgnoreCase( gui_everyInt_str) ) {
			//mark as dirty
 			__gui_RTi_ExportProduct.setDirty( true );
 			__dirty_vect.addElement(
			"Change Every Interval from \"" + db_everyInt_str +
			"\" to \"" + gui_everyInt_str + "\"");

 			__gui_RTi_ExportProduct.setIsInterval( gui_everyInt_str);
		}

		//now we have to go through and check each of the other fields.
		//YEAR
		gui_year_str = (String) __automation_tab_year_JComboBox.
		getSelected();
		int ind = -999;
		ind = gui_year_str.indexOf( " -" );
		if ( ind > 0 ) {
			gui_year_str = gui_year_str.substring( 0, ind ).trim();
		}
		//compare value to what was originally in db
		if ( !db_year_str.equalsIgnoreCase( gui_year_str )){
				//set Dirty
 			__gui_RTi_ExportProduct.setDirty( true );
 			__dirty_vect.addElement(
				"Change Year from \"" + db_year_str +
				"\" to \"" + gui_year_str + "\"");

 			__gui_RTi_ExportProduct.setExport_year(
				gui_year_str);
		}

		//month
		gui_month_str = (String) __automation_tab_month_JComboBox.
		getSelected();
		ind = -999;
		ind = gui_month_str.indexOf( " -" );
		if ( ind > 0 ) {
			gui_month_str = gui_month_str.substring(0, ind ).trim();
		}

		//compare value to what was originally in db
		if ( !db_month_str.equalsIgnoreCase( gui_month_str )){
				//set Dirty
 			__gui_RTi_ExportProduct.setDirty( true );
 			__dirty_vect.addElement(
				"Change Month from \"" + db_month_str +
				"\" to \"" + gui_month_str + "\"");

 			__gui_RTi_ExportProduct.setExport_month(
				gui_month_str);
		}

		//day
		gui_day_str = (String) __automation_tab_day_JComboBox.
		getSelected();
		ind = -999;
		ind = gui_day_str.indexOf( " -" );
		if ( ind > 0 ) {
			gui_day_str = gui_day_str.substring( 0, ind ).trim();
		}
		//compare value to what was originally in db
		if ( !db_day_str.equalsIgnoreCase( gui_day_str )){
				//set Dirty
 			__gui_RTi_ExportProduct.setDirty( true );
 			__dirty_vect.addElement(
				"Change Day from \"" + db_day_str +
				"\" to \"" + gui_day_str + "\"");

 			__gui_RTi_ExportProduct.setExport_day(
				gui_day_str);
		}

		//hour
		gui_hour_str = (String) __automation_tab_hour_JComboBox.
		getSelected();
		ind = -999;
		ind = gui_hour_str.indexOf( " -" );
		if ( ind > 0 ) {
			gui_hour_str = gui_hour_str.substring( 0, ind ).trim();
		}
		//compare value to what was originally in db
		if ( !db_hour_str.equalsIgnoreCase( gui_hour_str )){
				//set Dirty
 			__gui_RTi_ExportProduct.setDirty( true );
 			__dirty_vect.addElement(
				"Change Hour from \"" + db_hour_str +
				"\" to \"" + gui_hour_str + "\"");

 			__gui_RTi_ExportProduct.setExport_hour(
				gui_hour_str);
		}

		//MINUTE
		gui_minute_str = (String) __automation_tab_minute_JComboBox.
		getSelected();
		ind = -999;
		ind = gui_minute_str.indexOf( " -" );
		if ( ind > 0 ) {
			gui_minute_str = gui_minute_str.substring(0,ind).trim();
		}
		//compare value to what was originally in db
		if ( !db_minute_str.equalsIgnoreCase( gui_minute_str )){
				//set Dirty
 			__gui_RTi_ExportProduct.setDirty( true );
 			__dirty_vect.addElement(
				"Change Minute from \"" + db_minute_str +
				"\" to \"" + gui_minute_str + "\"");

 			__gui_RTi_ExportProduct.setExport_minute(
				gui_minute_str);
		}

		//Second
		gui_second_str = (String)
 		__automation_tab_second_JComboBox.getSelected();
		ind = -999;
		ind = gui_second_str.indexOf( " -" );
		if ( ind > 0 ) {
			gui_second_str = gui_second_str.substring(0,ind).trim();
		}
		//compare value to what was originally in db
		if ( !db_second_str.equalsIgnoreCase( gui_second_str )){
				//set Dirty
 			__gui_RTi_ExportProduct.setDirty( true );
 			__dirty_vect.addElement(
				"Change Second from \"" + db_second_str +
				"\" to \"" + gui_second_str + "\"");

 			__gui_RTi_ExportProduct.setExport_second(
				gui_second_str);
		}

		//weekday
		gui_weekday_str = (String)
 		__automation_tab_weekday_JComboBox.getSelected();
		ind = -999;
		ind = gui_weekday_str.indexOf( " -" );
		if ( ind > 0 ) {
			gui_weekday_str = gui_weekday_str.substring( 0, ind ).
			trim();
		}
		//compare value to what was originally in db
		if ( !db_weekday_str.equalsIgnoreCase( gui_weekday_str )){
				//set Dirty
 			__gui_RTi_ExportProduct.setDirty( true );
 			__dirty_vect.addElement(
				"Change Weekday from \"" + db_weekday_str +
				"\" to \"" + gui_weekday_str + "\"");

 			__gui_RTi_ExportProduct.setExport_weekday(
				gui_weekday_str);
		}

	} //end isAutomated is selected
	else { //if the isAutomated checkbox is not selected, nothing
		//else is active, so don't need checked.
		//but set the isAutomated status so can write it to the db
		gui_isAuto_str = "N";
		//compare value to what was originally in db
		if ( !db_isAuto_str.equalsIgnoreCase( gui_isAuto_str )){
 		__gui_RTi_ExportProduct.setDirty( true );
 			__dirty_vect.addElement(
				"Change IsAutomated from \"" + db_isAuto_str +
				"\" to \"" + gui_isAuto_str + "\"");

 			__gui_RTi_ExportProduct.setIsAutomated(
				gui_isAuto_str);
		}
		//leave the rest of the GUI fields to be their defaults
		if ( !db_year_str.equalsIgnoreCase( gui_year_str )){
				//set Dirty
 			__gui_RTi_ExportProduct.setDirty( true );
 			__dirty_vect.addElement(
				"Change Year from \"" + db_year_str +
				"\" to \"" + gui_year_str + "\"");

 			__gui_RTi_ExportProduct.setExport_year(
				gui_year_str);
		}
		if ( !db_month_str.equalsIgnoreCase( gui_month_str )){
				//set Dirty
 			__gui_RTi_ExportProduct.setDirty( true );
 			__dirty_vect.addElement(
				"Change Month from \"" + db_month_str +
				"\" to \"" + gui_month_str + "\"");

 			__gui_RTi_ExportProduct.setExport_month(
				gui_month_str);
		}
		if ( !db_day_str.equalsIgnoreCase( gui_day_str )){
				//set Dirty
 			__gui_RTi_ExportProduct.setDirty( true );
 			__dirty_vect.addElement(
				"Change Day from \"" + db_day_str +
				"\" to \"" + gui_day_str + "\"");

 			__gui_RTi_ExportProduct.setExport_day(
				gui_day_str);
		}
		if ( !db_hour_str.equalsIgnoreCase( gui_hour_str )){
				//set Dirty
 			__gui_RTi_ExportProduct.setDirty( true );
 			__dirty_vect.addElement(
				"Change Hour from \"" + db_hour_str +
				"\" to \"" + gui_hour_str + "\"");

 			__gui_RTi_ExportProduct.setExport_hour(
				gui_hour_str);
		}
		if ( !db_minute_str.equalsIgnoreCase( gui_minute_str )){
				//set Dirty
 			__gui_RTi_ExportProduct.setDirty( true );
 			__dirty_vect.addElement(
				"Change Minute from \"" + db_minute_str +
				"\" to \"" + gui_minute_str + "\"");

 			__gui_RTi_ExportProduct.setExport_minute(
				gui_minute_str);
		}
		if ( !db_second_str.equalsIgnoreCase( gui_second_str )){
				//set Dirty
 			__gui_RTi_ExportProduct.setDirty( true );
 			__dirty_vect.addElement(
				"Change Second from \"" + db_second_str +
				"\" to \"" + gui_second_str + "\"");

 			__gui_RTi_ExportProduct.setExport_second(
				gui_second_str);
		}
		if ( !db_weekday_str.equalsIgnoreCase( gui_weekday_str )){
				//set Dirty
 			__gui_RTi_ExportProduct.setDirty( true );
 			__dirty_vect.addElement(
				"Change Weekday from \"" + db_weekday_str +
				"\" to \"" + gui_weekday_str + "\"");

 			__gui_RTi_ExportProduct.setExport_weekday(
				gui_weekday_str);
		}

	}

} //end verify_automation_tab

/**
Verifies and stores all the information on the FILES tab.
The method <ul><li> fills in the <i>__gui</i> verions of the objects
in memory with the values that are currently set in the GUI</li>
<li>compares the values in the <i>__gui</i> version of the objects to the
<i>__db</i> version of the objects.  If the <i>__gui</i> versions differ
from the <i>__db</i> verions:<ul>
<li>the <i>__gui</i> versions are marked dirty (<i>.setDirty(true)</i>)</li>
<li>messages are added to the <i>__dirty_vect</i> indicating how the
<i>__gui</i> differs from the <i>__db</i> version (the <i>__db</i> version
remember, represents how the object is in the database itself) </li></ul>
</li></ul></ul>
@exception Exception thrown if error encountered
*/
public void verify_files_tab() throws Exception {
	String routine = __class + ".verify_files_tab";

	//SOURCE Directory - NOT REQUIRED
	String gui_dest_dir = null;
	String gui_dest_file = null;
	String db_dest_dir = null;
	String db_dest_file = null;
	db_dest_dir = __db_RTi_ExportProduct.getDestination_dir();
	db_dest_file = __db_RTi_ExportProduct.getDestination_file();

	//Destination Directory
	gui_dest_dir = ( __files_tab_dest_dir_JTextField.getText()).trim();

	if ( Message.isDebugOn ) {
		Message.printDebug( 35, routine,
		"Value for File Tab: destination directory: \"" +
		gui_dest_dir + "\"." );
	}
	//compare value to what was originally in db
	if ( !db_dest_dir.equalsIgnoreCase( gui_dest_dir )){
			//set Dirty
 		__gui_RTi_ExportProduct.setDirty( true );
 		__dirty_vect.addElement(
			"Change Destination Directory from \"" + db_dest_dir +
			"\" to \"" + gui_dest_dir + "\"");

 		__gui_RTi_ExportProduct.setDestination_dir( gui_dest_dir);
	}

	//Destination File
	gui_dest_file = ( __files_tab_dest_file_JTextField.getText()).trim();
	if ( Message.isDebugOn ) {
		Message.printDebug( 35, routine,
		"Value for File Tab: destination file: \"" +
		gui_dest_file + "\"." );
	}
	//compare value to what was originally in db
	if ( !db_dest_file.equalsIgnoreCase( gui_dest_file )){
			//set Dirty
 		__gui_RTi_ExportProduct.setDirty( true );
 		__dirty_vect.addElement(
			"Change Destination File(s) from \"" + db_dest_file +
			"\" to \"" + gui_dest_file + "\"");

 		__gui_RTi_ExportProduct.setDestination_file(
			gui_dest_file);
	}

} //end verify_files_tab

/**
Verifies and stores all the information on the PROPERTIES tab.
The method <ul><li> fills in the <i>__gui</i> verions of the objects
in memory with the values that are currently set in the GUI</li>
<li>compares the values in the <i>__gui</i> version of the objects to the
<i>__db</i> version of the objects.  If the <i>__gui</i> versions differ
from the <i>__db</i> verions:<ul>
<li>the <i>__gui</i> versions are marked dirty (<i>.setDirty(true)</i>)</li>
<li>messages are added to the <i>__dirty_vect</i> indicating how the
<i>__gui</i> differs from the <i>__db</i> version (the <i>__db</i> version
remember, represents how the object is in the database itself) </li></ul>
</li></ul></ul>
@exception Exception thrown if error encountered
*/
public void verify_properties_tab() throws Exception {
	String routine = __class + ".verify_properties_tab";
	String gui_exp_order_str = null;
	String gui_exp_start_str = null;
	String gui_exp_end_str = null;
	String gui_next_date_str = null;

	long db_exp_order = -999;
	String db_exp_start_str = null;
	String db_exp_end_str = null;
	Date db_next_date = null;
	DateTime db_next_DateTime = null;
	db_exp_order = __db_RTi_ExportProduct.getExport_order();
	db_exp_start_str = __db_RTi_ExportProduct.getExport_start();
	db_exp_end_str = __db_RTi_ExportProduct.getExport_end();
	//db_retries = __db_RTi_ExportProduct.getRetries();
	//db_props_str = __db_RTi_ExportProduct.getProperties();
	db_next_date = __db_RTi_ExportProduct.getNext_export_date();
	//might be null if creating new ExportProduct and new ExportConfs
	if ( db_next_date != null ) {
		db_next_DateTime = new DateTime( db_next_date );
		db_next_DateTime.setPrecision( DateTime.PRECISION_SECOND );
	}
	else {
		db_next_DateTime = new DateTime();
	}

	//Export Order
	long gui_exp_order = -999;
	gui_exp_order_str = (String)
 	__props_tab_export_order_JComboBox.getSelected();
	int ind =-999;
	ind = gui_exp_order_str.indexOf(" -" );
	if ( ind > 0 ) {
		gui_exp_order_str = gui_exp_order_str.substring(0, ind).trim();
	}
	gui_exp_order = StringUtil.atol( gui_exp_order_str);

	//compare value to what was originally in db
	if ( db_exp_order != gui_exp_order ) {
		//set Dirty
 		__gui_RTi_ExportProduct.setDirty( true );
 		__dirty_vect.addElement(
		"Change Export Order from \"" + db_exp_order  +
		"\" to \"" + gui_exp_order  + "\"");

 		__gui_RTi_ExportProduct.setExport_order( gui_exp_order );
	}

	//export start
	if ( __props_tab_export_start_current_JCheckBox.isSelected() ) {
		gui_exp_start_str = "CURRENT";
	}
	else {
		gui_exp_start_str = (String)
		__props_tab_export_start_plusminus_JComboBox.getSelected() +
		(String) __props_tab_export_start_numb_JComboBox.
		getSelected() + (String)
		__props_tab_export_start_dayhr_JComboBox.getSelected();
	}
	if ( Message.isDebugOn ) {
		Message.printDebug( 3, routine,
		"gui_exp_start_str = \"" + gui_exp_start_str + "\" and " +
		"db_exp_start_str = \"" + db_exp_start_str + "\"" );
	}
	if ( ! db_exp_start_str.equalsIgnoreCase( gui_exp_start_str ) ) {
		//set Dirty
 		__gui_RTi_ExportProduct.setDirty( true );
 		__dirty_vect.addElement(
		"Change Export Start from \"" + db_exp_start_str  +
		"\" to \"" + gui_exp_start_str  + "\"");

 		__gui_RTi_ExportProduct.setExport_start( gui_exp_start_str );
	}

	//export end
	if ( __props_tab_export_end_current_JCheckBox.isSelected() ) {
		gui_exp_end_str = "CURRENT";
	}
	else {
		gui_exp_end_str = (String)
		__props_tab_export_end_plusminus_JComboBox.getSelected() +
		(String) __props_tab_export_end_numb_JComboBox.
		getSelected() + (String)
		__props_tab_export_end_dayhr_JComboBox.getSelected();
	}
	if ( Message.isDebugOn ) {
		Message.printDebug( 3, routine,
		"gui_exp_end_str = \"" + gui_exp_end_str + "\" and " +
		"db_exp_end_str = \"" + db_exp_end_str + "\"" );
	}
	if ( ! db_exp_end_str.equalsIgnoreCase( gui_exp_end_str ) ) {
		//set Dirty
 		__gui_RTi_ExportProduct.setDirty( true );
 		__dirty_vect.addElement(
		"Change Export End from \"" + db_exp_end_str  +
		"\" to \"" + gui_exp_end_str  + "\"");

 		__gui_RTi_ExportProduct.setExport_end( gui_exp_end_str );
	}

	//Last Export date can't be changed, so does not need checked.
	//NEXT Export Date
	gui_next_date_str = ( __props_tab_next_export_date_JTextField.
	getText()).trim();
	//Next Date in GUI can be Null, only if we are defining a
	//new ExportProduct
	DateTime gui_next_DateTime = null;
	if (( gui_next_date_str != null ) && (gui_next_date_str.length() >0 )) {
		try {
			gui_next_DateTime = DateTime.parse( gui_next_date_str );
		}
		catch (Exception e ) {
			Message.printWarning( 2, routine, e);
		}
	}
	if ( gui_next_DateTime != null ) {
		//set Precision so we can compare dates.
		gui_next_DateTime.setPrecision( DateTime.PRECISION_SECOND);
		//else compare it to the db_next_date
		//using the DateTime.equals method
		if ( ! db_next_DateTime.equals( gui_next_DateTime ) ) {
 			__gui_RTi_ExportProduct.setDirty( true );
 			__dirty_vect.addElement(
			"Change Next Date from \"" +
			db_next_DateTime.toString() +
			"\" to \"" + gui_next_DateTime.toString()  + "\"");

			//update database
 			__gui_RTi_ExportProduct.setNext_export_date(
			gui_next_DateTime.getDate() );
		}
	}
	else {
		//DateTime is Null-- must have been null originally
		//in the database since checkRequiredInput() checks this.
		//_gui_RTi_ExportProduct.setNext_export_date(
		//new Date() );
	}

	//RETRIES - NOT Editable

	//PROPERTIES FIELDS
	if ( __db_ExportProduct_type.equals( __type_comma_str ) ) {
			verify_properties_tab_comma_props();
	}
	else if (__db_ExportProduct_type.equals(__type_graph_str)
	    || __db_ExportProduct_type.equals(__type_graph_str_old)) {
			verify_properties_tab_graph_props();
	}
	else if ( __db_ExportProduct_type.equals( __type_obsreport_str ) ) {
			verify_properties_tab_obsreport_props();
	}
	else if ( __db_ExportProduct_type.equals( __type_shef_str ) ) {
			verify_properties_tab_shef_props();
	}
	else if( __db_ExportProduct_type.equals( __type_table_str ) ) {
			verify_properties_tab_table_props();
	}
	else {
		if ( __props_tab_generic_props_JTextField != null ) {
			verify_properties_tab_generic_props();
		}
	}
} //end verify_properties_tab()

/**
Verifies and stores all the information from the properties fields
on the Properties tab for ExportProduct of type COMMA_DELIMINATED.
The method <ul><li> fills in the <i>__gui</i> verions of the objects
in memory with the values that are currently set in the GUI</li>
<li>compares the values in the <i>__gui</i> version of the objects to the
<i>__db</i> version of the objects.  If the <i>__gui</i> versions differ
from the <i>__db</i> verions:<ul>
<li>the <i>__gui</i> versions are marked dirty (<i>.setDirty(true)</i>)</li>
<li>messages are added to the <i>__dirty_vect</i> indicating how the
<i>__gui</i> differs from the <i>__db</i> version (the <i>__db</i> version
remember, represents how the object is in the database itself) </li></ul>
</li></ul></ul>
@exception Exception thrown if error encountered
*/
public void verify_properties_tab_comma_props() throws Exception {
	String routine = __class + "verify_properties_tab_comma_props";
	//get all props
	String db_props_str = __gui_RTi_ExportProduct.getProperties();

	//concatenate props from gui into one long String
	String gui_props_str = "";
	String gui_dateformat_str = null;
	String gui_timestamp_str = null;
	boolean blnGUI_timestamp = false;

	//DateFormat
	gui_dateformat_str = (String) __props_dateformat_comma_JComboBox.
	getSelected();
	if ( gui_dateformat_str.equals ( DEFAULT_str ) ) {
		gui_dateformat_str = "";
	}
	else {
		//remove description
		int ind = -999;
		ind = gui_dateformat_str.indexOf( " -" );
		if ( ind > 0 ) {
			gui_dateformat_str =
			gui_dateformat_str.substring( 0, ind ).trim();
		}
		gui_dateformat_str =
 		__props_dateformat_comma_JLabel_str+ "=" +gui_dateformat_str;
	}
	gui_props_str = gui_dateformat_str;

	//TimeStamp - set to true or false
	blnGUI_timestamp = __props_timestamp_comma_JCheckBox.isSelected();
	if ( blnGUI_timestamp ) {
		gui_timestamp_str =
 		__props_timestamp_comma_JLabel_str + "=TRUE";
	}

	//concatenate all the GUI properties now
	StringBuffer b = new StringBuffer();
	if ( gui_dateformat_str !=null ) {
		b.append( gui_dateformat_str.trim() );
	}
	if ( gui_timestamp_str != null ) {
		b.append(";");
		b.append( gui_timestamp_str.trim() );
	}
	gui_props_str = b.toString();
	if ( Message.isDebugOn ) {
		Message.printDebug( 2, routine, "The original properties " +
		"from the database are: \"" + db_props_str + "\"\n" +
		"The properties currently set in from the GUI are: \"" +
		gui_props_str + "\"" );
	}


	//now compare the properties strings.
	if ( !db_props_str.equalsIgnoreCase( gui_props_str ) ){
		//set Dirty
 		__gui_RTi_ExportProduct.setDirty( true );
 		__dirty_vect.addElement(
		"Change Properties from:\n \"" + db_props_str  +
		"\"\nto:\n \"" + gui_props_str  + "\"");

 		__gui_RTi_ExportProduct.setProperties( gui_props_str );
	}
} //end verify_properties_tab_comma_props

/**
Verifies and stores all the information from the properties fields
on the Properties tab for ExportProduct of type GENERIC
The method <ul><li> fills in the <i>__gui</i> verions of the objects
in memory with the values that are currently set in the GUI</li>
<li>compares the values in the <i>__gui</i> version of the objects to the
<i>__db</i> version of the objects.  If the <i>__gui</i> versions differ
from the <i>__db</i> verions:<ul>
<li>the <i>__gui</i> versions are marked dirty (<i>.setDirty(true)</i>)</li>
<li>messages are added to the <i>__dirty_vect</i> indicating how the
<i>__gui</i> differs from the <i>__db</i> version (the <i>__db</i> version
remember, represents how the object is in the database itself) </li></ul>
</li></ul></ul>
@exception Exception thrown if error encountered
*/
public void verify_properties_tab_generic_props() throws Exception {

	//this just has 1 JTextField with properties seperated
	//by a ";" just like in database
	String db_props = null;
	String gui_props = null;
	db_props = __db_RTi_ExportProduct.getProperties();
	gui_props= __props_tab_generic_props_JTextField.getText().trim();
	if ( !db_props.equalsIgnoreCase( gui_props ) ) {
		//set Dirty
 		__gui_RTi_ExportProduct.setDirty( true );
 		__dirty_vect.addElement(
		"Change Properties from:\n \"" + db_props +
		"\"\n to:\n \"" + gui_props + "\"");

 		__gui_RTi_ExportProduct.setProperties( gui_props );
	}
}//end verify_properties_tab_generic_props


/**
Verifies and stores all the information from the properties fields
on the Properties tab for ExportProduct of type GRAPH_JPEG.
The method <ul><li> fills in the <i>__gui</i> verions of the objects
in memory with the values that are currently set in the GUI</li>
<li>compares the values in the <i>__gui</i> version of the objects to the
<i>__db</i> version of the objects.  If the <i>__gui</i> versions differ
from the <i>__db</i> verions:<ul>
<li>the <i>__gui</i> versions are marked dirty (<i>.setDirty(true)</i>)</li>
<li>messages are added to the <i>__dirty_vect</i> indicating how the
<i>__gui</i> differs from the <i>__db</i> version (the <i>__db</i> version
remember, represents how the object is in the database itself) </li></ul>
</li></ul></ul>
@exception Exception thrown if error encountered
*/
public void verify_properties_tab_graph_props() throws Exception {
	String routine = __class + "verify_properties_tab_graph_props";

	//get all props
	String gui_props_str = "";
	String db_props_str = __gui_RTi_ExportProduct.getProperties();
	if ( Message.isDebugOn ) {
		Message.printDebug( 3, routine, "The original properties: " +
		db_props_str + "\"" );
	}

	String gui_title_str = "";
	boolean gui_blnCreationTime = true;
	boolean gui_blnTimeStamp = false;
	String gui_creationtime_str = "";
	String gui_timestamp_str = "";
	String gui_windowdim_w_str = "";
	String gui_windowdim_h_str = "";
	String gui_windowdim_str = "";
	String gui_dateformat_str = null;
	String gui_annline_1_str = "";
	String gui_annline_2_str = "";
	String gui_annline_str = "";
	String gui_anntext_1_str = "";
	String gui_anntext_2_str = "";
	String gui_anntext_str = "";
	String gui_range_lo_str = "";
	String gui_range_hi_str = "";
	String gui_range_str = "";

	Vector exception_vect = new Vector();

	// title
	gui_title_str = __props_title_graph_JTextField.getText();
	if ( gui_title_str.length() <= 0 ) {
		gui_title_str = null;
	}
	else {
		gui_title_str = __props_title_graph_JLabel_str + "=" +
		gui_title_str;
	}
	if ( Message.isDebugOn ) {
		Message.printDebug( 2, routine, "The title set in the GUI: \"" +
		gui_title_str + "\"" );
	}

	String db_TSPName  = null;
	int db_TSPNum = __db_RTi_ExportProduct.getTSProduct_num();
	
	// Using the Product number get the product name.
	try {
		Vector tsProduct_vect = __dmi.readTSProductList();
		if ( tsProduct_vect != null ) {
			int nP = tsProduct_vect.size();
			for ( int n=0; n<nP; n++) {
				RiversideDB_TSProduct rdb_tsp =
				   (RiversideDB_TSProduct)
					tsProduct_vect.elementAt(n);
				if( rdb_tsp.getTSProduct_num() == db_TSPNum ) {
					db_TSPName = rdb_tsp.getName();
					break;
				}	
			}
		}
	} catch ( Exception e ) {   
		Message.printWarning (1, routine, "Error reading TSProduct Table");
	}	

	// compare
	String gui_TSPName = (String) __props_tsProduct_graph_JComboBox.getSelected();
	if ( !db_TSPName.equalsIgnoreCase( gui_TSPName ) ) {
 		__gui_RTi_ExportProduct.setDirty ( true );
 		__dirty_vect.addElement(
		"Change Export Product TSProduct  "+
		"from \"" + db_TSPName +"\" to \"" +gui_TSPName+"\"");

		// set in memory
		try {
			Vector tsProduct_vect = __dmi.readTSProductList();
			if ( tsProduct_vect != null ) {
				int nP = tsProduct_vect.size();
				for ( int n=0; n<nP; n++) {
					RiversideDB_TSProduct rdb_tsp =
					   (RiversideDB_TSProduct)
						tsProduct_vect.elementAt(n);
					if( rdb_tsp.getName().equalsIgnoreCase(
							gui_TSPName ) ) {
						Message.printWarning (1,routine,"yes");		
				 		__gui_RTi_ExportProduct.setTSProduct_num(
							rdb_tsp.getTSProduct_num() );	
						break;
					}	
				}
			}
		} catch ( Exception e ) {   
			Message.printWarning (1, routine, "Error reading TSProduct Table");
		}
	}

	//creation time T/F
	gui_blnCreationTime = __props_creationtime_graph_JCheckBox.isSelected();
	if ( gui_blnCreationTime ) {
		gui_creationtime_str =
 		__props_creationtime_graph_JLabel_str + "=TRUE";
	}
	else {
 		gui_creationtime_str =
		__props_creationtime_graph_JLabel_str + "=FALSE";
	}
	if ( Message.isDebugOn ) {
		Message.printDebug( 2, routine, "The creation time value " +
		"set in the GUI: \"" + gui_creationtime_str + "\"" );
	}

	//timestamp T/F
	gui_blnTimeStamp = __props_timestamp_graph_JCheckBox.isSelected();
	if ( gui_blnTimeStamp ) {
		gui_timestamp_str =
 		__props_timestamp_graph_JLabel_str + "=TRUE";
	}
	else {
 		gui_timestamp_str = null;
		//__props_timestamp_graph_JLabel_str + "=FALSE";
	}
	if ( Message.isDebugOn ) {
		Message.printDebug( 2, routine, "The timestamp value " +
		"set in the GUI: \"" + gui_timestamp_str + "\"" );
	}

	//window dimensions
	gui_windowdim_w_str = (__props_windowdim_w_graph_JTextField.
	getText()).trim();
	if ( gui_windowdim_w_str.length() <= 0 ) {
		//that's OK, means won't have width or height
		gui_windowdim_str = null;
	}
	else if  ( ! StringUtil.isInteger ( gui_windowdim_w_str ) ) {
		exception_vect.addElement
		( "Must have integer for Window Dimension width.\n" );
	}
	else { //try to get the second field (height)
		gui_windowdim_h_str = (__props_windowdim_h_graph_JTextField.
		getText()).trim();
		if (( gui_windowdim_h_str.length() <= 0 ) ||
		(! StringUtil.isInteger ( gui_windowdim_h_str ) ) ) {
			exception_vect.addElement
			( "Must have integer for Window Dimension height.\n" );
		}
		else {
			gui_windowdim_str = __props_windowdim_graph_JLabel_str +
			"=" + gui_windowdim_w_str + "," + gui_windowdim_h_str;
		}
	}
	if ( Message.isDebugOn ) {
		Message.printDebug( 2, routine, "The window dimensions set " +
		" in the GUI: \"" + gui_windowdim_str + "\"" );
	}

	// Date format
	gui_dateformat_str = (String) __props_dateformat_graph_JComboBox.getSelected();

	//remove description ( anything including and after the " -" )
	//remove description
	int ind = -999;
	ind = gui_dateformat_str.indexOf( " -" );
	if ( ind > 0 ) {
		gui_dateformat_str =
		gui_dateformat_str.substring( 0, ind ).trim();
	}

	if ( ! gui_dateformat_str.equals( DEFAULT_str ) ) {
		gui_dateformat_str = __props_dateformat_graph_JLabel_str + "=" +
		gui_dateformat_str;
	}
	else {
		gui_dateformat_str = null;
	}
	if ( Message.isDebugOn ) {
		Message.printDebug( 2, routine, "The date format set " +
		"in the GUI: \"" + gui_dateformat_str + "\"" );
	}

	//annotation lines
	gui_annline_1_str = (__props_annotationline_1_graph_JTextField.getText()).trim();
	gui_annline_2_str = (__props_annotationline_2_graph_JTextField.getText()).trim();
	boolean skip1= false;
	boolean skip2= false;
	if ( gui_annline_1_str.length() <= 0 ) {
		skip1 = true;
	}
	if ( gui_annline_2_str.length() <= 0 ) {
		skip2 = true;
	}
	if (( skip1 == false ) && ( skip2 == false ) ) {
		//check that values are longs
		if (( ! StringUtil.isDouble ( gui_annline_1_str ) ) ||
		 ( ! StringUtil.isDouble ( gui_annline_2_str ) ) ) {
			exception_vect.addElement
			( "Must have a number for Reference Line 1 and 2 or no values at all (neither field is required).\n" );
		}
		else { //get their values
			gui_annline_str = __props_annotationline_graph_JLabel_str +
			"=" + gui_annline_1_str + "," + gui_annline_2_str;
		}
	}
	else if (( skip1 == true ) && ( skip2 == true )) {
		gui_annline_str = null;
	}
	else if ( skip1 == true ) {
		//then value 2 is ok, so use it
		gui_annline_str = __props_annotationline_graph_JLabel_str +
		"=" + gui_annline_2_str;
	}
	else if ( skip2 == true ) {
		//then value 1 is ok, so use it
		gui_annline_str = __props_annotationline_graph_JLabel_str +
		"=" + gui_annline_1_str;
	}
	if ( Message.isDebugOn ) {
		Message.printDebug( 2, routine, "The reference lines " +
		"set in the GUI: \"" + gui_annline_str + "\"" );
	}

	//annotation text
	gui_anntext_1_str = (__props_annotationtext_1_graph_JTextField.getText()).trim();
	gui_anntext_2_str = (__props_annotationtext_2_graph_JTextField.getText()).trim();
	skip1= false;
	skip2= false;
	if ( gui_anntext_1_str.length() <= 0 ) {
		skip1 = true;
	}
	if ( gui_anntext_2_str.length() <= 0 ) {
		skip2 = true;
	}
	if (( skip1 == false ) && ( skip2 == false ) ) {
		//check that values are longs
		if (( ! StringUtil.isDouble ( gui_anntext_1_str ) ) ||
		 ( ! StringUtil.isDouble ( gui_anntext_2_str ) ) ) {
			exception_vect.addElement
			( "Must have a number for Reference Line 1 and 2 or no values at all (neither field is required).\n" );
		}
		else { //get their values
			gui_anntext_str = __props_annotationtext_graph_JLabel_str +
			"=" + gui_anntext_1_str + "," + gui_anntext_2_str;
		}
	}
	else if (( skip1 == true ) && ( skip2 == true )) {
		gui_anntext_str = null;
	}
	else if ( skip1 == true ) {
		//then value 2 is ok, so use it
		gui_anntext_str = __props_annotationtext_graph_JLabel_str +
		"=" + gui_anntext_2_str;
	}
	else if ( skip2 == true ) {
		//then value 1 is ok, so use it
		gui_anntext_str = __props_annotationtext_graph_JLabel_str +
		"=" + gui_anntext_1_str;
	}
	if ( Message.isDebugOn ) {
		Message.printDebug( 2, routine, "The reference lines " +
		"set in the GUI: \"" + gui_anntext_str + "\"" );
	}
	//range
	gui_range_lo_str = (__props_range_lo_graph_JTextField.getText()).trim();
	gui_range_hi_str = (__props_range_hi_graph_JTextField.getText()).trim();
	if ( gui_range_lo_str.length() <= 0 ) {
		//that's OK
		gui_range_str = null;
	}
	else if  ( ! StringUtil.isDouble ( gui_range_lo_str ) ) {
		exception_vect.addElement
		( "Must have a number for the lower bound of the Range field.\n" );
	}
	else {
		gui_range_hi_str =
		(__props_range_hi_graph_JTextField.getText()).trim();
		if ( ( gui_range_hi_str.length() <= 0 ) ||
		( ! StringUtil.isDouble ( gui_range_hi_str ) ) ) {
			exception_vect.addElement
			( "Must have a number for the upper bound of the Range field.\n" );
		}
		else {
			gui_range_str = __props_range_graph_JLabel_str +
			"=" + gui_range_lo_str + "," + gui_range_hi_str;
		}
	}
	if ( Message.isDebugOn ) {
		Message.printDebug( 2, routine, "The range set in the GUI: \"" +
		gui_range_str + "\"" );
	}

	//now see if we have items in the exeception vector
	if ( exception_vect.size() > 0 ) {
		StringBuffer b = new StringBuffer();
		int num_errs = exception_vect.size();
		b.append( "Errors verifying the properties tab " +
		"of the Export Product.\n" );
		for ( int i=0; i<num_errs; i++ ) {
			b.append( (String) exception_vect.elementAt(i) );
		}
		if ( b.length() >0 ) {
			Message.printWarning( 1, routine, b.toString(),
			this );
			throw new Exception ( b.toString() );
		}
		exception_vect = null;
	}

	// concatenate all the GUI properties now
	StringBuffer b = new StringBuffer();
	if ( gui_title_str !=null ) {
		b.append( gui_title_str.trim() );
		b.append(";");
	}
	
	b.append( gui_creationtime_str.trim() );
	b.append(";");
	if ( gui_timestamp_str != null ) {
		b.append( gui_timestamp_str.trim() );
		b.append(";");
	}
	if ( gui_windowdim_str !=null ) {
		b.append( gui_windowdim_str.trim() );
		b.append(";");
	}
	if ( gui_dateformat_str !=null ) {
		b.append( gui_dateformat_str.trim() );
		b.append(";");
	}
	if ( gui_annline_str !=null ) {
		b.append( gui_annline_str.trim() );
		b.append(";");
	}
	if ( gui_anntext_str !=null ) {
		b.append( gui_anntext_str.trim() );
		b.append(";");
	}
	if ( gui_range_str !=null ) {
		b.append( gui_range_str.trim() );
	}

	gui_props_str = b.toString();
	if ( Message.isDebugOn ) {
		Message.printDebug( 2, routine, "The original properties " +
		"from the database are: \"" + db_props_str + "\"\n" +
		"The properties currently set in from the GUI are: \"" +
		gui_props_str + "\"" );
	}

	//compare GUI version to DB version
	if ( !db_props_str.equalsIgnoreCase( gui_props_str ) ) {
		//set Dirty
 		__gui_RTi_ExportProduct.setDirty( true );
 		__dirty_vect.addElement(
		"Change Properties from:\n \"" + db_props_str  +
		"\"\nto:\n \"" + gui_props_str  + "\"");

 		__gui_RTi_ExportProduct.setProperties( gui_props_str );
	}
} //end verify_properties_tab_graph_props


/**
Verifies and stores all the information from the properties fields
on the Properties tab for ExportProduct of type LAST_OBS_REPORT.
The method <ul><li> fills in the <i>__gui</i> verions of the objects
in memory with the values that are currently set in the GUI</li>
<li>compares the values in the <i>__gui</i> version of the objects to the
<i>__db</i> version of the objects.  If the <i>__gui</i> versions differ
from the <i>__db</i> verions:<ul>
<li>the <i>__gui</i> versions are marked dirty (<i>.setDirty(true)</i>)</li>
<li>messages are added to the <i>__dirty_vect</i> indicating how the
<i>__gui</i> differs from the <i>__db</i> version (the <i>__db</i> version
remember, represents how the object is in the database itself) </li></ul>
</li></ul></ul>
@exception Exception thrown if error encountered
*/
public void verify_properties_tab_obsreport_props() throws Exception {
	String routine = __class + "verify_properties_tab_obsreport_props";

	//get all props
	String db_props_str = __gui_RTi_ExportProduct.getProperties();
	String gui_props_str = "";

	boolean blnGUI_timestamp = false;
	String gui_timestamp_str = null;
	String gui_title_str = null;
	String gui_dateformat_str = null;
	String gui_format_str = null;
	String gui_deliminiter_str = null;

	//TITLE
	gui_title_str = __props_title_obsreport_JTextField.getText().trim();
	if ( ( gui_title_str != null ) && ( gui_title_str.length() > 0 ) ) {
		gui_title_str = __props_title_obsreport_JLabel_str + "=" +
		gui_title_str.toUpperCase();
	}

	//Timestamp
	blnGUI_timestamp = __props_timestamp_obsreport_JCheckBox.isSelected();
	if ( blnGUI_timestamp ) {
		gui_timestamp_str =
 		__props_timestamp_obsreport_JLabel_str + "=TRUE";
	}

	//date_format
	gui_dateformat_str = (String) __props_dateformat_obsreport_JComboBox.
	getSelected();

	//remove description ( anything including and after the " -" )
	int ind = -999;
	ind = gui_dateformat_str.indexOf( " -" );
	if ( ind > 0 ) {
		gui_dateformat_str =
		gui_dateformat_str.substring( 0, ind ).trim();
	}

	if ( ! gui_dateformat_str.equals( DEFAULT_str ) ) {
		gui_dateformat_str = __props_dateformat_obsreport_JLabel_str +
		"=" + gui_dateformat_str;
	}
	else {
		gui_dateformat_str = null;
	}
	if ( Message.isDebugOn ) {
		Message.printDebug( 2, routine, "The date format set " +
		"in the GUI: \"" + gui_dateformat_str + "\"" );
	}

	//Format
	gui_format_str = (String) __props_format_obsreport_JComboBox.
	getSelected();

	//remove description ( anything including and after the " -" )
	ind = -999;
	ind = gui_format_str.indexOf( " -" );
	boolean bolCheckDel = false;
	if ( ind > 0 ) {
		gui_format_str =
		gui_format_str.substring( 0, ind ).trim();
		if ( gui_format_str.startsWith("TXT") ) {
			bolCheckDel = true;
		}
	}
	gui_format_str = __props_format_obsreport_JLabel_str + "=" +
	gui_format_str;

	//DELIMINITER
	if ( bolCheckDel ) {
		gui_deliminiter_str = __props_deliminiter_obsreport_JTextField.
		getText().trim();
		gui_deliminiter_str =__props_deliminiter_obsreport_JLabel_str +
		"=" + gui_deliminiter_str;
	}


	StringBuffer b = new StringBuffer();
	if ( gui_timestamp_str !=null ) {
		b.append( gui_timestamp_str );
		b.append(";");
	}
	if ( gui_title_str !=null ) {
		b.append( gui_title_str );
		b.append(";");
	}
	if ( gui_dateformat_str !=null ) {
		b.append( gui_dateformat_str );
		b.append(";");
	}
	if ( gui_format_str !=null ) {
		b.append( gui_format_str );
		b.append(";");
	}
	if ( gui_deliminiter_str !=null ) {
		b.append( gui_deliminiter_str );
	}


	//now compare the properties strings.
	gui_props_str = b.toString();
	if ( !db_props_str.equalsIgnoreCase( gui_props_str ) ){
		//set Dirty
 		__gui_RTi_ExportProduct.setDirty( true );
 		__dirty_vect.addElement(
		"Change Properties from:\n \"" + db_props_str  +
		"\"\nto:\n \"" + gui_props_str  + "\"");

 		__gui_RTi_ExportProduct.setProperties( gui_props_str );
	}

} //end verify_properties_tab_obsreport_props

/**
Verifies and stores all the information from the properties fields
on the Properties tab for ExportProduct of type SHEF.
The method <ul><li> fills in the <i>__gui</i> verions of the objects
in memory with the values that are currently set in the GUI</li>
<li>compares the values in the <i>__gui</i> version of the objects to the
<i>__db</i> version of the objects.  If the <i>__gui</i> versions differ
from the <i>__db</i> verions:<ul>
<li>the <i>__gui</i> versions are marked dirty (<i>.setDirty(true)</i>)</li>
<li>messages are added to the <i>__dirty_vect</i> indicating how the
<i>__gui</i> differs from the <i>__db</i> version (the <i>__db</i> version
remember, represents how the object is in the database itself) </li></ul>
</li></ul></ul>
@exception Exception thrown if error encountered
*/
public void verify_properties_tab_shef_props() throws Exception {

	//get all props
	String db_props_str = __gui_RTi_ExportProduct.getProperties();

	//SHEF properties: TIMESTAMP, USEHOUR24, APPEND
	//concatenate props from gui into one long String
	String gui_props_str = "";
	boolean blnGUI_timestamp = false;
	boolean blnGUI_usehour = true;
	boolean blnGUI_append = true;
	String gui_timestamp_str = null;
	String gui_usehour_str = null;
	String gui_append_str = null;
	String gui_dateformat_str = null;

	//Timestamp
	blnGUI_timestamp = __props_timestamp_shef_JCheckBox.isSelected();
	if ( blnGUI_timestamp ) {
		gui_timestamp_str =
 		__props_timestamp_shef_JLabel_str + "=TRUE";
	}

	//use 24 hour
	blnGUI_usehour = __props_usehour_shef_JCheckBox.isSelected();
	if ( blnGUI_usehour ) {
		gui_usehour_str = __props_usehour_shef_JLabel_str + "=TRUE";
	}

	//append
	blnGUI_append = __props_append_shef_JCheckBox.isSelected();
	if ( blnGUI_append ) {
		gui_append_str = __props_append_shef_JLabel_str + "=TRUE";
	}
	else {
		gui_append_str = __props_append_shef_JLabel_str + "=FALSE";
	}
	//DATEFORMAT
	gui_dateformat_str = (String) __props_dateformat_shef_JComboBox.
	getSelected();
	if ( gui_dateformat_str.equals ( DEFAULT_str ) ) {
		gui_dateformat_str = null;
	}
	else {
		//remove description
		int ind = -999;
		ind = gui_dateformat_str.indexOf( " -" );
		if ( ind > 0 ) {
			gui_dateformat_str =
			gui_dateformat_str.substring( 0, ind ).trim();
		}
		gui_dateformat_str =
 		__props_dateformat_shef_JLabel_str+ "=" +gui_dateformat_str;
	}

	StringBuffer b = new StringBuffer();
	if ( gui_timestamp_str !=null ) {
		b.append( gui_timestamp_str );
		b.append(";");
	}
	if ( gui_usehour_str !=null ) {
		b.append( gui_usehour_str );
		b.append(";");
	}
	if ( gui_append_str !=null ) {
		b.append( gui_append_str );
		b.append(";");
	}
	if ( gui_dateformat_str !=null ) {
		b.append( gui_dateformat_str );
		b.append(";");
	}

	//now compare the properties strings.
	gui_props_str = b.toString();

	if ( !db_props_str.equalsIgnoreCase( gui_props_str ) ){
		//set Dirty
 		__gui_RTi_ExportProduct.setDirty( true );
 		__dirty_vect.addElement(
		"Change Properties from:\n \"" + db_props_str  +
		"\"\nto:\n \"" + gui_props_str  + "\"");

 		__gui_RTi_ExportProduct.setProperties( gui_props_str );
	}
} //end verify_properties_tab_shef_props

/**
Verifies and stores all the information from the properties fields
on the Properties tab for ExportProduct of type TABLE_REPORT.
The method <ul><li> fills in the <i>__gui</i> verions of the objects
in memory with the values that are currently set in the GUI</li>
<li>compares the values in the <i>__gui</i> version of the objects to the
<i>__db</i> version of the objects.  If the <i>__gui</i> versions differ
from the <i>__db</i> verions:<ul>
<li>the <i>__gui</i> versions are marked dirty (<i>.setDirty(true)</i>)</li>
<li>messages are added to the <i>__dirty_vect</i> indicating how the
<i>__gui</i> differs from the <i>__db</i> version (the <i>__db</i> version
remember, represents how the object is in the database itself) </li></ul>
</li></ul></ul>
@exception Exception thrown if error encountered
*/
public void verify_properties_tab_table_props() throws Exception {

	//get all props
	String db_props_str = __gui_RTi_ExportProduct.getProperties();

	//TABLE properties: TIMESTAMP, hideMISSING, DATE_FORMAT, LISTING_ORDER
	//concatenate props from gui into one long String
	String gui_props_str = "";
	boolean blnGUI_timestamp = false;
	boolean blnGUI_hidemissing = true;
	String gui_timestamp_str = null;
	String gui_hidemissing_str = null;
	String gui_dateformat_str = null;
	String gui_listorder_str = null;

	//Timestamp
	blnGUI_timestamp = __props_timestamp_table_JCheckBox.isSelected();
	if ( blnGUI_timestamp ) {
		gui_timestamp_str =
 		__props_timestamp_table_JLabel_str + "=TRUE";
	}

	//hideMISSING
	blnGUI_hidemissing = __props_hidemissing_table_JCheckBox.isSelected();
	if ( blnGUI_hidemissing ) {
		gui_hidemissing_str =
 		__props_hidemissing_table_JLabel_str + "=TRUE";
	}
	/*
	//default for showmissing is to be true
	if ( !blnGUI_showmissing ) {
		gui_showMissing_string =
 		__props_showmissing_table_JLabel_str + "=FALSE";
	}
	//else { //gui_showMissing_string = null }
	*/

	//DATEFORMAT
	gui_dateformat_str = (String) __props_dateformat_table_JComboBox.
	getSelected();
	if ( gui_dateformat_str.equals ( DEFAULT_str ) ) {
		gui_dateformat_str = null;
	}
	else {
		//remove description
		int ind = -999;
		ind = gui_dateformat_str.indexOf( " -" );
		if ( ind > 0 ) {
			gui_dateformat_str =
			gui_dateformat_str.substring( 0, ind ).trim();
		}
		gui_dateformat_str =
 		__props_dateformat_table_JLabel_str+ "=" +gui_dateformat_str;
	}

	/*
	//ListDescending JCheckBox
	blnGUI_listdesc =  __props_listdesc_table_JCheckBox.isSelected();
	if ( blnGUI_listdesc ) {
		gui_listdesc_str =
 		__props_listdesc_table_JLabel_str + "=TRUE";
	}
	*/
	//LISTING_ORDER
	gui_listorder_str = (String) __props_listorder_table_JComboBox.
	getSelected();
	//remove description
	int ind = -999;
	ind = gui_listorder_str.indexOf( " -" );
	if ( ind > 0 ) {
		gui_listorder_str =
		gui_listorder_str.substring( 0, ind ).trim();
	}
	gui_listorder_str =
	__props_listorder_table_JLabel_str+ "=" +gui_listorder_str;
	/*
	if ( gui_listorder_str.equalsIgnoreCase("DATE_DESCENDING" ) ) {
		gui_listorder_str =
 		__props_listorder_table_JLabel_str+ "=" +gui_listorder_str;
	}
	else {
		gui_listorder_str =
 		__props_listorder_table_JLabel_str+ "=" +gui_listorder_str;
	}
	*/

	//}

	StringBuffer b = new StringBuffer();
	if ( gui_dateformat_str !=null ) {
		b.append( gui_dateformat_str );
		b.append(";");
	}
	if ( gui_timestamp_str !=null ) {
		b.append( gui_timestamp_str );
		b.append(";");
	}
	if ( gui_hidemissing_str !=null ) {
		b.append( gui_hidemissing_str );
		b.append(";");
	}
	if ( gui_listorder_str != null ) {
		b.append( gui_listorder_str );
		b.append(";");
	}
	//now compare the properties strings.
	gui_props_str = b.toString();

	if ( !db_props_str.equalsIgnoreCase( gui_props_str ) ){
		//set Dirty
 		__gui_RTi_ExportProduct.setDirty( true );
 		__dirty_vect.addElement(
		"Change Properties from:\n \"" + db_props_str  +
		"\"\nto:\n \"" + gui_props_str  + "\"");

 		__gui_RTi_ExportProduct.setProperties( gui_props_str );
	}
} //end verify_properties_tab_table_props

/**
Verifies and stores all the information on the SECURITY tab.
The method <ul><li> fills in the <i>__gui</i> verions of the objects
in memory with the values that are currently set in the GUI</li>
<li>compares the values in the <i>__gui</i> version of the objects to the
<i>__db</i> version of the objects.  If the <i>__gui</i> versions differ
from the <i>__db</i> verions:<ul>
<li>the <i>__gui</i> versions are marked dirty (<i>.setDirty(true)</i>)</li>
<li>messages are added to the <i>__dirty_vect</i> indicating how the
<i>__gui</i> differs from the <i>__db</i> version (the <i>__db</i> version
remember, represents how the object is in the database itself) </li></ul>
</li></ul></ul>
@exception Exception thrown if error encountered
*/
public void verify_security_tab() throws Exception {

	//check all the fields in the Files tab
	String db_user_login_str = null;
	String db_user_passwd_str = null;
	String db_firewall_login_str = null;
	String db_firewall_passwd_str = null;
	db_user_login_str = __db_RTi_ExportProduct.getUser_login();
	db_user_passwd_str = __db_RTi_ExportProduct.getUser_PWD();
	db_firewall_login_str = __db_RTi_ExportProduct.getFirewall_user();
	db_firewall_passwd_str = __db_RTi_ExportProduct.getFirewall_user_PWD();

	//user login
	String gui_user_login_str = null;
	gui_user_login_str =
	( __security_tab_user_login_JTextField.getText()).trim();
	//compare value to what was originally in db
	if ( !db_user_login_str.equalsIgnoreCase( gui_user_login_str )){
		//set Dirty
 		__gui_RTi_ExportProduct.setDirty( true );
 		__dirty_vect.addElement(
		"Change User Login from \"" + db_user_login_str  +
		"\" to \"" + gui_user_login_str  + "\"");

 		__gui_RTi_ExportProduct.setProperties( gui_user_login_str );
	}

	//user password
	String gui_user_passwd_str = null;
	gui_user_passwd_str =
	( __security_tab_user_passwd_JTextField.getText()).trim();

	//compare value to what was originally in db
	if ( !db_user_passwd_str.equalsIgnoreCase( gui_user_passwd_str )){
		//set Dirty
 		__gui_RTi_ExportProduct.setDirty( true );
 		__dirty_vect.addElement(
		"Change User Password from \"" + db_user_passwd_str  +
		"\" to \"" + gui_user_passwd_str  + "\"");

 		__gui_RTi_ExportProduct.setProperties( gui_user_passwd_str );
	}

	//firewall login
	String gui_firewall_login_str = null;
	gui_firewall_login_str =
	( __security_tab_firewall_login_JTextField.getText()).trim();

	//compare value to what was originally in db
	if ( !db_firewall_login_str.equalsIgnoreCase( gui_firewall_login_str )){
		//set Dirty
 		__gui_RTi_ExportProduct.setDirty( true );
 		__dirty_vect.addElement(
		"Change Firewall Login from \"" + db_firewall_login_str  +
		"\" to \"" + gui_firewall_login_str  + "\"");

 		__gui_RTi_ExportProduct.setProperties( gui_firewall_login_str );
	}

	//firewall passwd
	String gui_firewall_passwd_str = null;
	gui_firewall_passwd_str =
	( __security_tab_firewall_passwd_JTextField.getText()).trim();

	//compare value to what was originally in db
	if ( !db_firewall_passwd_str.equalsIgnoreCase(gui_firewall_passwd_str)){
		//set Dirty
 		__gui_RTi_ExportProduct.setDirty( true );
 		__dirty_vect.addElement(
		"Change Firewall Password from \"" + db_firewall_passwd_str +
		"\" to \"" + gui_firewall_passwd_str  + "\"");

 		__gui_RTi_ExportProduct.setProperties( gui_firewall_passwd_str );
	}


} //end verify_security_tab

/**
Method to verify information on the Time Series selected in the
JWorksheet of Time Series for Export (right list).
The method <ul><li> fills in the <i>__gui</i> verions of the ExportConf objects
in memory with the values that are currently set in the GUI</li>
<li>compares the values in the <i>__gui</i> version of the objects to the
<i>__db</i> version of the objects.  If the <i>__gui</i> versions differ
from the <i>__db</i> verions:<ul>
<li>the <i>__gui</i> versions are marked dirty (<i>.setDirty(true)</i>)</li>
<li>messages are added to the <i>__dirty_vect</i> indicating how the
<i>__gui</i> differs from the <i>__db</i> version (the <i>__db</i> version
remember, represents how the object is in the database itself) </li></ul>
</li></ul></ul>
@exception Exception thrown if error encountered
*/
public void verify_timeseries_tab( ) throws Exception {
	verify_timeseries_tab( true );
}

/**
Method to verify information on the Time Series selected in the
JWorksheet of Time Series for Export (right list).
The method <ul><li> fills in the <i>__gui</i> verions of the ExportConf objects
in memory with the values that are currently set in the GUI</li>
<li>compares the values in the <i>__gui</i> version of the objects to the
<i>__db</i> version of the objects.  If the <i>__gui</i> versions differ
from the <i>__db</i> verions:<ul>
<li>the <i>__gui</i> versions are marked dirty (<i>.setDirty(true)</i>)</li>
<li>messages are added to the <i>__dirty_vect</i> indicating how the
<i>__gui</i> differs from the <i>__db</i> version (the <i>__db</i> version
remember, represents how the object is in the database itself) </li></ul>
</li></ul></ul>
@param blnWarningOn True if the warning messages about changes
to the database version of the ExportConf object and the version of
the object in the GUI should be included.
@exception Exception thrown if error encountered
*/
public void verify_timeseries_tab( boolean blnWarningOn ) throws Exception {
	String routine = __class + ".verify_timeseries_tab";

	//all data is stored in the __timeseries_tab_JWorksheet and
	//is of type: ExportConf
	StringBuffer db_buffer = new StringBuffer();
	StringBuffer gui_buffer = new StringBuffer();

	//get list of TSIdents for the ExportConf objects originally
	//associated with this ExportProduct.
	int orig_num = __gui_RTi_ExportConf_vect.size();

	RiversideDB_ExportConf ec = null;
	if ( orig_num > 0 ) {
		db_buffer.append( "ExportConf objects originally " +
		"associated with this ExportProduct: \n" );
	}
	for ( int i=0; i<orig_num; i++ ) {
		ec = (RiversideDB_ExportConf) __gui_RTi_ExportConf_vect.
		elementAt(i);
		if ( ec == null ) {
			continue;
		}
		long mt_num = -999;
		mt_num = ec.getMeasType_num();
		ec = null;
		//find MeasType with matching MeasType_num
		String tsid_str = getTSIDForMeasType_num( mt_num );
		db_buffer.append( tsid_str + "\n");
		ec = null;
	}

	//read in all data currently in worksheet.
	Vector table_vect = null;
	table_vect = __timeseries_tab_selTS_JWorksheet.getAllData();

	//compare original number of ExportConf objects
	//to current number of ExportConf objects in worksheet
	int rows = -999;
	rows = table_vect.size();
	if ( Message.isDebugOn ) {
		Message.printDebug( 3, routine, "Number of ExportConf " +
		"objects currently in the worksheet: " + rows +
		" and in the database, there are: " + orig_num +
		" ExportConf objects." );
	}

	if ( rows > 0 ) {
		gui_buffer.append( "ExportConf objects currently " +
		"associated with this ExportProduct: \n" );
	}

	if ( rows != orig_num ) {
		if ( Message.isDebugOn ) {
			Message.printDebug( 3, routine,
			"Since number of rows in the current worksheet (" +
			rows + ") does not match the number of ExportConf " +
			"objects ("+ orig_num + ") originally associated " +
			"with this ExportProduct, we know that the " +
			"ExportConf objects have changed." );
		}
		//clear out the GUI version since we are updating it now.
 		__gui_RTi_ExportConf_vect.clear();

		//we know right away that the Exportconf objects are
		//dirty (when we update ExportConf objects, we delete all the
		//current Ex objects from the DB and then write the new ones
		//back. So, just by knowing that there are no longer the
		//same number of ExportConf objects as there originally
		//were, we know that we need to write to the database.

		ec = null;
		for ( int i=0; i<rows; i++ ) {
			ec = (RiversideDB_ExportConf)
			table_vect.elementAt(i);
			if ( ec == null ) {
				continue;
			}
			ec.setDirty( true );
 			__gui_RTi_ExportProduct.setDirty( true );
			//add to Vector

 			__gui_RTi_ExportConf_vect.addElement( ec );

			long mt_num = -999;
			mt_num = ec.getMeasType_num();
			ec = null;
			//find MeasType with matching MeasType_num
			String tsid_str = getTSIDForMeasType_num( mt_num );

			gui_buffer.append( tsid_str + "\n" );
		}

 		__dirty_vect.addElement( "Update ExportConf objects " +
		"associated with ExportProduct? \n" + db_buffer.toString() +
		"\n" + gui_buffer.toString() );

	}
	else {
		if ( Message.isDebugOn ) {
			Message.printDebug( 3, routine,
			"Since number of rows in the current worksheet (" +
			rows + ") does match the number of ExportConf " +
			"objects ("+ orig_num + ") originally associated " +
			"with this ExportProduct, we will go through " +
			"each ExportConf object in the worksheet to " +
			"see if they have changed." );
		}
 		__gui_RTi_ExportConf_vect.clear();

		//go through each and compare each ExportConf object in
		//the worksheet to the one in the original
		//vector of ExportConf objects, assuming it exists in the
		//original list of ExportConf. If they do exist and do,
		//differ, mark the object dirty. If they don't exist,
		//mark object as dirty.
		RiversideDB_ExportConf table_ec = null;
		RiversideDB_ExportConf orig_ec = null;
		String tsid_str= null;
		boolean blnNewEC = false;
		for ( int i=0; i<rows; i++ ) {
			table_ec = (RiversideDB_ExportConf)
			table_vect.elementAt(i);
			if ( table_ec == null ) {
				continue;
			}
			long mt_num = -999;
			mt_num = table_ec.getMeasType_num();
			//find MeasType with matching MeasType_num
			tsid_str = getTSIDForMeasType_num( mt_num );

			//now go through original vector of RTi_ExportConf
			for ( int j=0; j<orig_num;j++ ) {
				orig_ec = (RiversideDB_ExportConf)
 				__db_RTi_ExportConf_vect.elementAt(j);
				if ( orig_ec == null ) {
					continue;
				}
				if ( orig_ec.getMeasType_num() == mt_num ) {
					if ( Message.isDebugOn ) {
						Message.printDebug( 4, routine,
						"Examining ExportConf " +
						"object with MeasType_num ="+
						mt_num + " and tsid = " +
						tsid_str );
					}
					//then we found a matching object that
					//exists in both the worksheet
					//and in the original list of
					//ExportConf objects for this
					//ExportProduct

					//compare the 2 objects.
					String gui_exp_id = table_ec.
					getExport_id();
					String db_exp_id = orig_ec.
					getExport_id();
					if ( Message.isDebugOn ) {
						Message.printDebug( 5, routine,
						"gui_exp_id = \"" +
						gui_exp_id +"\" and " +
						"db_exp_id = \"" +
						db_exp_id +"\"" );
					}
					if (! gui_exp_id.equalsIgnoreCase(
					db_exp_id ) ) {
						table_ec.setDirty( true );
 						__gui_RTi_ExportProduct.setDirty(
						true );
 						__dirty_vect.addElement(
						"Update " +
						"Export ID from:\n \"" +
						db_exp_id + "\" to: \"" +
						gui_exp_id + "\" for Time " +
						"Series:\"" + tsid_str + "\"?");
					}

					String gui_exp_units = table_ec.
					getExport_units();
					String db_exp_units = orig_ec.
					getExport_units();
					if ( Message.isDebugOn ) {
						Message.printDebug( 5, routine,
						"gui_exp_units = \"" +
						gui_exp_units +"\" and " +
						"db_exp_units = \"" +
						db_exp_units +"\"" );
					}
					if (! gui_exp_units.equalsIgnoreCase(
					db_exp_units ) ) {
						if (( db_exp_units == null ) ||
						( db_exp_units.
						length() <= 0 )) {
							db_exp_units ="DEFAULT";
						}
						table_ec.setDirty( true );
 						__gui_RTi_ExportProduct.setDirty(
						true );
 						__dirty_vect.addElement(
						"Update " +
						"Data Units from:\n \"" +
						db_exp_units + "\" to: \"" +
						gui_exp_units + "\" for Time " +
						"Series:\"" + tsid_str + "\"?");
					}
					String gui_isActive = table_ec.
					getIsActive();
					String db_isActive = orig_ec.
					getIsActive();
					if ( Message.isDebugOn ) {
						Message.printDebug( 5, routine,
						"gui_isActive = \"" +
						gui_isActive +"\" and " +
						"db_isActive = \"" +
						db_isActive +"\"" );
					}
					if (! gui_isActive.equalsIgnoreCase(
					db_isActive ) ) {
						table_ec.setDirty( true );
 						__gui_RTi_ExportProduct.setDirty(
						true );
 						__dirty_vect.addElement(
						"Update ImportConf " +
						"IsActive field from:\n \"" +
						db_isActive + "\" to: \"" +
						gui_isActive + "\" for Time " +
						"Series:\"" + tsid_str + "\"?");
					}

					//now we have compared the
					//fields, we need to add this
					//ExportConf object back to
					//Vector of ExportConfs

 					__gui_RTi_ExportConf_vect.addElement(
					table_ec );

						break;
				}

				if ( j == (orig_num -1) ) {
					//then never
					//found a matching one...
					blnNewEC = true;
				}
			}
			if ( blnNewEC ) {
				if ( Message.isDebugOn ) {
					Message.printDebug( 4, routine,
					"Did not find matching " +
					"ExportConf object with " +
					"MeasType_num " + mt_num +
					" and tsid = " + tsid_str +
					", so must have added this " +
					"as a new ExportConf object." );
				}
				// we never found a matching
				//ExportConf object
				//so this one must be a new addition
				table_ec.setDirty( true );
 				__gui_RTi_ExportProduct.setDirty( true );
 				__dirty_vect.addElement(
				"Add ExportConf object \"" +
				tsid_str + "\" to selected ExportProduct?" );

				//update vector of GUI ExportConf objects
 				__gui_RTi_ExportConf_vect.addElement( table_ec );
				table_ec = null;
				orig_ec = null;
			}
		}
	}

} //end verify_timeseries_tab

/**
Verifies all the information on the tabs currently
present in the GUI by calling the specify verify_xxx() methods such as:
verify_files_tab, verify_properties_tab, verify_timeseries_tab, etc.
@exception Exception thrown if error encountered
*/
public void verify_tab_info( ) throws Exception {
	String routine = __class + ".verify_tab_info";

	//some tabs are not added for certain Export product
	//types, so make sure the panel for that tab has been
	//created before checking its fields.
	if ( __files_tab_JPanel != null ) {
		try {
			verify_files_tab();
		}
		catch ( Exception e ) {
			Message.printWarning( 2, routine, e );
		}
	}
	if ( __timeseries_tab_JPanel != null ) {
		try {
			verify_timeseries_tab();
		}
		catch ( Exception e ) {
			Message.printWarning( 2, routine, e );
		}
	}
	if ( __properties_tab_JPanel != null ) {
		try {
			verify_properties_tab();
		}
		catch ( Exception e ) {
			Message.printWarning( 2, routine, e );
			throw new Exception ( "Error verifying the " +
			"properties tab." );
		}
	}
	if ( __security_tab_JPanel != null ) {
		try {
			verify_security_tab();
		}
		catch ( Exception e ) {
			Message.printWarning( 2, routine, e );
		}
	}
	if ( __automation_tab_JPanel != null ) {
		try {
			verify_automation_tab();
		}
		catch ( Exception e ) {
			Message.printWarning( 2, routine, e );
		}
	}

}//end verify_tab_info

/**
Verifies all the information in the top portion of the GUI.
The method <ul><li> fills in the <i>__gui</i> verions of the objects
in memory with the values that are currently set in this portion of the GUI</li>
<li>compares the values in the <i>__gui</i> version of the objects to the
<i>__db</i> version of the objects.  If the <i>__gui</i> versions differ
from the <i>__db</i> verions:<ul>
<li>the <i>__gui</i> versions are marked dirty (<i>.setDirty(true)</i>)</li>
<li>messages are added to the <i>__dirty_vect</i> indicating how the
<i>__gui</i> differs from the <i>__db</i> version (the <i>__db</i> version
remember, represents how the object is in the database itself) </li></ul>
</li></ul></ul>
@exception Exception thrown if error encountered
*/
public void verify_top_fields() throws Exception {

	//holds original node name from tree- this node may need
	//to be updated if the Export Product name changes
 	__db_tree_node_str = __gui_RTi_ExportProduct.getProduct_name() +
	" (type: " + __gui_RTi_ExportProduct.getProduct_type() + ")";

	//Product ID
	String gui_id =null;
	gui_id = ( __product_info_id_JTextField.getText()).trim();
	String db_id = null;
	db_id = __db_RTi_ExportProduct.getProduct_name();
	if ( ! db_id.equalsIgnoreCase( gui_id) ) {
 		__gui_RTi_ExportProduct.setDirty ( true );
 		__dirty_vect.addElement(
		"Change Product Identifier from:\n \"" +
		db_id +"\"\n to:\n \"" +gui_id+"\"");
 		__gui_RTi_ExportProduct.setProduct_name( gui_id );
	}

	//Product Group
	int gui_grp_num = -999;
	String gui_grp = null;
	gui_grp = (String) __product_info_group_JComboBox.getSelected();
	int ind = -999;
	ind = gui_grp.indexOf( " -" );
	if ( ind > 0 ) {
		gui_grp = gui_grp.substring( 0, ind );
	}
	//convert to int
	if ( StringUtil.isInteger( gui_grp ) ) {
		gui_grp_num = StringUtil.atoi( gui_grp );
	}

	//String db_grp = null;
	int db_grp_num = -999;
	db_grp_num = __db_RTi_ExportProduct.getProductGroup_num();
	//if ( ! db_grp.equalsIgnoreCase( gui_grp )) {}
	if ( db_grp_num !=  gui_grp_num ) {
 		__gui_RTi_ExportProduct.setDirty ( true );
 		__dirty_vect.addElement(
		"Change Product Group Number from:\n \"" +
		db_grp_num +"\"\n to:\n \"" +gui_grp_num+"\"");
 		__gui_RTi_ExportProduct.setProductGroup_num(gui_grp_num );
	}

	//Product Type  - can't change this field, so don't need to check.
	String gui_type = null;
	gui_type = (String) __product_info_type_JComboBox.getSelected();
//REVISIT [LT] 2005-02-01 - Replace JComboBox by JTextField.
//	gui_type = (String) __product_info_type_JTextField.getText();	
	ind = -999;
	ind = gui_type.indexOf( " -" );
	if ( ind > 0 ) {
		gui_type = gui_type.substring( 0, ind );
	}
	String db_type = __db_RTi_ExportProduct.getProduct_type( );

	//compare it to the original value for Product TYpe
	if ( ! db_type.equalsIgnoreCase( gui_type ) ) {
		//mark dirty
 		__gui_RTi_ExportProduct.setDirty ( true );
 		__dirty_vect.addElement(
		"Change Product Type from:\n \"" +
		db_type +"\"\n to:\n \"" +gui_type+"\"");
 		__gui_RTi_ExportProduct.setProduct_type( gui_type );
	}


	//MeasLocgroup_num field - required
	int gui_mlg_num = -999;
	int db_mlg_num = -999;
	String gui_mlg_str = null;
	gui_mlg_str = (String) __product_info_measlocgroup_JComboBox.
	getSelected();
	ind = -999;
	ind = gui_mlg_str.indexOf( " - " );
	if ( ind > 0 ) {
		gui_mlg_str = (gui_mlg_str.substring( 0, ind)).trim();
	}
	if ( StringUtil.isInteger( gui_mlg_str ) ) {
		gui_mlg_num = StringUtil.atoi( gui_mlg_str );
	}

	db_mlg_num = __db_RTi_ExportProduct.getMeasLocGroup_num();
	if ( db_mlg_num != gui_mlg_num ) {
		//mark object as dirty
 		__gui_RTi_ExportProduct.setDirty ( true );
 		__dirty_vect.addElement(
		"Change MeasLocGroup_num from \"" +
		db_mlg_num +"\" to \"" +gui_mlg_num+"\"");
		//set in memory
 		__gui_RTi_ExportProduct.setMeasLocGroup_num( gui_mlg_num );
	}

	//Check current "isActive" state to original state.
	String gui_isAct_str = null;
	String db_isAct_str = null;
	db_isAct_str = __db_RTi_ExportProduct.getIsActive();
	if ( __product_info_active_JCheckBox.isSelected() ) {
		gui_isAct_str = "Y";
	}
	else {
		gui_isAct_str = "N";
	}
	//compare
	if ( !db_isAct_str.equalsIgnoreCase( gui_isAct_str )) {
 		__gui_RTi_ExportProduct.setDirty ( true );
 		__dirty_vect.addElement(
		"Change Export Product Is Enabled (Y/N) (see top of gui) "+
		"from \"" + db_isAct_str +"\" to \"" +gui_isAct_str+"\"");

		//set in memory
 		__gui_RTi_ExportProduct.setIsActive(
		gui_isAct_str );
	}

} //end verify_top_fields

////////////////////////  ACTIONS ///////////////////////////////
/////////////////////////////////////////////////////////////////
/**
The event handler manages window events.
@param event Event to handle.
*/
public void actionPerformed (ActionEvent event) {
	String routine = __class + ".actionPerformed";

	try {
	Object source = event.getSource();

	if ( source.equals( __apply_JButton ) ) {
		boolean blnUpdated = true;

		/*
		//update fields again since current ExportConf fields
		//may have changed.
		try {
			verify_timeseries_tab( false );
		}
		catch ( Exception e ) {
			Message.printWarning( 2, routine, e);
			blnUpdated= false;
		}
		*/

		//REQUIRED Fields
		try {
			checkRequiredInput();
		}
		catch ( Exception e ) {
			//then there was an error so do not
			//update object in memory or in database.
			Message.printWarning( 2, routine, e );
			blnUpdated= false;
 			__dirty_vect.clear();
		}

		//update the "GUI" object in memory
		if ( blnUpdated ) {
			try {
				update_RiversideDB_objects();
			}
			catch( Exception e ) {
				Message.printWarning( 2, routine, e );
				blnUpdated=false;
			}
		}
		if ( blnUpdated ) {
			try {
				//update database itself
				update_database();
			}
			catch( Exception e ) {
				Message.printWarning( 2, routine, e );
				blnUpdated=false;
				//update the __gui_ versions to be the
				//the memory version again since update failed.
 				__gui_RTi_ExportProduct = null;
 				__gui_RTi_ExportProduct =
				new RiversideDB_ExportProduct(
 				__db_RTi_ExportProduct );

				//transfer stuff from
				//_db_RTi_ExportConf_vect to __gui_ version
				int s = 0;
				if ( __db_RTi_ExportConf_vect != null ){
					s = __db_RTi_ExportConf_vect.size();
				}

 				__gui_RTi_ExportConf_vect.clear();
				for ( int i=0; i<s; i++ ) {
 					__gui_RTi_ExportConf_vect.addElement(
 					__db_RTi_ExportConf_vect.elementAt(i) );
				}

 				__dirty_vect.clear();
			}
		}
		if ( blnUpdated ) {
			//if we got this far, the database was updated,
			//so update objects in memory.  The __gui_ object
			//was written to the database, so now the
			//_db_ object should equal the __gui_ object
 			__db_RTi_ExportProduct = null;
 			__db_RTi_ExportProduct = new RiversideDB_ExportProduct(
 			__gui_RTi_ExportProduct );
 			__db_RTi_ExportProduct.setDirty( false );

			//update ExportConf - transfer GUI to DB
			int s = 0;
			if ( __gui_RTi_ExportConf_vect != null ){
				s = __gui_RTi_ExportConf_vect.size();
			}
 			__db_RTi_ExportConf_vect.clear();
			RiversideDB_ExportConf ec = null;
			for ( int i=0; i<s; i++ ) {
				ec = (RiversideDB_ExportConf)
 				__gui_RTi_ExportConf_vect.elementAt(i);
				ec.setDirty( false);
 				__db_RTi_ExportConf_vect.addElement( ec );
			}
		}
	}

	if ( source.equals( __automation_tab_automated_JCheckBox )) {

		//if the JCheckBox is Checked, then
		//the other fields should be filled in.

		//if the JCheckBox is un-checked, then
		//the other fields should be grayed out.

		boolean enable_fields = false;
		if ( __automation_tab_automated_JCheckBox.isSelected() ) {
			//if the date fields should be active or not

			enable_fields = true;
			//every interval checkbox
 			JGUIUtil.setEnabled(
			__automation_tab_every_interval_JRadioButton, true);

			//at time radiobutton
 			JGUIUtil.setEnabled(
 			__automation_tab_at_time_JRadioButton, enable_fields );

 			JGUIUtil.setEnabled(
 			__automation_tab_every_interval_JRadioButton,
			enable_fields );
			if ( enable_fields ) {
				//year
 				JGUIUtil.setEnabled(
 				__automation_tab_year_JComboBox, true );

				//month
				JGUIUtil.setEnabled(
 				__automation_tab_month_JComboBox, true );

				//day
				JGUIUtil.setEnabled(
 				__automation_tab_day_JComboBox, true );

				//hour
				JGUIUtil.setEnabled(
 				__automation_tab_hour_JComboBox, true );

				//minute
				JGUIUtil.setEnabled(
 				__automation_tab_minute_JComboBox, true );

				//second
				JGUIUtil.setEnabled(
 				__automation_tab_second_JComboBox, true );

			}
		} //end if the isAutomated button is selected
		else {  //the automation tab not checked,
			//so no fields are active

			JGUIUtil.setEnabled(
 			__automation_tab_every_interval_JRadioButton, false);

			JGUIUtil.setEnabled(
 			__automation_tab_at_time_JRadioButton, false );

			//year
			JGUIUtil.setEnabled(
 			__automation_tab_year_JComboBox, false );

			//month
			JGUIUtil.setEnabled(
 			__automation_tab_month_JComboBox, false );

			//day
			JGUIUtil.setEnabled(
 			__automation_tab_day_JComboBox, false );

			//hour
			JGUIUtil.setEnabled(
 			__automation_tab_hour_JComboBox, false );

			//minute
			JGUIUtil.setEnabled(
 			__automation_tab_minute_JComboBox, false );


			//second
			JGUIUtil.setEnabled(
 			__automation_tab_second_JComboBox, false );

		}
	}
	else if ( source.equals( __cancel_JButton ) ) {
		if ( __bln_new_object ) {
			//if we are adding a new ExportProduct,
			//then we already wrote a ExportProduct to the
			//database in the constructor in order to get the
			//ExportProduct_num (autonum) for the new ExportProduct.
			//If the user cancels b/f making any other saves,
			//we should delete the ExportProduct from the
			//database.  In order to tell if we need to delete
			//it, check to see if the Object in the Database
			//has been updated to have a Product Identifier field.
			//(since that is one of the required fields, we
			//know that the database Has been updated if it is
			//filled or has Not been updated if it isn't).
			String db_id = null;
			db_id = __db_RTi_ExportProduct.getProduct_name();
			//if ( db_id.equals(DMIUtil.MISSING_STRING ) ){}
			if ( DMIUtil.isMissing( db_id ) ) {
				//delete product that had
				//been written to the database and close GUI
				try {
 					__dmi.
					deleteExportProductForExportProduct_num(
					(int) __db_ExportProduct_num );
				}
				catch (Exception e ) {
					Message.printWarning( 2, routine, e);
				}
				//setVisible(false);
				//dispose();
				windowManagerClose();
			}
		}
		//else if(( __cautious_mode ) && ( __dirty_vect.size() > 0 )) {}
		else if( __cautious_mode ) {
			//create and update __gui_ objects in memory
			//The only reason to do this is to provide the
			//user with a Confirm Cancel message.
			try {
				update_RiversideDB_objects();
			}
			catch( Exception e ) {
				Message.printWarning( 2, routine, e);

				//setVisible(false);
				//dispose();
				windowManagerClose();
			}

			//if the ExportConf obj was marked dirty,
			//the ImportProduct would have been too.
			if ( __gui_RTi_ExportProduct.isDirty()) {
				StringBuffer b = null;
				//holds messages from __dirty_vect
				b = new StringBuffer();
				for (int i=0;i< __dirty_vect.size();i++) {
					b.append( (String)
 					__dirty_vect.elementAt(i)+"\n" );
				}

				//write out a confirmation message.
				int x = new ResponseJDialog( this,
				"Cancel Changes",
				"Are you sure you want to " +
				"Cancel the following changes?\n" +
				b.toString() ,
				ResponseJDialog.YES | ResponseJDialog.NO ).
				response();

				if ( x == ResponseJDialog.YES ) {
					//write to log file
					Message.printStatus( 5,
					routine, "User canceled changes: " +
					b.toString() );

					//setVisible(false);
					//dispose();
					windowManagerClose();

					//empty out dirty vector
 					__dirty_vect.clear();

				}
				else {
					//do nothing.. leave GUI open
 					__dirty_vect.clear();
				}
				b = null;
			}
			else {
				//Nothing has been changed, so
				//just do a normal cancel- close gui
				windowManagerClose();
				//setVisible(false);
				//dispose();
			}
		}
		else {
			//just do a normal cancel- close gui
			windowManagerClose();
			//setVisible(false);
			//dispose();
		}
	}
	else if ( source.equals( __close_JButton ) ) {
		closeGUI();
	}

	//BROWSE BUTTONS
	else if ( source.equals( __files_tab_dest_browse_JButton) ) {

		String cur_dir = null;
		cur_dir = __files_tab_dest_dir_JTextField.getText().trim();
		if (( cur_dir == null ) || ( cur_dir.length() <= 0 )) {
			//try getting a directory from JGUIUtil
			cur_dir = JGUIUtil.getLastFileDialogDirectory();
		}

		JFileChooser chooser = JFileChooserFactory.createJFileChooser();
		String open_file_title = "Select Destination Directory";
		chooser.setDialogTitle( open_file_title );
		File file = new File( cur_dir );

		//if "file" is null, then it will
		//open the file chooser in the user's defualt directory
		//(usually "My Documents" on Windows OS, and $HOME on Unix)
		chooser.setCurrentDirectory( file );
		int returnVal = chooser.showOpenDialog( this );

		if ( returnVal == JFileChooser.APPROVE_OPTION ) {
 			__files_tab_dest_dir_JTextField.setText(
			chooser.getSelectedFile().getPath());
		}
		chooser = null;
	}

	else if ( source == __props_tab_export_end_current_JCheckBox ) {
		update_export_date_fields( "end" );
	}
 	else if ( source == __props_tab_export_end_numb_JComboBox ) {
		//check that they entered an integer
		String s = (String) __props_tab_export_end_numb_JComboBox.
		getSelected();
		if (( s == null ) || ( ! StringUtil.isInteger( s ) ) ) {
			Message.printWarning( 1, routine,
			"You must enter or select an integer in " +
			"the middle Export End Date comboBox." , this );
			return;
		}
	}
	else if ( source == __props_tab_export_start_current_JCheckBox ) {
		update_export_date_fields( "start" );
	}

 	else if ( source == __props_tab_export_start_numb_JComboBox ) {
		//check that they entered an integer
		String s = (String) __props_tab_export_start_numb_JComboBox.
		getSelected();
		if (( s == null ) || ( ! StringUtil.isInteger( s ) ) ) {
			Message.printWarning( 1, routine,
			"You must enter or select an integer in " +
			"the middle Export Start Date comboBox.", this  );
			return;
		}
	}

 	else if ( source == __props_format_obsreport_JComboBox )  {
		//if TXT is selected, activate the delimiter field,
		//otherwise, de-activate it.

		if ( ((String) __props_format_obsreport_JComboBox.
		getSelected()).startsWith( "TXT" ) ) {
			JGUIUtil.setEnabled(
			__props_deliminiter_obsreport_JTextField, true );

		}
		else {
			JGUIUtil.setEnabled(
			__props_deliminiter_obsreport_JTextField, false );
		}
	}

	else if ( source.equals( __timeseries_tab_clear_selected_JButton ) ) {

		int row = __timeseries_tab_selTS_JWorksheet.getSelectedRow();

		//get total number of rows--- cannot delete last row
		int total_num = __timeseries_tab_selTS_JWorksheet.getRowCount();
		if( ( total_num ==1 ) || ( total_num == 0 ) ) {
			Message.printWarning( 1, routine,
			"Unable to delete the last row of data. ");
		}
		else if ( row != -1 ) {
			//get tsid from 1 column to delete MeasType
			//that is also associated with the ExportConf in the
			//table.
			String tsid_str = (String)
 			__timeseries_tab_selTS_JWorksheet.getValueAt(row,
			1) ;

   			int x = new ResponseJDialog(this,
    			"Delete Selected Row", "Delete Export Conf object "+
			"for " + tsid_str + "?",
    			ResponseJDialog.YES | ResponseJDialog.NO)
    			.response();

   			if (x == ResponseJDialog.NO) {
    				return;
   			}

 			__timeseries_tab_selTS_JWorksheet.cancelEditing();
 			__timeseries_tab_selTS_JWorksheet.deleteRow(row);

 			__table_model.deleteMeasType( tsid_str );
		}
		else {
			Message.printWarning( 1, routine,
			"You must select a row to delete. " , this );
		}

	} //end move left
	else if ( source.equals( __timeseries_tab_move_right_JButton ) ) {

		//make vector of selected MeasType objects and corresponding
		//Vector of ExportConf objects
		Vector mt_vect = new Vector();
		Vector ec_vect = new Vector();
		//read in all ExportConf objects
		Vector all_ExportConf_vect = null;
		try {
			all_ExportConf_vect =
 			__dmi.readExportConfList();
		}
		catch ( Exception e ) {
			Message.printWarning( 2, routine, e);
			all_ExportConf_vect = null;
		}
		int num_ec = 0;
		if ( all_ExportConf_vect != null ) {
			num_ec =  all_ExportConf_vect.size();
		}

		//make sure that measType does not already exist in the
		//worksheet of selected ExportConf objects.
		Object[] selTS_to_move =null;
		if ( __timeseries_tab_allTS_JList.getModel().getSize() > 0 ) {
			selTS_to_move =
 			__timeseries_tab_allTS_JList.getSelectedValues();
		}
		//go through each selected item and make sure it
		//is not already in the right worksheet of selected TS
		String ts = null;
		String ts_nodesc ="";
		boolean blnMove = true;
		for ( int i=0; i< selTS_to_move.length; i++ ) {
			ts = (String) selTS_to_move[i];
			if ( ts == null ) {
				continue;
			}
			ts_nodesc = ts;
			int ind = -999;
			ind = ts.indexOf( " - " );
			if ( ind > 0 ) {
				ts_nodesc = ts.substring( 0, ind ).trim();
			}
			//get number of rows.
			int rows = __timeseries_tab_selTS_JWorksheet.
			getRowCount();
			String s = null;
			for ( int r=0; r< rows; r++ ) {
				s = (String) __timeseries_tab_selTS_JWorksheet.
				getValueAt(r, 1 );
				if ( s.equals( ts_nodesc ) ) {
					Message.printWarning( 1, routine,
					"Time Series: \"" +ts_nodesc +
					"\"\n already in worksheet " +
					"of export time series.",
					this);
					blnMove = false;
					break;
				}
			}
			RiversideDB_MeasType sel_mt = null;
			long sel_mt_num = -999;
			if ( blnMove ) {
				//now make sure it is not
				//already used as an ExportConf
				//check to make sure there is
				//not an ExportConf
				//object already for this ExasType
				//( in another Export product)

				//get MeasType_num for selected TS.
				try {
					sel_mt =
 					__dmi.readMeasTypeForTSIdent( ts_nodesc);
				}
				catch ( Exception e ) {
					Message.printWarning( 2, routine, e);
					sel_mt_num = -999;
				}
				if ( sel_mt != null ) {
					sel_mt_num = sel_mt.getMeasType_num();
				}
				RiversideDB_ExportConf ec = null;
				long mt_num =-999;
				for ( int j=0;j<num_ec;j++ ) {
					ec =(RiversideDB_ExportConf)
					all_ExportConf_vect.
					elementAt(j);
					if ( ec == null ) {
						continue;
					}
					//get MeasType num from it.
					mt_num = ec.getMeasType_num();
					if( mt_num == sel_mt_num ) {
						if ( Message.isDebugOn ) {
							Message.printDebug( 4, routine,
							"Found object with matching" +
							"MeasType_num as selected " +
							"MeasType (MeasType_num = "+
							sel_mt_num + ") " );
						}
						//we won't move the selected
						//time series
						//over since it already is
						//used as an
						//ExportConf obj.
						//Find which ExportProduct
						//it is related to.
						RiversideDB_ExportProduct ep = null;
						String ep_name = "";
						try {
							ep = __dmi.
							readExportProductForExportProduct_num(
							(int)ec.getExportProduct_num() );
						}
						catch( Exception e) {
							Message.printWarning( 2,
							routine,e );
							ep_name = "";
							ep = null;
						}
						if ( ep != null ){
							ep_name = ep.getProduct_name() ;
							Message.printWarning( 1,
							routine,
							"Time Series: \n\"" +
							ts_nodesc +
							"\"\n already used as " +
							"ExportConf object "+
							"\nin ExportProduct: \"" +
							ep_name +
				 			"\"", this);
							blnMove= false;
							break;
						}
					}
				}
			}
			//add it to the Vector of
			//MeasType objects
			if ( blnMove ) {
				mt_vect.addElement( sel_mt );

				RiversideDB_ExportConf new_ec =
				new RiversideDB_ExportConf();
				new_ec.setMeasType_num( sel_mt_num );
				new_ec.setExportProduct_num(
 				__db_RTi_ExportProduct.
				getExportProduct_num());

				new_ec.setIsActive( "Y" );

				ec_vect.addElement( new_ec );

 				__table_model.addMeasType( sel_mt );
 				__timeseries_tab_selTS_JWorksheet.
				addRow( new_ec );

 				__timeseries_tab_selTS_JWorksheet.
				scrollToLastRow();
 				__timeseries_tab_selTS_JWorksheet.
				selectLastRow();
			}
		}

	} //end source move right
	
	else if ( source == __files_tab_dest_wild_JComboBox ) {
			// Get wildcard
			String wild = null;
			wild = (String) __files_tab_dest_wild_JComboBox.getSelected();
			int ind = -999;
			ind = wild.indexOf(" -" );
			if ( ind > 0 ) {
				wild = wild.substring( 0, ind ).trim();
				// Get current text and append to it.
				String gui_file = null;
				gui_file = __files_tab_dest_file_JTextField.getText();
 					__files_tab_dest_file_JTextField.setText(
 						 gui_file + wild );
 			}
	}

	source = null;
	} // End of try
	catch ( Exception e ) {
		if ( Message.isDebugOn ) {
			Message.printWarning ( 2, routine, e );
		}
	}
} //end action performed

/**
Respond to ItemEvents.
@param event ItemEvent to listen for.
*/
public void itemStateChanged ( ItemEvent event ) {
	Object source = event.getItemSelectable();
	if ( event.getStateChange() == ItemEvent.SELECTED ) {
		if ( source == __automation_tab_month_JComboBox ) {
			//update days_vect to have correct number of days.
			update_automation_days();
		}
	}
} //end itemStateChanged

//WINDOW EVENTS
public void windowActivated ( WindowEvent e )
{
}

/**
This class is listening for GeoViewGUI closing so it can gracefully handle.
*/
public void windowClosed ( WindowEvent e )
{
}

/**
We care if the GUI is closing because we need to shut it down gracefully.
*/
public void windowClosing ( WindowEvent e ) {
	if ( __canWriteExportProduct ) {
	 	closeGUI();
	}
	else {
		//just close as a cancel
		//setVisible(false);
		//dispose();
		windowManagerClose();
	}
}

public void windowDeactivated ( WindowEvent e )
{
}

public void windowDeiconified ( WindowEvent e )
{
}

public void windowIconified ( WindowEvent e )
{
}

public void windowOpened ( WindowEvent e )
{
}

private void windowManagerClose() {
	if (__originallyNewObject) {
		_windowManager.closeWindowInstance(
			_windowManager.WINDOW_EXPORT_PRODUCT,
			"CREATING NEW OBJECT");
	}
	else {
		//the measloc_num is the unique ID for this window.
		_windowManager.closeWindowInstance(
			_windowManager.WINDOW_EXPORT_PRODUCT,
			new Long(__db_RTi_ExportProduct.getExportProduct_num()));
	}
}
/////////////////////// END ACTIONS /////////////////////////////

}// end RiversideDB_Export_JFrame class
