//--------------------------------------------------------------------------
// RiversideDB_Location_JFrame -
//	Contains the code used to create the GUI for
//	MeasLoc Stations and Areas.
//	GUI for the RiverTrakAssistant.  This class is called by
//	the RTAssistant_Main_JFrame.
//
//--------------------------------------------------------------------------
// Copyright:	See the COPYRIGHT file.
//--------------------------------------------------------------------------
// History:
//
// 2002-06-10	Morgan Sheedy, RTi	Initial Implementation
//
//
// 2002-06-11	AMS, RTi		Changed class name from:
//					RiversideDBAdministratorMeasLocJFrame
//					to: RTiDBAdmin_MeasLoc_JFrame
//
// 2002-06-12 	AMS, RTi		Formatted numbers to be written
//					in the GUI with precision: %.6f and
//					for comparison, the numbers are
//					formatted to %.6f.
//
// 2002-06-15	AMS, RTi		Changed name from:
//					RTiDBAdmin_MeasLoc_JFrame
//					to: RTiDBAdmin_Location_JFrame
//					Made class specific to Station/Areas.
//
// 2002-09-26	Morgan Love, RTi	Changed Application name from:
//					RiversideDBAdmin to:
//					RiverTrakAssistant and Class from:
//					RTiDBAdmin_Location_JFrame to:
//					RTAssistant_Location_JFrame.
//
// 2003-05-09	Morgan Love, RTi	Updated code to have:
//					checkRequiredFields() method which
//					is called before objects are
//					updated in memory.
//					Also, once update_RiversideDB_objects()
//					is called, a new copy of the
//					objects are created, named the
//					"_gui_RTi_MeasLoc" and "_gui_RTi_GeoLoc"
//					respectively.  The "_gui_" versions
//					are the versions that are operated
//					on and are marked as "setDirty" so that
//					if the user decides Not to save their
//					changes, the original "_db_"
//					versions of the object are unchanged.
//
// 					__cautious_mode flag added. When
//					true, user is prompted to confirm
//					changes before the database is
//					updated and to confirm Cancel if
//					they have made changes.
//
// 2003-06-03	AML, RTi		Update to use new TS classes.
//
// 2003-06-08	AML, RTi		DBUser, DBGroup, DBPermissions
//					implemented for security.
//
// 2003-06-11	AML, RTi		*Add Group: to MeasLocGUI as
//					an uneditable JComboBox to
//					incorporate the MeasLocGroup_num.
//
// 2003-06-30	AML, RTi		*code clean up
//
// 2004-02-06	J. Thomas Sapienza, RTi	Added window manager code.
//
// 2004_07_14	AML, RTi		*.setEnabled() and setBackgroundColor()
//					replaced by JGUIUtil.setEnabled().
//					*general code cleaning.
// 2004-10-25 Luiz Teixeira, RTi	Upgraded by moving it from the
//					main application (RiverTrak Assistant)
//					to the RiversideDB_DMI library.
// 2004_10_29 Luiz Teixeira, RTi	Created the class
//					RiversideDB_BaseEditor_JFrame.java to
// 					be used as base for all the editor
//					that needed to communicate back to the
//					calling classes. This is now done via
//					the RiversideDB_System_Listener which
//					is implemented in the base class
//					RiversideDB_BaseEditor_JFrame. The
//					base class also implements the
//					addRiversideDBSystemListener(...)
//					and the private array member
//					RiversideDB_System_Listener []
//					_listeners to keep the assingned
//					listeners. This class now extends
// 					from RiversideDB_BaseEditor_JFrame.
// 2004_10_29 Luiz Teixeira, RTi	Removed the definition and all
//					reference to all __calling_class.
//					From now on using the
//					RiversideDB_System_Listener implemen
//					ted in RiversideDB_BaseEditor_JFrame
// 2005-01-05 Luiz Teixeira, RTi	Added the argument _dmi to the calls to
//						RiversideDB_..._TableModel
// 2005-01-07 Luiz Teixeira, RTi 	Replaced the JWorksheet property names
//
// 2005-04-11	J. Thomas Sapienza, RTi	The table model changed to use the
//					new version of row numbering, in which
//					the row numbers are not returned by the
//					table model but are generated by the
//					worksheet, so the properties for 
//					the worksheet in have been changed.
// 2005-08-10	JTS, RTi		Added __originallyNewObject so that the
//					window manager would properly close the
//					GUI for new Locations.
//--------------------------------------------------------------------------

package RTi.DMI.RiversideDB_DMI;

import  java.awt.Color;
import  java.awt.Dimension;
import  java.awt.GridBagConstraints;
import  java.awt.GridBagLayout;
import  java.awt.Insets;
import  java.awt.event.ActionEvent;
import  java.awt.event.ActionListener;
import  java.awt.event.ItemEvent;
import  java.awt.event.ItemListener;
import  java.awt.event.WindowEvent;
import  java.awt.event.WindowListener;
import  java.util.List;
import  java.util.Vector;

import 	javax.swing.BorderFactory;
import 	javax.swing.border.Border;
import 	javax.swing.border.TitledBorder;
import 	javax.swing.DefaultComboBoxModel;
import 	javax.swing.JComboBox;
import 	javax.swing.JDialog;
import 	javax.swing.JFrame;
import 	javax.swing.JLabel;
import 	javax.swing.JOptionPane;
import 	javax.swing.JPanel;
import 	javax.swing.JScrollPane;
import 	javax.swing.JTabbedPane;
import 	javax.swing.JTextField;

import  RTi.Util.GUI.JGUIUtil;
import  RTi.Util.GUI.JWorksheet;
import  RTi.Util.GUI.ResponseJDialog;
import  RTi.Util.GUI.SimpleJButton;
import  RTi.Util.GUI.SimpleJComboBox;
import 	RTi.Util.IO.DataUnits;
import  RTi.Util.IO.IOUtil;
import  RTi.Util.IO.PropList;
import	RTi.Util.Message.Message;
import  RTi.Util.String.StringUtil;
import  RTi.Util.Time.DateTime;
import  RTi.Util.Time.TimeUtil;

import 	RTi.DMI.DMIUtil;
import 	RTi.DMI.RiversideDB_DMI.RiversideDB_DataSource;
import 	RTi.DMI.RiversideDB_DMI.RiversideDB_DBUser;
import 	RTi.DMI.RiversideDB_DMI.RiversideDB_DMI;
import 	RTi.DMI.RiversideDB_DMI.RiversideDB_Geoloc;
import 	RTi.DMI.RiversideDB_DMI.RiversideDB_MeasLoc;
import 	RTi.DMI.RiversideDB_DMI.RiversideDB_MeasLocGroup;
import 	RTi.DMI.RiversideDB_DMI.RiversideDB_RatingTable;
import 	RTi.DMI.RiversideDB_DMI.RiversideDB_RatingTable_CellRenderer;
import 	RTi.DMI.RiversideDB_DMI.RiversideDB_RatingTable_TableModel;
import 	RTi.DMI.RiversideDB_DMI.RiversideDB_StageDischargeRating;

/**
RiversideDB_Location_JFrame.
This class is laid out similarly to the other RiverTrakAssistant classes.
The general format of the class is laid out below, with the major
methods listed with their key functions.  The main object types from
RiversideDB that are manipulated by this class are:<br><ul>
<li>RiversideDB_MeasLoc (abbreviated MeasLoc)</li>
<li>RiversideDB_GeoLoc (abbreviated GeoLoc)</li></ul><br>
<li>RiversideDB_StageDischargeRating (abbreviated StageDischargeRating)</li></ul><br>
<p><b>Constructor</b><br>
The constructor is called by an action in one of the JTrees of the
main application.  The main application passes to this class a
RiversideDB_MeasLoc.  This class is called in one of two cases: <br>
<ul><li>to view the properties of a current MeasLoc</li>
<li>to create a new MeasLoc</li></ul>
In the case of viewing a current MeasLoc, the MeasLoc object
passed to this class is already defined and all required properties
already known.  In the case of creating a totally new MeasLoc, the
MeasLoc passed in to this class is essentially an empty skeleton,
with only the MeasLoc object type (AREA vs STATION/POINT) and MeasLocGroup_num
known since they can be attained from the JTree.
<br>
It is important to distinguish in the constructor, if we are dealing with
an existing MeasLoc and just changing some of its fields or if
we are creating a totally new MeasLoc.  If the Identifier field
for the MeasLoc passed in is MISSING (String), then we know that we are
creating a new MeasLoc object and a new GeoLoc.  In the constructor then, set
the <i>__bln_new_object = true </i> flag.  The <b><i>__bln_new_object</i></b>
flag is important because:<br>
<ul>
<li>we can mark the object as dirty (using the <i>setDirty(true)</i> flag)
 since it is an entirely new object</li>
<li>we need to add the fields for <i>DBUser</i>, <i>DBGroup</i>, and
<i>DBPermissions</i> based on the information already known by the DMI for
this user.</li>
<li> we do not have to confirm changes made to a totally new object like we do
if the user is changing an existing object</li>
<li>we need to know to add a new node to the JTree</li></ul>
At this point, whether we are creating a new MeasLoc or modifying an
existing one, we assign the MeasLoc to the variable known throughout
this class as: <b><i>__gui_RTi_MeasLoc</i></b>.  We also set up
the variable known throughout this class as: <b><i>
__gui_RTi_GeoLoc</i></b> which is a GeoLoc object that
are related to the <i>__gui_RTi_MeasLoc</i>.  If we have created
a totally new MeasLoc, the <i>__gui_RTi_GeoLoc</i> is an
empty object; otherwise, it is a "full" object read directly
from the database, based on the MeasLoc_num of the (already existing)
MeasLoc_num. Finally, if the MeasLoc is of type: STATION/POINT (and not AREA),
we create a Vector of related StageDischargeRating
objects, <i>__stageDischargeRating_vect </i>, which will be an empty
vector if we have created a totally new MeasLoc object; otherwise, the
Vector of StageDischargeRating objects will be read from the database,
using the MeasLoc_num of the existing MeasLoc object.
<br><br>
Finally, the constructor also:<ul><li> sets up Vectors of (static) reference
data, read directly from the database thay will be used throughout the class
</li> <li>calls method: <i>init_layout_GUI()</i> which creates and sets up the
GUI components</li></ul><br>
</p>
<p><b>init_layout_gui</b><br>
This method is called from the constructor to create and layout the
GUI components.  It calls the method: <i>create_main_panel</i>, which
in turn calls methods named such as: <i>assemble_tab_geography()</i>,
<i>assemble_tab_rating</i>.  These methods all create
GUI components and put them together in a <i>GridBagLayout</i>. They
do not worry about setting correct values in the components' fields, but just
gets the components set up.  The main components in the GUI consists of:
<ul><li>JPanel that contains general information pertinent to the MeasLoc
object at the top of the GUI</li>
<li>a tab ("Geography" tab) in a JTabbedPane with fields for GeoLoc
object's information </li><li> a tab (the "Ratings" tab) for the related
StageDischargeRating objects if the object is a STATION/AREA, </li>
<li>a panel added at the bottom that includes the standard buttons for:
<ul><li>apply</li><li>close</li><li>cancel</li></ul></li></ul>
At the end of <i>init_layout_gui</i>, a
call to <i>update_gui_fields</i> is made which fills in all the
fields of the GUI according to the MeaLoc, GeoLoc, and StageDischargeRating
objects currently being worked with.
</p>
<p><b>update_gui_fields</b><br>
This method: <ul><li>determines if the current user, already known to the DMI,
has write permissions.  If the user does not have write permissions, the
<b>apply</b> and <b>close</b> buttons are disabled, leaving only the
<b>cancel</b> button enabled.</li><li>Fills in all the GUI fields according
to the data in the MeasLoc and related GeoLoc and StageDischargeRating
objects.</li></ul>
</p><br>
At this point the GUI is essentially laid out and we wait for actions...  The
major methods triggered by actions include: <ul>
<li><i>checkRequiredInput()</i></li>
<li><i>update_RiversideDB_objects()</i></li>
<li><i>update_database()</i></li></ul>
Each of these will be detailed below.

<p><b>checkRequiredInput</b><br>
This method simply goes through all the fields in the GUI and checks that
each fields is: <ul> <li>filled in if it is a required field </li>
<li>contains valid values (for JTextFields, for example)</li>
</ul>If an invalid entry is encountered, the method displays a warning message,
indicating the fields with invalid values.
</ul>
</p>

<p><b>update_RiversideDB_objects</b><br>
This method:<ul>
<li><b>creates the <i>__gui</i> versions of the objects!</b> This includes: <ul><li>__gui_RTi_MeasLoc</li><li>__gui_RTi_GeoLoc</li><li>Vector for
StageDischargeRating objects: __stageDischargeRating_vect</li></ul> The
<i>__gui</i> versions are created in this method by copying the <i>__db</i>
versions (which were originally created and set up in the constructor)</li>
<li>calls the <i>verify_xxx</i> methods. These include:<ul>
<li><i>verify_top_fields()</i></li>
<li><i>verify_geography_tab()</i></li>
<li><i>verify_ratings_tab()</i></li>
The <i>verify_xxx</i> methods:<ul><li> fill in the <i>__gui</i> verions of the objects
in memory with the values that are currently set in the GUI</li>
<li>compares the values in the <i>__gui</i> version of the objects to the
<i>__db</i> version of the objects.  If the <i>__gui</i> versions differ
from the <i>__db</i> verions:<ul>
<li>the <i>__gui</i> versions are marked dirty (<i>.setDirty(true)</i>)</li>
<li>messages are added to the <i>__dirty_vect</i> indicating how the
<i>__gui</i> differs from the <i>__db</i> version (the <i>__db</i> version
remember, represents how the object is in the database itself) </li></ul>
</li></ul></ul>
</p>
<p><b>update_database</b><br>
This method: <ul>
<li>makes a confirmation message to verify that the user wants to save the
changes (and lists out all the changes from the <i>__dirty_vect</i>) <b>if</b>
a new MeasLoc was <b>not</b> created (if a new MeasLoc was created,
we do not want to re-confirm every change)</li>
<li>writes the <i>__gui</i> version of the objects to the database</li>
<li>if the objects were successfully written to the database, the
<i>__gui</i> objects are marked as <b>not</b> dirty
( <i>setDirty(false)</i></li>
<li><i>__dirty_vect</i> is cleared out</li>
<li>if we created a new MeasLoc object (<i>__bln_new_object == true</i>),
add a new node on the JTree in the main application  - <b>or</b> -  update the
existing MeasLoc node on the JTree with the new changes.</li>
</ul>
</p>

<br>
<p><b>ACTIONS and the events they trigger</b><br>
The main actions in the GUI are fired off when the user selects one of the
following buttons:<ul><li>cancel</li><li>close</li><li>apply</li></ul>
<ul><li><b>cancel</b><br>
Items that are checked before the GUI is closed:<ul>
<li>if the user was changing the properties of an existing MeasLoc,
<ul><li><i>update_RiversideDB_objects()</i> is called to <b>create</b> and
update the <i><b>__gui_RTi_MeasLoc</b></i>, <i>
<b>__gui_RTi_GeoLoc</b></i>, and the <i><b>__stageDischargeRating_vect</b></i>
objects in memory, mark them dirty, and add messages to the
<i>__dirty_vect</i> Vector.</li><li>Print a confirmation
message, confirming the user wants to cancel the changes (that are stored
in the <i>__dirty_vect</i>) </li></ul> </li> </ul> </li>
<li><b>close</b> (close Button and "X" in application window bar)<br>
The method: <i>closeGUI()</i>is called which does the following:<ul>
<li>calls <i>checkRequiredInput</i> which makes sure all the required fields in the GUI are filled out and have valid entries</li>
<li>calls <i>update_RiversideDB_objects</i> which is called to
<b>create</b> and update the <i><b>__gui_RTi_MeasLoc</b></i> and
<i> <b>__gui_RTi_GeoLoc</b></i> and <i><b>__stageDischargeRating_vect</b></i>
objects in memory, mark them dirty, and add messages to the
<i>__dirty_vect</i> Vector.
</li>
<li>creates a confirmation message if the <i>__gui</i> versions are dirty,
prompting the user to verify if they want to save their changes
(all the changes are listed out from the <i>__dirty_vect</i>)</li>
<li>updates the database by calling, <i>update_database</i></li>
<li>closes the GUI and destroys it</li>
</ul> </li>
<li><b>apply</b><br>
After the <b>apply</b> button is pressed, methods are called that follow a
similar pattern as those called after the <b>close</b> button outlined above.
These methods are:<ul>
<li>checkRequired_input</li>
<li>update_RiversideDB_objects</li>
<li>update_database</li>
<li>Then, since the GUI is not being closed, the objects need to be updated
in memory to represent the new states.  Since the <i>__gui</i> objects have
been written to the database, the <i>__db</i> objects need to be updated to
represent the new database status.  To do so:<ul><li> the
<i>__db_RTi_MeasLoc</i> object is re-created, using the copy
constructor and passing in the <i>__gui_RTi_MeasLoc</i> object: <br>
<i>__db_RTi_MeasLoc = new RiversideDB_MeasLoc
( __gui_RTi_MeasLoc) </i> </li><li>the <i>__stageDischargeRating_vect</i>
is cleared out, and the  <i>__db_RTi_GeoLoc</i> object is re-created,
using the copy constructor and passing in the <i>__gui_RTi_GeoLoc</i> object
<br> </li></ul> </li>
</ul>
</li>
</ul>
*/
public class RiversideDB_Location_JFrame
	extends    RiversideDB_EditorBase_JFrame
	implements ActionListener,
		   ItemListener,
		   WindowListener
{

// Class name
private static String __class = "RiversideDB_Location_JFrame";

//variables passed in with constructor.
//RiversideDB_DMI object - already opened
private RiversideDB_DMI __dmi = null;

//Variable to hold which system units we are using
private String __system_units = null;

//String to use for the TITLE of the GUI-
//ALso is used to indicate if we have either "AREA" or "STATION"
private String __title = null;

//stores the index of the tab that is on top.
//this is used when the user changes tabs, so that
//the index of the tab that was previously on top is
//still known and the info on that previous tab can be
//verified at that point in time.
int __selectedTab_index = 0;

//Shared Layout parameters
Insets __insets = null;
GridBagLayout __gridbag = null;

//indicates what the current action is
//ie, if an MeasLoc is being "added" or just "updated"
private boolean __bln_new_object = false;
private boolean __originallyNewObject = false;

//Main Container components
private JPanel __main_JPanel = null;
private JPanel __top_station_info_JPanel = null;
private JPanel __tabbedInfo_JPanel = null;

//Tabbed pane itself
private JTabbedPane __info_JTabbedPane = null;

//String added to SimpleJComboBox lists if the field that
//the combobox represents is not a required field and can
//be left empty
String NONE_STRING = "NONE";

//components for close panel
private SimpleJButton __close_JButton = null;
private SimpleJButton __cancel_JButton = null;
private SimpleJButton __apply_JButton = null;

/////////////////////////////////////////////////////////
//         STATIONS / POINTS
/////////////////////////////////////////////////////////
//TOP information Panel for STATIONS
//strings for top panel
private JTextField __station_id_JTextField = null;
private JTextField __station_name_JTextField = null;
private SimpleJComboBox __station_source_JComboBox = null;
private JTextField __station_type_JTextField = null;
private SimpleJComboBox __station_measlocgrp_JComboBox = null;

//STATIONS:
//GEOGRAPHIC DATA TAB
//string for tab - has to be short in length
private String __geog_tab_string = "Geographic Data";
//information label
private JTextField __geog_tab_latitude_JTextField = null;
private JTextField __geog_tab_longitude_JTextField = null;
private JTextField __geog_tab_x_JTextField = null;
private JTextField __geog_tab_y_JTextField = null;
private JTextField __geog_tab_country_JTextField = null;
private JTextField __geog_tab_state_JTextField = null;
private JTextField __geog_tab_county_JTextField = null;
private JTextField __geog_tab_elevation_JTextField = null;
private SimpleJComboBox __geog_tab_units_JComboBox = null;

//Rating Curve tab
JDialog __rating_newDates_JDialog = null;
private String __rating_tab_string = "Rating Data";
//information label
JComboBox __rating_tab_dates_JComboBox =null;
DefaultComboBoxModel __rating_tab_dates_model =null;
SimpleJButton __rating_tab_add_dates_JButton =null;
JTextField __rating_tab_datum_JTextField =null;
SimpleJComboBox __rating_tab_datum_units_JComboBox =null;
JTextField __rating_tab_warning_stage_JTextField =null;
JTextField __rating_tab_flood_stage_JTextField =null;
SimpleJComboBox __rating_tab_interpol_JComboBox =null;
SimpleJComboBox __rating_tab_stage_units_JComboBox =null;
SimpleJComboBox __rating_tab_discharge_units_JComboBox =null;
JWorksheet __rating_JWorksheet =null;
JScrollPane __rating_worksheet_JScrollPane =null;
SimpleJButton __rating_tab_rating_add_JButton =null;
SimpleJButton __rating_tab_rating_delete_JButton =null;
SimpleJButton __rating_tab_rating_edit_JButton =null;
PropList __worksheet_PropList = null;
Dimension __worksheet_dim = new Dimension( 245, 100 );

//popup dialog to set new dates
SimpleJComboBox __rating_tab_popup_start_MM_JComboBox = null;
JComboBox __rating_tab_popup_start_DD_JComboBox = null;
DefaultComboBoxModel __rating_tab_popup_start_DD_model = null;
JTextField __rating_tab_popup_start_YYYY_JTextField = null;
SimpleJComboBox __rating_tab_popup_start_HH_JComboBox = null;
SimpleJComboBox __rating_tab_popup_start_mm_JComboBox = null;
SimpleJComboBox __rating_tab_popup_end_MM_JComboBox = null;
JComboBox __rating_tab_popup_end_DD_JComboBox = null;
DefaultComboBoxModel __rating_tab_popup_end_DD_model = null;
JTextField __rating_tab_popup_end_YYYY_JTextField = null;
SimpleJComboBox __rating_tab_popup_end_HH_JComboBox = null;
SimpleJComboBox __rating_tab_popup_end_mm_JComboBox = null;
SimpleJButton __rating_tab_popup_ok_JButton = null;
SimpleJButton __rating_tab_popup_cancel_JButton = null;

//String to hold the preselected Station ID
//that get passed in if this GUI is created via the
//popup menu on the JTree in the main interface.
//If these strings are null, the GUI will be
//empty and usefull for creating a NEW STATION
private String __preselected_ID_string = null;

//all the OBJECTS that are manipulated in this GUI.
//Current Geoloc object
//And Vectors of all of the objects
RiversideDB_Geoloc __db_RTi_GeoLoc = null;
//MeasLoc object that is currently being used...
RiversideDB_MeasLoc __db_RTi_MeasLoc = null;
private List __RTi_MeasLoc_vect = null;
//StageDischargeRating vector
private List __stageDischargeRating_vect = null;

//Vector of JWOrksheets containing data from RatingTable table
private List __ratingTable_worksheet_vect = new Vector();

//StageDischargeRating Object previously selected on the RATINGS tab
RiversideDB_StageDischargeRating __previous_RTi_StageDischargeRating = null;

//Strings for the TYPE
String TYPE_STATION = "P - POINT";
String TYPE_AREA = "A - AREA";

///////////////////////////////////////////////////
// Station Tab
//////////////////////////////////////////////////
//Station DATA TAB - not used currently
//string for tab - has to be short in length
private String __station_tab_string = "Station";

///////////////////////////////////////////////////
// AREA Tab
///////////////////////////////////////////////////
//Area DATA TAB - not used currently
//string for tab - has to be short in length
private String __area_tab_string = "Area";
//information label
private String __area_tab_info_JLabel_string = "Specify area data -UNAVAILABLE";
private JTextField __area_tab_num_JTextField = null;
private JTextField __area_tab_id_JTextField = null;
private JTextField __area_tab_name_JTextField = null;
private JTextField __area_tab_area_JTextField = null;
private SimpleJComboBox __area_tab_units_JComboBox = null;

//Holds a list of status information-- each
//field that has been changed is recored in this vector.
private List __dirty_vect = new Vector();

//Holds objects with current, but uncommitted changes
RiversideDB_MeasLoc __gui_RTi_MeasLoc = null;
RiversideDB_Geoloc __gui_RTi_GeoLoc = null;

//Flag to indicate if we are running in CAUTIOUS MODE---
//aka, if we prompt the user for confirmation of changes
private boolean __cautious_mode = true;

//DBUser
RiversideDB_DBUser __DBUser = null;
//user write permissions
private boolean __canWriteMeasLoc = false;

private long __db_MeasLoc_num = DMIUtil.MISSING_LONG;

/**
RiversideDB_Location_JFrame constructor.
The constructor is called by an action in one of the JTrees of the
main application.  The main application passes to this class a
RiversideDB_MeasLoc.  This class is called in one of two cases: <br>
<ul><li>to view the properties of a current MeasLoc</li>
<li>to create a new MeasLoc</li></ul>
In the case of viewing a current MeasLoc, the MeasLoc object
passed to this class is already defined and all required properties
already known.  In the case of creating a totally new MeasLoc, the
MeasLoc passed in to this class is essentially an empty skeleton, with
only the MeasLoc object type (AREA vs STATION/POINT) and MeasLocGroup_num
known since they can be attained from the JTree.
It is important to distinguish in the constructor, if we are dealing with
an existing MeasLoc and just changing some of its fields or if
we are creating a totally new MeasLoc.  If the Identifier String
for the MeasLoc passed in is MISSING, then we know that we are
creating a new MeasLoc object.  In the constructor then, set
the <i>__bln_new_object = true </i> flag.  The <b><i>__bln_new_object</i></b>
flag is important because:<br>
<ul>
<li>we can mark the object as dirty (using the <i>setDirty(true)</i> flag)
 since it is an entirely new object</li>
<li>we need to add the fields for <i>DBUser</i>, <i>DBGroup</i>, and
<i>DBPermissions</i> based on the information already known by the DMI for
this user.</li>
<li> we do not have to confirm changes made to a totally new object like we do
if the user is changing an existing object</li>
<li>we need to know to add a new node to the JTree</li></ul>
At this point, whether we are creating a new MeasLoc or modifying an
existing one, we assign the MeasLoc to the variable known throughout
this class as: <b><i>__gui_RTi_MeasLoc</i></b>.  We also set up
the variable known throughout this class as: <b><i>
__gui_RTi_GeoLoc</i></b> which the related GeoLoc object for the MeasLoc.
Also analyzed throughout the class is the Vector of StageDischargeRating
objects that are related to the <i>__gui_RTi_MeasLoc</i>, if it is of
type: Station/ARea.
Finally, the constructor also:<ul><li> sets up Vectors of (static) reference data,
read directly from the database thay will be used throughout the class</li>
<li>calls method: <i>init_layout_GUI()</i> which creates and sets up the
GUI components</li></ul><br>
@param calling_class Instance of RiversideDB_Main_JFrame.
@param dmi Instance of RiversideDB_DMI that has already been opened.
@param title String for title of JFrame.
@param ml RiversideDB_MeasLoc object to display in
this GUI. If a new MeasLoc is being created, the IDENTIFIER String field
will be MISSING.
*/
public RiversideDB_Location_JFrame(
				RiversideDB_DMI dmi,
				RiversideDB_WindowManager windowManager,
				String title,
				RiversideDB_MeasLoc ml )
{
	super( title );

	String routine = __class + ".constructor";

	//add RTi icon logo
	JGUIUtil.setIcon( this, JGUIUtil.getIconImage() );

	// Make global
 	__dmi = dmi;
 	__dmi.setDumpSQLOnError( true );
 	__title = title;
 	__db_RTi_MeasLoc = ml;

 	// Set protected member in the base RiversideDB_EditorBase_JFrame class.
 	_windowManager = windowManager;

	//get system units
 	__system_units = IOUtil.getPropValue("UNITS_SYSTEM");
	if ( __system_units == null ) {
		Message.printWarning( 2, routine,
		"Unable to determine System Units, Will use " +
		"\"ENGL\" units" );
 		__system_units = "ENGL";
	}
	if ( Message.isDebugOn ) {
		Message.printDebug( 5, routine,
		"Units for System are: " + __system_units );
	}
	//get user
	try {
 		__DBUser = __dmi.getDBUser();
	}
	catch ( Exception e ) {
		Message.printWarning( 2, routine, e );
	}

	//read in the MeasLoc vectors fresh here to catch any changes
	try {
 		__RTi_MeasLoc_vect =
 		__dmi.readMeasLocList();
	}
	catch ( Exception e ){
		Message.printWarning( 2, "",e);
 		__RTi_MeasLoc_vect = new Vector();
	}

	//RiversideDB_MeasLoc object passed in will not be null, but if
	//we are creating an entirely new MeasLoc object, the
	//ID will be null

	//assign variable to hold name of Station whose
	//properties you are accessing

 	__preselected_ID_string = __db_RTi_MeasLoc.getIdentifier();

	//if are working on a current MeasLoc (MeasLoc selected in
	//JTree and changing its properties), then the ID will not be null
	if( ( __preselected_ID_string == null ) || ( __preselected_ID_string.
	length() <= 0 ) ) {
		//we are creating a new MeasLoc object to Add to the tree

		//set Flag
 		__bln_new_object = true;
		__originallyNewObject = true;

		//add user permissions
 		__db_RTi_MeasLoc.setDBUser_num( __DBUser.getDBUser_num() );
 		__db_RTi_MeasLoc.setDBGroup_num( __DBUser.getPrimaryDBGroup_num());
 		__db_RTi_MeasLoc.setDBPermissions(
 		__DBUser.getDefault_DBPermissions() );

		//mark it as dirty since it is totally New.
 		__db_RTi_MeasLoc.setDirty( true );
	}
	else {
		__db_MeasLoc_num = ml.getMeasLoc_num();
	}

	//Whether it is a new or old MeasLoc object,
	//must set the Product Type at this point.
	//use the title to find out if it is a
	//"STATION", ie, POINT or if it is an
	//"AREA", ie AREA.
	if  ( __title.indexOf( "Station" ) >= 0 ) {
 		__db_RTi_MeasLoc.setMeas_loc_type( "P" );
	}
	else {
 		__db_RTi_MeasLoc.setMeas_loc_type( "A" );
	}
	//check Write permissions
	try {
 		__canWriteMeasLoc =
 		__dmi.canWrite( __db_RTi_MeasLoc.getDBUser_num(),
 		__db_RTi_MeasLoc.getDBGroup_num(),
 		__db_RTi_MeasLoc.getDBPermissions() );
	}
	catch ( Exception e ) {
		Message.printWarning ( 2, routine, e);
 		__canWriteMeasLoc = false;
	}

	//Get the correct GeoLoc object for that measLoc object.

	//IF we created a new MEASLOC object, the GeoLoc num will be
	//the MISSING value.
	long gl_num_long = -999;
	gl_num_long = __db_RTi_MeasLoc.getGeoloc_num();
	if ( Message.isDebugOn ) {
		Message.printDebug( 25, routine,
		"Geoloc number for selected MeasLoc is: " + gl_num_long );
	}
	if ( DMIUtil.isMissing(gl_num_long) ) {
		//we must be creating a new GeoLoc Object ...
 		__db_RTi_GeoLoc = new RiversideDB_Geoloc();
		//set GeoLoc dirty since it is new
 		__db_RTi_GeoLoc.setDirty( true );
	}
	else if ( gl_num_long > 0 ) {
		//use it to get the right GeoLoc object
		//Vector geoloc objects
		try {
 			__db_RTi_GeoLoc = __dmi.
			readGeolocForGeoloc_num( gl_num_long );
		}
		catch ( Exception e ) {
			Message.printWarning( 2, routine, e );
		}
	}//end if gl_num >0

	//Fill in Proplist for Worksheet
	//make the Project Worksheet and put in...
 	__worksheet_PropList = new PropList(
	"RTAdminAssistant.JWorksheet");
 	__worksheet_PropList.add("JWorksheet.CellFontName=Courier");
 	__worksheet_PropList.add("JWorksheet.CellFontStyle=Plain");
 	__worksheet_PropList.add("JWorksheet.CellFontSize=11");
 	__worksheet_PropList.add("JWorksheet.ColumnHeaderFontName=Arial");
 	__worksheet_PropList.add("JWorksheet.ColumnHeaderFontStyle=Plain");
 	__worksheet_PropList.add("JWorksheet.ColumnHeaderFontSize=11");
 	__worksheet_PropList.add("JWorksheet.ColumnHeaderBackground=LightGray");
 	__worksheet_PropList.add("JWorksheet.ShowRowHeader=false");
 	__worksheet_PropList.add("JWorksheet.ShowPopupMenu=true");
 	__worksheet_PropList.add("JWorksheet.SelectionMode=ExcelSelection");
 	__worksheet_PropList.add("JWorksheet.AllowCopy=True");
 	__worksheet_PropList.add("JWorksheet.AllowPaste=True");

	//get the related StageDischargeRating Vector of objects
	//(returns sorted by start_date DESC in the DMI)
	//get the StageDischargeRating object via the MeasLoc
	//FIlls __stageDischargeRating_vect and
	//_ratingTable_worksheet_vect vectors!
	fillStageDischargeRatingAndRatingTable_vectors( true );

	// create/layout the GUI ...
	//Assign the shared variables used for layouts
	//layout manager is GridBagLayout
 	__gridbag = new GridBagLayout();

	//Insets order: top, left, bottom, right
 	__insets = new Insets( 2, 2, 2, 2);

	//layout GUI
	init_layout_GUI( );

	//add window listener
	addWindowListener ( this );

	//setup frame to do nothing on close so that we can take over
	//control of window events.
	setDefaultCloseOperation( JFrame.DO_NOTHING_ON_CLOSE );

	setResizable( false );
}

/**
Method to add components to the area tab.  Currently not implemented.
@return JPanel with all the components.
*/
public JPanel assemble_tab_area() {
	String routine = __class + ".assemble_tab_area";

	JPanel area_JPanel = new JPanel();
	area_JPanel.setLayout( __gridbag );

	JLabel area_tab_info_JLabel = new JLabel(
 	__area_tab_info_JLabel_string );

	JLabel area_tab_num_JLabel = new JLabel( "Number:" );
 	__area_tab_num_JTextField = new JTextField(10);
 	JGUIUtil.setEnabled( __area_tab_num_JTextField, false );

	JLabel area_tab_id_JLabel = new JLabel( "Identifier:" );
 	__area_tab_id_JTextField = new JTextField(10);
 	JGUIUtil.setEnabled( __area_tab_id_JTextField, false );

	JLabel area_tab_name_JLabel = new JLabel(
 	"Name: ");
 	__area_tab_name_JTextField = new JTextField(10);
 	JGUIUtil.setEnabled( __area_tab_name_JTextField, false );

	JLabel area_tab_area_JLabel = new JLabel( "Area:");
 	__area_tab_area_JTextField = new JTextField(10);
 	JGUIUtil.setEnabled( __area_tab_area_JTextField, false );

	//vector of units used for area.
	String system_units = null;
	system_units = IOUtil.getPropValue( "UNITS_SYSTEM" );
	if ( Message.isDebugOn ) {
		Message.printDebug( 2, routine, "System units set to: \"" + system_units +"\"" );
	}

	List units_vect = new Vector();
	//get units for areas
	List v = DataUnits.lookupUnitsForDimension( __system_units, "L2" );
	int size = 0;
	if ( v != null ) {
		size = v.size();
	}
	DataUnits du = null;
	for ( int i=0; i< size; i++ ) {
		du = (DataUnits)v.get(i);
		units_vect.add( du.getAbbreviation() + " - " + du.getLongName() );
	}
	if ( size == 0 ) {
		units_vect.add( "      " );
	}
	//now sort the units
	List sorted_units_vect = null;
	sorted_units_vect = StringUtil.sortStringList( units_vect,
		StringUtil.SORT_ASCENDING, null, false, true );
	units_vect = null;
	if ( sorted_units_vect == null ) {
		sorted_units_vect = new Vector();
	}

 	__area_tab_units_JComboBox = new SimpleJComboBox( sorted_units_vect );
 	JGUIUtil.setEnabled( __area_tab_units_JComboBox,false);

	try {
		int y =0;
		int x =0;
		JGUIUtil.addComponent(
			area_JPanel, area_tab_info_JLabel,
			x, y, 2, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.WEST );

		JGUIUtil.addComponent(
			area_JPanel, area_tab_num_JLabel,
			x, ++y, 1, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.EAST );

		JGUIUtil.addComponent(
			area_JPanel, __area_tab_num_JTextField,
			++x, y, 1, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.WEST );

		JGUIUtil.addComponent(
			area_JPanel, area_tab_id_JLabel,
			--x, ++y, 1, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.EAST );

		JGUIUtil.addComponent(
			area_JPanel, __area_tab_id_JTextField,
			++x, y, 1, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.WEST );

		JGUIUtil.addComponent(
			area_JPanel, area_tab_name_JLabel,
			--x, ++y, 1, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.EAST );

		JGUIUtil.addComponent(
			area_JPanel, __area_tab_name_JTextField,
			++x, y, 1, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.WEST );

		x=0;
		JGUIUtil.addComponent(
			area_JPanel, area_tab_area_JLabel,
			x, ++y, 1, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.EAST );

		JGUIUtil.addComponent(
			area_JPanel, __area_tab_area_JTextField,
			++x, y, 1, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.WEST );

		JGUIUtil.addComponent(
			area_JPanel, __area_tab_units_JComboBox,
			++x, y, 1, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.WEST );
	}
	catch (Exception e ) {
		Message.printWarning( 2, routine, e );
		Message.printWarning( 2, routine,
		"Error laying out AREA tab" );
	}

	return area_JPanel;

} //end assemble_tab_area

/**
Method adds all the components to a JPanel for the Geographic Data tab.
The data for this tab comes from the GeoLoc object.
@return JPanel with all the components.
*/
public JPanel assemble_tab_geographic() {
	String routine = __class + ".assemble_tab_geographic";

	JPanel geog_JPanel = new JPanel();
	geog_JPanel.setLayout( __gridbag );

	//components
	//info
	JLabel geog_tab_info_JLabel = new JLabel( "Specify geographical data");

	//LATITUDE
	JLabel geog_tab_latitude_JLabel = new JLabel( "Latitude:" );
	geog_tab_latitude_JLabel.setToolTipText("Latitude coordinate in Decimal Degrees (optional)");

 	__geog_tab_latitude_JTextField = new JTextField( 10 );

	JLabel geog_tab_latitude_units_JLabel = new JLabel( "Dec. Deg." );

	//LONGITUDE
	JLabel geog_tab_longitude_JLabel = new JLabel( "Longitude: ");
	geog_tab_longitude_JLabel.setToolTipText("Longitude coordinate in Decimal Degrees (optional)");
 	__geog_tab_longitude_JTextField = new JTextField( 10 );
	JLabel geog_tab_longitude_units_JLabel = new JLabel( "Dec. Deg." );

	// X POINT
	JLabel geog_tab_x_JLabel = new JLabel( "X:" );
	geog_tab_x_JLabel.setToolTipText("X coordinate in projected units (optional)");

 	__geog_tab_x_JTextField = new JTextField( 10 );

	// Y POINT
	JLabel geog_tab_y_JLabel = new JLabel( "Y:");
	geog_tab_y_JLabel.setToolTipText("Y coordinate in projected units (optional)");

 	__geog_tab_y_JTextField = new JTextField( 10 );

	//COUNTRY
	JLabel geog_tab_country_JLabel = new JLabel( "Country: ");
	geog_tab_country_JLabel.setToolTipText("Country name or abbreviation (optional)" );

 	__geog_tab_country_JTextField = new JTextField( 15 );

	//STATE
	JLabel geog_tab_state_JLabel = new JLabel( "State: " );
	geog_tab_state_JLabel.setToolTipText("State name or abbreviation (optional)" );

 	__geog_tab_state_JTextField = new JTextField( 15 );

	//PROVINCE
	JLabel geog_tab_county_JLabel = new JLabel( "County/Province: " );
	geog_tab_county_JLabel.setToolTipText("County/Province name or abbreviation (optional)" );

 	__geog_tab_county_JTextField = new JTextField( 15 );

	//ELEVATION
	JLabel geog_tab_elevation_JLabel = new JLabel( "Elevation:");
	geog_tab_elevation_JLabel.setToolTipText("Elevation of location (optional)" );

 	__geog_tab_elevation_JTextField = new JTextField( 10 );

	//UNITS
	JLabel geog_tab_units_JLabel = new JLabel( "Elev. Units:" );
	geog_tab_units_JLabel.setToolTipText("Units for elevation of location (required if elevation filled in)" );

	List units_vect = new Vector();
	List v = DataUnits.lookupUnitsForDimension( __system_units, "L" );
	int size = 0;
	if ( v != null ) {
		size = v.size();
	}
	if ( Message.isDebugOn ) {
		Message.printDebug( 40, routine,
		"Size of units vector for Geography " +
		"Tab Elevation units is " + size );
	}
	DataUnits du = null;
	for ( int i=0; i< size; i++ ) {
		du = (DataUnits)v.get(i);
		units_vect.add( du.getAbbreviation() + " - " + du.getLongName() );
	}
	v = null;
	//now sort vector alphabetically
	List sorted_units_vect = null;
	sorted_units_vect = StringUtil.sortStringList( units_vect,
	StringUtil.SORT_ASCENDING, null, false, true );
	units_vect = null;

	if ( sorted_units_vect == null ) {
		sorted_units_vect = new Vector();
	}

	//make UNITS JCOMBOBOX!
 	__geog_tab_units_JComboBox = new SimpleJComboBox( sorted_units_vect );

	//assemble components
	try {
		int y = 0; //row number
		int x = 0;
		//Info
		JGUIUtil.addComponent(
			geog_JPanel, geog_tab_info_JLabel,
			x, y, 3, 1, 0.0, 0.0, __insets,
			GridBagConstraints.CENTER,
			GridBagConstraints.WEST );

		//LONGITUDE
		JGUIUtil.addComponent(
			geog_JPanel, geog_tab_longitude_JLabel,
			x, ++y, 1, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.EAST );

		JGUIUtil.addComponent(
			geog_JPanel, __geog_tab_longitude_JTextField,
			++x, y, 1, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.WEST );

		//LONGITUDE units
		JGUIUtil.addComponent(
			geog_JPanel, geog_tab_longitude_units_JLabel,
			++x, y, 1, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.WEST );

		//LATITUDE
		JGUIUtil.addComponent(
			geog_JPanel, geog_tab_latitude_JLabel,
			++x, y, 2, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.EAST );

		++x;
		JGUIUtil.addComponent(
			geog_JPanel, __geog_tab_latitude_JTextField,
			++x, y, 1, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.WEST );

		//LATITUDE units
		JGUIUtil.addComponent(
			geog_JPanel, geog_tab_latitude_units_JLabel,
			++x, y, 1, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.WEST );

		x=0;
		JGUIUtil.addComponent(
			geog_JPanel, geog_tab_x_JLabel,
			x, ++y, 1, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.EAST );

		JGUIUtil.addComponent(
			geog_JPanel, __geog_tab_x_JTextField,
			++x, y, 2, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.WEST );

		++x;
		JGUIUtil.addComponent(
			geog_JPanel, geog_tab_y_JLabel,
			++x, y, 2, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.EAST );

		++x;
		JGUIUtil.addComponent(
			geog_JPanel, __geog_tab_y_JTextField,
			++x, y, 2, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.WEST );

		//COUNTRY
		x=0;
		JGUIUtil.addComponent(
			geog_JPanel, geog_tab_country_JLabel,
			x, ++y, 1, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.EAST );

		JGUIUtil.addComponent(
			geog_JPanel, __geog_tab_country_JTextField,
			++x, y, 2, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.WEST );

		++x;
		//STATE
		JGUIUtil.addComponent(
			geog_JPanel, geog_tab_state_JLabel,
			++x, y, 2, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.EAST );

		++x;
		JGUIUtil.addComponent(
			geog_JPanel, __geog_tab_state_JTextField,
			++x, y, 2, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.WEST );

		x=0;
		//City/PROVINCE
		JGUIUtil.addComponent(
			geog_JPanel, geog_tab_county_JLabel,
			x, ++y, 1, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.EAST );

		JGUIUtil.addComponent(
			geog_JPanel, __geog_tab_county_JTextField,
			++x, y, 2, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.WEST );

		//ELEVATION
		x=0;
		JGUIUtil.addComponent(
			geog_JPanel, geog_tab_elevation_JLabel,
			x, ++y, 1, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.EAST );

		JGUIUtil.addComponent(
			geog_JPanel, __geog_tab_elevation_JTextField,
			++x, y, 1, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.WEST );

		//UNITS
		JGUIUtil.addComponent(
			geog_JPanel, geog_tab_units_JLabel,
			++x, y, 2, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.EAST );

		++x;
		JGUIUtil.addComponent(
			geog_JPanel, __geog_tab_units_JComboBox,
			++x, y, 3, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.WEST );
	}
	catch ( Exception e ) {
		Message.printWarning( 2, routine, e );
		Message.printWarning( 2, routine,
			"Error laying out \"Geographic Data\" tab." );
	}
	return geog_JPanel;
} //end assemble_tab_geographic

/**
Method to add components to the Ratings tab. The data is related to
StageDischargeRating objects.
@return JPanel with all the components.
*/
public JPanel assemble_tab_rating() {
	String routine = __class + ".assemble_tab_rating";

	JPanel rating_JPanel = new JPanel();
	rating_JPanel.setLayout( __gridbag );

	JLabel rating_tab_info_JLabel = new JLabel(
	"Specify Rating Curve data: " );

	// "Select Date Range";
	JLabel rating_tab_dates_JLabel = new JLabel( "Select Date Range:" );
	rating_tab_dates_JLabel.setToolTipText("Choose date range for Rating operation");

	//get Date ranges -sorted in reverse order so latest is first
 	__rating_tab_dates_model = new DefaultComboBoxModel();
 	__rating_tab_dates_JComboBox = new JComboBox( __rating_tab_dates_model );
 	__rating_tab_dates_JComboBox.addItemListener( this );

	//"Add Date Range";
 	__rating_tab_add_dates_JButton =new SimpleJButton(
	"Add Date Range", this );
 	__rating_tab_add_dates_JButton.setToolTipText("Add new date range for Rating operation");

	//"Gage Zero Datum"; -Label, JtextField, and JComboBox for units
	JLabel rating_tab_datum_JLabel = new JLabel( "Gage Zero Datum: " );
		rating_tab_datum_JLabel.setToolTipText("Add value for Zero Datum Elevation");
 	__rating_tab_datum_JTextField =new JTextField( 5 );

	//get units for LENGTH
	List length_units_vect = new Vector();
	//get units for lengths
	List v = DataUnits.lookupUnitsForDimension( __system_units, "L" );
	int size = 0;
	if ( v != null ) {
		size = v.size();
	}
	DataUnits du = null;
	for ( int i=0; i< size; i++ ) {
		du = (DataUnits)v.get(i);
		if ( du == null ) {
			continue;
		}
		length_units_vect.add( du.getAbbreviation() +
		" - " + du.getLongName() );
		du = null;
	}
	if ( size == 0 ) {
		length_units_vect.add( "      " );
	}
	//now sort the units
	List sorted_length_units_vect = null;
	sorted_length_units_vect = StringUtil.sortStringList( length_units_vect,
		StringUtil.SORT_ASCENDING, null, false, true );
	length_units_vect = null;
	if ( sorted_length_units_vect == null ) {
		sorted_length_units_vect = new Vector();
	}

 	__rating_tab_datum_units_JComboBox =new SimpleJComboBox(
	sorted_length_units_vect);
 	__rating_tab_datum_units_JComboBox.setToolTipText("Select units for Datum Elevation");

	//"Warning Stage";
	JLabel rating_tab_warning_stage_JLabel = new JLabel( "Warning Stage:");
	rating_tab_warning_stage_JLabel.setToolTipText("Add value for Warning Stage" );
 	__rating_tab_warning_stage_JTextField =new JTextField( 5 );

	//"Flood Stage";
	JLabel rating_tab_flood_stage_JLabel = new JLabel( "Flood Stage:" );
	rating_tab_flood_stage_JLabel.setToolTipText("Add value for Flood Stage" );
 	__rating_tab_flood_stage_JTextField =new JTextField( 5 );

	//"Interpoloation method";
	List interpol_vect = new Vector();
	interpol_vect.add( "LINEAR" );
	interpol_vect.add( "LOGARITHMIC" );
	JLabel rating_tab_interpol_JLabel = new JLabel( "Interpolation Method: " );
	rating_tab_interpol_JLabel.setToolTipText("Choose Interpolation method");
 	__rating_tab_interpol_JComboBox =new SimpleJComboBox( interpol_vect );

	//"Stage Units";
	JLabel rating_tab_stage_units_JLabel = new JLabel( "Stage Units:" );
	rating_tab_stage_units_JLabel.setToolTipText("Select units for Stage" );
 	__rating_tab_stage_units_JComboBox =new SimpleJComboBox(
	sorted_length_units_vect);

	//"Discharge Units";
	//get units for FLOW
	List flow_units_vect = new Vector();
	//get units for flow_
	v = null;
	v = DataUnits.lookupUnitsForDimension( __system_units, "L3/T" );
	size = 0;
	if ( v != null ) {
		size = v.size();
	}
	du = null;
	for ( int i=0; i< size; i++ ) {
		du = (DataUnits)v.get(i);
		if ( du == null ) {
			continue;
		}
		flow_units_vect.add( du.getAbbreviation() +
		" - " + du.getLongName() );
		du = null;
	}
	if ( size == 0 ) {
		flow_units_vect.add( "      " );
	}
	//now sort the units
	List sorted_flow_units_vect = null;
	sorted_flow_units_vect = StringUtil.sortStringList( flow_units_vect,
		StringUtil.SORT_ASCENDING, null, false, true );
	flow_units_vect = null;
	if ( sorted_flow_units_vect == null ) {
		sorted_flow_units_vect = new Vector();
	}
	JLabel rating_tab_discharge_units_JLabel = new JLabel( "Discharge Units:");
	rating_tab_discharge_units_JLabel.setToolTipText("Select units for discharge" );
 	__rating_tab_discharge_units_JComboBox =new SimpleJComboBox(
	sorted_flow_units_vect );

	//make JPanel to hold worksheet and 3 buttons: add, delete, edit
	JPanel worksheet_JPanel = new JPanel();
	worksheet_JPanel.setLayout( __gridbag );

	Border border = BorderFactory.createLineBorder(Color.black);
	TitledBorder titled_border = BorderFactory.createTitledBorder(
	border,"Ratings" );
	/*
	TitledBorder titled_border = BorderFactory.createTitledBorder(
		border, "Ratings", TitledBorder.TOP,
		TitledBorder.CENTER );
		*/


	worksheet_JPanel.setBorder( titled_border);
	//worksheet_JPanel.setBorder( BorderFactory.createLineBorder(
	//Color.black ) );
	worksheet_JPanel.setToolTipText("Add values for Ratings" );

	try {
 		__rating_JWorksheet = new JWorksheet(
		0, 0, __worksheet_PropList );
		//make empty worksheet - will be filled in by "update" method
	}
	catch (Exception e) {
		Message.printWarning(2, routine, e);
 		__rating_JWorksheet = new JWorksheet(
		0, 0, __worksheet_PropList );
	}
 	__rating_JWorksheet.setToolTipText("Add, Edit, and Delete Rating values");
	//set worksheet so it is known to TableModel and can
	//set is dirty!
	//tm.setWorksheet( __rating_JWorksheet );

 	__rating_worksheet_JScrollPane = new JScrollPane (
 	__rating_JWorksheet );
 	__rating_worksheet_JScrollPane.setPreferredSize( __worksheet_dim );
 	__rating_worksheet_JScrollPane.setMinimumSize( __worksheet_dim );
 	__rating_worksheet_JScrollPane.setMaximumSize( __worksheet_dim );

	//"Add Rating Data" JButton
 	__rating_tab_rating_add_JButton = new SimpleJButton(
	"Add Rating Data", this );
 	__rating_tab_rating_add_JButton.setToolTipText("Add a new line to worksheet to add new data values" );

	//"Delete Rating Data" JButton
 	__rating_tab_rating_delete_JButton = new SimpleJButton(
	"Delete Rating Data", this );
 	__rating_tab_rating_delete_JButton.setToolTipText("Delete selected line in worksheet" );

	//"Edit Rating Data" JButton
 	__rating_tab_rating_edit_JButton = new SimpleJButton(
	"Edit Rating Data", this );

	//Assemble worksheet subpanel
	try {
		int x=0;
		int y=0;
		JGUIUtil.addComponent(
			worksheet_JPanel, __rating_worksheet_JScrollPane,
			x, y, 1, 3, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.WEST );
		JGUIUtil.addComponent(
			worksheet_JPanel, __rating_tab_rating_add_JButton,
			++x, y, 1, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.WEST );
		JGUIUtil.addComponent(
			worksheet_JPanel, __rating_tab_rating_delete_JButton,
			x, ++y, 1, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.WEST );
		/*
		JGUIUtil.addComponent(
			worksheet_JPanel, __rating_tab_rating_edit_JButton,
			x, ++y, 1, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.WEST );
			*/
	}
	catch ( Exception e ) {
		Message.printWarning( 2, routine, e );
		Message.printWarning( 2, routine,
		"Error laying out worksheet part of Rating Tab." );
	}

	//Asseble overall panel
	try {
		int x=0;
		int y=0;
		JGUIUtil.addComponent(
			rating_JPanel, rating_tab_info_JLabel,
			x, y, 2, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.WEST );

		JGUIUtil.addComponent(
			rating_JPanel, rating_tab_dates_JLabel,
			x, ++y, 1, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.EAST );
		JGUIUtil.addComponent(
			rating_JPanel, __rating_tab_dates_JComboBox,
			++x, y, 5, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.WEST );
		++x;
		++x;
		JGUIUtil.addComponent(
			rating_JPanel, __rating_tab_add_dates_JButton,
			++x, y, 2, 1, 0.0, 0.0, __insets,
			GridBagConstraints.HORIZONTAL,
			GridBagConstraints.EAST );

		x=0;
		JGUIUtil.addComponent(
			rating_JPanel, rating_tab_datum_JLabel,
			x, ++y, 1, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.EAST );
		JGUIUtil.addComponent(
			rating_JPanel, __rating_tab_datum_JTextField,
			++x, y, 1, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.WEST );
		JGUIUtil.addComponent(
			rating_JPanel, __rating_tab_datum_units_JComboBox,
			++x, y, 2, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.WEST );

		x=0;
		JGUIUtil.addComponent(
			rating_JPanel, rating_tab_warning_stage_JLabel,
			x, ++y, 1, 1, 0.0, 0.0, __insets,
			GridBagConstraints.CENTER,
			GridBagConstraints.EAST );
			//GridBagConstraints.WEST );
		JGUIUtil.addComponent(
			rating_JPanel, __rating_tab_warning_stage_JTextField,
			++x, y, 1, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.WEST );
			//GridBagConstraints.EAST );

		//x=0;
		JGUIUtil.addComponent(
			rating_JPanel, rating_tab_flood_stage_JLabel,
			++x, y, 1, 1, 0.0, 0.0, __insets,
			GridBagConstraints.CENTER,
			GridBagConstraints.EAST );
		JGUIUtil.addComponent(
			rating_JPanel, __rating_tab_flood_stage_JTextField,
			++x, y, 1, 1, 0.0, 0.0, __insets,
			//++x, y, 1, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.WEST );

		JGUIUtil.addComponent(
			rating_JPanel, rating_tab_interpol_JLabel,
			++x, y, 1, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.EAST );

		JGUIUtil.addComponent(
			rating_JPanel, __rating_tab_interpol_JComboBox,
			++x, y, 1, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.WEST );

		x=0;
		JGUIUtil.addComponent(
			rating_JPanel, rating_tab_stage_units_JLabel,
			x, ++y, 1, 1, 0.0, 0.0, __insets,
			GridBagConstraints.CENTER,
			GridBagConstraints.EAST );
		JGUIUtil.addComponent(
			rating_JPanel, __rating_tab_stage_units_JComboBox,
			++x, y, 3, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.WEST );
		/*
		++x;
		++x;
		JGUIUtil.addComponent(
			rating_JPanel, worksheet_JPanel,
			++x, y, 4, 3, 0.0, 0.0, __insets,
			GridBagConstraints.BOTH,
			GridBagConstraints.WEST );
		*/

		x=0;
		JGUIUtil.addComponent(
			rating_JPanel, rating_tab_discharge_units_JLabel,
			x, ++y, 1, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.EAST );
		JGUIUtil.addComponent(
			rating_JPanel, __rating_tab_discharge_units_JComboBox,
			++x, y, 3, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.WEST );

		/*
		x=0;
		JGUIUtil.addComponent(
			rating_JPanel, rating_tab_interpol_JLabel,
			x, ++y, 1, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.EAST );
		JGUIUtil.addComponent(
			rating_JPanel, __rating_tab_interpol_JComboBox,
			++x, y, 3, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.WEST );
		*/


		x=0;
		JGUIUtil.addComponent(
			rating_JPanel, worksheet_JPanel,
			x, ++y, 7, 1, 0.0, 0.0, __insets,
			GridBagConstraints.BOTH,
			GridBagConstraints.WEST );

	}
	catch ( Exception e ) {
		Message.printWarning( 2, routine, e );
		Message.printWarning( 2, routine,
		"Error laying out Rating Tab." );
	}


	//set Strings in GUI
	if ( __stageDischargeRating_vect.size() <=0 ) {
		//gray out fields.
 		JGUIUtil.setEnabled( __rating_tab_dates_JComboBox, false );
 		JGUIUtil.setEnabled( __rating_tab_datum_JTextField,false);
 		JGUIUtil.setEnabled(
		__rating_tab_warning_stage_JTextField, false);
 		JGUIUtil.setEnabled(
		__rating_tab_flood_stage_JTextField, false);

 		__rating_JWorksheet.setBackground(Color.lightGray);
	}


	return rating_JPanel;
}//end assemble_tab_rating

/**
Method to add components to the station tab.  Currently not implemented.
@return JPanel with all the components.
*/
public JPanel assemble_tab_station() {
	String routine = __class + ".assemble_tab_station";

	JPanel station_JPanel = new JPanel();
	station_JPanel.setLayout( __gridbag );

	//"UNAVAILABLE CURRENTLY"
	JLabel station_tab_info_JLabel = new JLabel(
	"Specify Station Information- UNAVAILABLE" ) ;

	try {
		int y =0;
		JGUIUtil.addComponent(
			station_JPanel, station_tab_info_JLabel,
			0, y, 2, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.WEST );
	}
	catch (Exception e ) {
		Message.printWarning( 2, routine, e );
		Message.printWarning( 2, routine,
		"Error laying out STATION tab" );
	}

	return station_JPanel;

} //end assemble_tab_station

/**
This method simply goes through all the fields in the GUI and checks that
each fields is: <ul> <li>filled in if it is a required field </li>
<li>contains valid values (for JTextFields, for example)</li>
</ul>If an invalid entry is encountered, the method displays a warning message,
indicating the fields with invalid values. (Prints one error message at the end indicating any fields that need to
be filled in before a save can occur.)
</ul>
@exception Exception thrown if a required filled does not
have a value.
*/
protected void checkRequiredInput() throws Exception {

	String gui_id= null;
	gui_id = __station_id_JTextField.getText();

	StringBuffer buffer = new StringBuffer();

	if (( gui_id == null ) || ( gui_id.length() <=0 )) {
		buffer.append( "Unable to save without \"IDENTIFIER\". \n" );
	}

	String gui_name = null;
	gui_name = __station_name_JTextField.getText();
	if (( gui_name == null ) || ( gui_name.length() <=0 )) {
		buffer.append( "Unable to save without \"NAME\". \n" );
	}

	//Source can't be null because in JComboBox.
	//Type can't be null because is non-editable

	//Rating Tab
	if ( __db_RTi_MeasLoc.getMeas_loc_type().equalsIgnoreCase( "P" ) ) {

		if ( __rating_tab_dates_model.getSize() > 0 ) {
			StringBuffer b = null;
			b = checkRequiredInput_ratingTab();

			if ( b.length() > 0 ) {
				buffer.append( b );
			}
		}
	}

	//check length of StringBuffer.
	//If it is longer than 0, then add final statement
	//and printWarning
	if ( buffer.length() >0 ) {
		buffer.append( "Please specify all required fields or cancel." );
		JOptionPane.showMessageDialog( this,
		buffer.toString(), "Warning", JOptionPane.WARNING_MESSAGE);

		throw new Exception (
		"Please specify all required fields or cancel." );
	}
	buffer = null;

}//end checkRequiredInput

/**
Checks that JTextFields in the Ratings Tab have Numeric entries
*/
protected StringBuffer checkRequiredInput_ratingTab() throws Exception {

	StringBuffer buffer = new StringBuffer();

	//Gage Datum
	String datum_str = null;
	datum_str = __rating_tab_datum_JTextField.getText();
	if( ( datum_str.length() <= 0 ) ||
	( !StringUtil.isDouble( datum_str )  ) ) {
		buffer.append( "\"Gage Zero Datum\" value must be numeric.\n" );
	}
	//Warning Stage
	String warn_str = null;
	warn_str = __rating_tab_warning_stage_JTextField.getText();
	if( ( warn_str.length() <= 0 ) ||
	( !StringUtil.isDouble( warn_str )  ) ) {
		buffer.append( "\"Warning Stage\" value must be numeric.\n" );
	}
	//Flood Stage
	String flood_str = null;
	flood_str = __rating_tab_flood_stage_JTextField.getText();
	if( ( flood_str.length() <= 0 ) ||
	( !StringUtil.isDouble( flood_str )  ) ) {
		buffer.append( "\"Flood Stage\" value must be numeric.\n" );
	}

	return buffer;
}//end checkRequiredInput_ratingTab()

/**
This method does the following:<ul>
<li>calls <i>checkRequiredInput</i> which makes sure all the required fields in the GUI are filled out and have valid entries</li>
<li>calls <i>update_RiversideDB_objects</i> which is called to
<b>create</b> and update the <i><b>__gui_RTi_MeasLoc</b></i> and
<i> <b>__gui_RTi_GeoLoc</b></i> objects in memory, mark them dirty,
and add messages to the <i>__dirty_vect</i> Vector.</li>  <li>Also analyzed
is any changes to the Vector of relating <i>StageDischargeRating</i> objects,
if there StageDischargeRating objects associated with this MeasLoc</li>
<li>creates a confirmation message if the <i>__gui</i> versions are dirty,
prompting the user to verify if they want to save their changes
(all the changes are listed out from the <i>__dirty_vect</i>)</li>
<li>updates the database by calling, <i>update_database</i></li>
<li>closes the GUI and destroys it</li>
</ul>
*/
public void closeGUI( ) {
	String routine = __class + ".closeGUI";
	boolean blnUpdated=true;
	//Required fields
	try {
		checkRequiredInput(); //this will print out
	//any errors it finds.
	}
	catch ( Exception e ) {
		//then there was an error so do not
		//update object in memory or in database.
		Message.printWarning( 2, routine, e );

		blnUpdated= false;
	}

	//update the object in memory
	if ( blnUpdated ) {

		//update objects in memory whether closing or just cancelling
		try {
			update_RiversideDB_objects();
		}
		catch( Exception e ) {
			Message.printWarning( 2, routine, e );
			blnUpdated=false;
		}
	}

	boolean sdr_dirty = false;
	if ( __db_RTi_MeasLoc.getMeas_loc_type().equalsIgnoreCase( "P" ) ) {
		//go through vector StageDischargeRating objects to see if it is
		//dirty.
		int numb_sdr = __stageDischargeRating_vect.size();
		RiversideDB_StageDischargeRating sdr =null;
		for ( int i=0;i<numb_sdr;i++ ) {
			sdr = (RiversideDB_StageDischargeRating)
 			__stageDischargeRating_vect.get(i);
			if ( sdr == null ) {
				continue;
			}
			if ( sdr.isDirty() ) {
				sdr_dirty = true;
				break;
			}
		}
	}

	if( blnUpdated)  {
		if(( __gui_RTi_GeoLoc.isDirty()) ||
 		__gui_RTi_MeasLoc.isDirty() || sdr_dirty )   {

			//prompt user if they want to save their
			//changes to the database.
			int x = 0;
			x = new ResponseJDialog ( this,
				"Save changes",
				"Save your changes before closing?",
				ResponseJDialog.YES | ResponseJDialog.NO
				| ResponseJDialog.CANCEL).response();

			if ( x == ResponseJDialog.YES ) {
				//update database itself
				try {
					//update database itself
					update_database();
					//this method (update_database)
					//will print out messages
					//listing all the changes
					//before save occurs.

				}
				catch( Exception e ) {
					Message.printWarning( 2,
					routine, e );
					blnUpdated=false;
				}

				windowManagerClose();
			}
			else if ( x == ResponseJDialog.NO ) {
				windowManagerClose();
			}
		}
		else { //no changes, so just close.
			windowManagerClose();
		}
	}
	/*
	else { //we have not updated the objects in memory
		if ( ! blnUpdated ) {
			//FIlls __stageDischargeRating_vect and
			//_ratingTable_worksheet_vect vectors!
			fillStageDischargeRatingAndRatingTable_vectors();

			windowManagerClose();
		}
	}
	*/

} //end closeGUI

/**
Puts together a JDialog that allows the user to set Start and End
dates for Rating (stagedischargerating) operation.
@return JDialog with all GUI controls in it.
*/
protected JDialog createNewDatesJDialog( ) {
	String routine = __class + ".createNewDatesJDialog";
	//pass in this JFrame so that the dialog will inherit and
	//use the icon.
	JDialog d = new JDialog( this );
	d.setTitle( "RiverTrak Assistant - Create Start and End Dates for Ratings" );
	JPanel p = new JPanel();
	p.setLayout( __gridbag);

	//Labels for start and end dates
	JLabel start_JLabel = new JLabel( "Start Date:");
	JLabel end_JLabel = new JLabel( "End Date:");

	//Labels for YEAR, MONTH, DAY, HOUR, MINUTE
	JLabel YYYY_JLabel = new JLabel( "YYYY" );
	JLabel MM_JLabel = new JLabel( "MM" );
	JLabel DD_JLabel = new JLabel( "DD" );
	JLabel HH_JLabel = new JLabel( "HH" );
	JLabel mm_JLabel = new JLabel( "mm" );

	//JComboBoxes themselves
	//YYYY
 	__rating_tab_popup_start_YYYY_JTextField = new JTextField(5);
 	__rating_tab_popup_end_YYYY_JTextField = new JTextField(5);
	//MM
	List months_vect = new Vector();
	for ( int i=1; i<13; i++ ) {
		months_vect.add( StringUtil.formatString (
		String.valueOf( i ), "%02d") );
	}
 	__rating_tab_popup_start_MM_JComboBox = new SimpleJComboBox( months_vect );
 	__rating_tab_popup_end_MM_JComboBox = new SimpleJComboBox( months_vect );

	//DD
	List days_vect = new Vector();
	for ( int i=1; i<31; i++ ) {
		days_vect.add( StringUtil.formatString (
		String.valueOf( i ), "%02d") );
	}
 	__rating_tab_popup_start_DD_model = new DefaultComboBoxModel(new Vector(days_vect));
 	__rating_tab_popup_end_DD_model = new DefaultComboBoxModel(new Vector(days_vect));
 	__rating_tab_popup_start_DD_JComboBox = new JComboBox(
 	__rating_tab_popup_start_DD_model );
 	__rating_tab_popup_end_DD_JComboBox = new JComboBox(
 	__rating_tab_popup_end_DD_model );

	//HH
	List hours_vect = new Vector();
	for ( int i=1; i<25; i++ ) {
		hours_vect.add( StringUtil.formatString (
		String.valueOf( i ), "%02d") );
	}
 	__rating_tab_popup_start_HH_JComboBox = new SimpleJComboBox( hours_vect );
 	__rating_tab_popup_end_HH_JComboBox = new SimpleJComboBox( hours_vect );

	//mm
	List min_vect = new Vector();
	for ( int i=1; i<61; i++ ) {
		min_vect.add( StringUtil.formatString (
		String.valueOf( i ), "%02d") );
	}
 	__rating_tab_popup_start_mm_JComboBox = new SimpleJComboBox( min_vect );
 	__rating_tab_popup_end_mm_JComboBox = new SimpleJComboBox( min_vect );

	//update fields as needed.
	//set Start Date to current time
	DateTime sd = new DateTime( DateTime.DATE_CURRENT );
 	__rating_tab_popup_start_YYYY_JTextField.setText( String.valueOf(
	sd.getYear() ) );
 	__rating_tab_popup_start_DD_JComboBox.setSelectedItem(
	(StringUtil.formatString( sd.getDay(), "%02d" ) ) );
 	__rating_tab_popup_start_MM_JComboBox.setSelectedItem(
	(StringUtil.formatString( sd.getMonth(), "%02d" ) ) );
 	__rating_tab_popup_start_HH_JComboBox.setSelectedItem(
	(StringUtil.formatString( sd.getHour(), "%02d" ) ) );
 	__rating_tab_popup_start_mm_JComboBox.setSelectedItem(
	(StringUtil.formatString( sd.getMinute(), "%02d" ) ) );

	sd = null;
	//set End date to 12-31-9999 00:00
 	__rating_tab_popup_end_YYYY_JTextField.setText( "9999");
 	__rating_tab_popup_end_DD_JComboBox.setSelectedItem( "31");
 	__rating_tab_popup_end_MM_JComboBox.setSelectedItem( "12");

	//canel and ok buttons
 	__rating_tab_popup_ok_JButton = new SimpleJButton( "OK", this );
 	__rating_tab_popup_cancel_JButton = new SimpleJButton( "Cancel", this );

	//now see if we need to update days JComboBox depending on
	//what year/month are selected.
	try {
		update_rating_days_in_month( "start" );
		update_rating_days_in_month( "end" );
	}
	catch ( Exception e ) {
		Message.printWarning( 2, routine, e );
	}

	//layout
	try {
		int x=0;
		int y=0;

		//labels for YYYY MM DD HH MM
		JGUIUtil.addComponent(
		p, YYYY_JLabel, ++x, y, 1, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE, GridBagConstraints.EAST );

		JGUIUtil.addComponent(
		p, MM_JLabel, ++x, y, 1, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE, GridBagConstraints.EAST );

		JGUIUtil.addComponent(
		p, DD_JLabel, ++x, y, 1, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE, GridBagConstraints.EAST );

		JGUIUtil.addComponent(
		p, HH_JLabel, ++x, y, 1, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE, GridBagConstraints.EAST );

		JGUIUtil.addComponent(
		p, mm_JLabel, ++x, y, 1, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.EAST );


		//labels for start and end dates
		x = 0;
		JGUIUtil.addComponent(
		p, start_JLabel,
		x, ++y, 1, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.EAST );

		JGUIUtil.addComponent(
		p, end_JLabel,
		x, ++y, 1, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.EAST );

		//actual fields to fill in START date
		--y;
		JGUIUtil.addComponent(
		p, __rating_tab_popup_start_YYYY_JTextField,
		++x, y, 1, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

		JGUIUtil.addComponent(
		p, __rating_tab_popup_start_MM_JComboBox,
		++x, y, 1, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

		JGUIUtil.addComponent(
		p, __rating_tab_popup_start_DD_JComboBox,
		++x, y, 1, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

		JGUIUtil.addComponent(
		p, __rating_tab_popup_start_HH_JComboBox,
		++x, y, 1, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

		JGUIUtil.addComponent(
		p, __rating_tab_popup_start_mm_JComboBox,
		++x, y, 1, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

		//actual fields to fill in END date
		++y;
		x=0;
		JGUIUtil.addComponent(
		p, __rating_tab_popup_end_YYYY_JTextField,
		++x, y, 1, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

		JGUIUtil.addComponent(
		p, __rating_tab_popup_end_MM_JComboBox,
		++x, y, 1, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

		JGUIUtil.addComponent(
		p, __rating_tab_popup_end_DD_JComboBox,
		++x, y, 1, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

		JGUIUtil.addComponent(
		p, __rating_tab_popup_end_HH_JComboBox,
		++x, y, 1, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

		JGUIUtil.addComponent(
		p, __rating_tab_popup_end_mm_JComboBox,
		++x, y, 1, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

		x = 0;
		JGUIUtil.addComponent(
		p, __rating_tab_popup_ok_JButton,
		x, ++y, 3, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.EAST );

		x = x+3;
		JGUIUtil.addComponent(
		p, __rating_tab_popup_cancel_JButton,
		x, y, 3, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.EAST );

	}
	catch ( Exception e ) {
		Message.printWarning( 2, routine, e );
		Message.printWarning( 2, routine,
		"Error laying GUI to set Start and End " +
		"Rating dates." );
	}

	d.getContentPane().add( p );
	d.pack();
	JGUIUtil.center( d );
	d.setVisible( true);


	return d;
}

/**
Creates the __tabbedInfo_JPanel panel that holds the JTabbedPanes that
contain information regarding the station for the MeasLoc Identifier
selected in the JTree.  The tabs consist of the following topics:
Geographic Data and potentially, Ratings information (for MeasLocs of
type: STATION/POINT).
*/
private void create_tabbed_panel( ) {
	String routine = __class + ".create_tabbed_panel";

	//create the overall panel to hold things.
 	__tabbedInfo_JPanel = new JPanel();
 	__tabbedInfo_JPanel.setLayout( new GridBagLayout() );

	//create the tabbed panes
 	__info_JTabbedPane = new JTabbedPane();

	//Geographic Data Tabe
	//Creates a panel to hold all the info for the Geographic data tab
	JPanel geog_JPanel = null;
	geog_JPanel = assemble_tab_geographic( );
	if ( geog_JPanel != null ) {
		//add geography panel to tab
 		__info_JTabbedPane.addTab(
 		__geog_tab_string, geog_JPanel );
 		__info_JTabbedPane.setToolTipTextAt(0,"Geographic information");
	}

	if ( __db_RTi_MeasLoc.getMeas_loc_type().equalsIgnoreCase( "P" ) ) {
		JPanel rating_JPanel = null;
		rating_JPanel = assemble_tab_rating( );
		//add tab for Rating Curves
		if ( rating_JPanel != null ) {
			//add geography panel to tab
 			__info_JTabbedPane.addTab(
 			__rating_tab_string, rating_JPanel );
 			__info_JTabbedPane.setToolTipTextAt(0,
			"Rating Curve information");
		}
	}

	//Station Panel
	//Not being used.
	JPanel station_JPanel = null;
	station_JPanel = assemble_tab_station();
	if ( station_JPanel != null ) {
		//add geography panel to tab
 		__info_JTabbedPane.addTab(
 		__station_tab_string, station_JPanel );
 		__info_JTabbedPane.setToolTipTextAt(1,"Specify Station information unavailable");
	}

	//Area Panel
	//Not being used.
	JPanel area_JPanel = null;
	area_JPanel = assemble_tab_area();
	if ( area_JPanel != null ) {
		//add geography panel to tab
 		__info_JTabbedPane.addTab(
 		__area_tab_string, area_JPanel );
 		__info_JTabbedPane.setToolTipTextAt(2,"Specify Area information unavailable");
	}


	//ASSEMBLE this portion of GUI
	//top, left, bottom, right
	try {

		//add tabbed pane to main panel
		JGUIUtil.addComponent(
 		__tabbedInfo_JPanel, __info_JTabbedPane,
		0, 0, 2, 1, 0.0, 0.0, __insets,
		GridBagConstraints.BOTH,
		GridBagConstraints.CENTER );
	}
	catch ( Exception e ) {
		Message.printWarning( 2, routine, e);
		Message.printWarning( 2, routine,
		"Error laying out information panel with tabbed panes." );
	}

} //end create_tabbed_panel


/**
Creates the topmost panel of the MeasLoc Configuration GUI for MeasLoc Stations.
The actual information will be filled in the update_GUI_fields()
method.
*/
private void create_top_panel() {

	String routine = __class + ".create_top_panel";

 	__top_station_info_JPanel = new JPanel();
 	__top_station_info_JPanel.setLayout( __gridbag );

	//components are:
	//"Id", "name", "source", "type"
	//make the labels and textfields

	//IDENTIFER
	JLabel station_id_JLabel = new JLabel( "Identifier:" );
	station_id_JLabel.setToolTipText("Identifier (with no spaces) for location (required)" );

 	__station_id_JTextField = new JTextField( 20 );
 	__station_id_JTextField.setText( __preselected_ID_string );

	//NAME
	JLabel station_name_JLabel = new JLabel( "Name:" );
	station_name_JLabel.setToolTipText("Descriptive name for location (required)");

 	__station_name_JTextField = new JTextField( 28 );

	//SOURCE
	JLabel station_source_JLabel = new JLabel( "Source:" );
	station_source_JLabel.setToolTipText( "Primary data source for location (required)" );

	//SOURCE
	List RTi_DataSource_vect = null;
	try {
		RTi_DataSource_vect = __dmi.readDataSourceList();
	}
	catch( Exception e ) {
		Message.printWarning( 2, routine, e );
		Message.printWarning( 2, routine,
		"Unable to get list of data sources. ");
		RTi_DataSource_vect = new Vector();
	}

	//We already have the non-null vector of DataSource objects
	//to use to make a list of Source choices.
	RiversideDB_DataSource ds = null;
	String source_str = null;
	List source_vect = new Vector();
	for ( int i=0; i<RTi_DataSource_vect.size(); i++ ) {
		ds = (RiversideDB_DataSource) RTi_DataSource_vect.get(i);
		if ( ds == null ) {
			continue;
		}
		source_str = ds.getSource_abbrev() + " - " +
			ds.getSource_name();

		if ( source_str != null ) {
			if ( source_str.length() > 45 ) {
				source_str = source_str.substring(0,45)+ " ...";
			}

			source_vect.add( source_str );
		}

		source_str = null;
		ds = null;
	}
	RTi_DataSource_vect = null;

	//make comboBox
 	__station_source_JComboBox = new SimpleJComboBox( source_vect );

	//Do not need list of Station types.  Either is is a
	//POINT (if an Station was selected ) or it is a "AREA" ,
	//if an area was selected.  This is "hardcoded" for now because
	//currently in the database, there is a third type that is not
	//used... Type in general is not used so might go away in the future.

	//TYPE
	JLabel station_type_JLabel = new JLabel( "Location Type:" );
	station_type_JLabel.setToolTipText("Non-editable field." );

	//make Uneditable JTextField
	//check title to see if it is an "AREA" or a "STation"
	if  ( __title.indexOf( "Station" ) >= 0 ) {
 		__station_type_JTextField = new JTextField( TYPE_STATION, 12 );
	}
	else {
 		__station_type_JTextField = new JTextField( TYPE_AREA, 12 );
	}

	//make Uneditable JTextField
 	__station_type_JTextField.setEditable( false );
 	__station_type_JTextField.setBackground( Color.lightGray );

	//MeasLocGroup
	JLabel station_measlocgrp_JLabel = new JLabel( "Location Group:" );
	station_measlocgrp_JLabel.setToolTipText("Non-editable field." );

	List mlg_vect = null;
	try {
		mlg_vect = __dmi.readMeasLocGroupList();
	}
	catch ( Exception e ) {
		Message.printWarning( 2, routine, e );
		//create an empty vector
		mlg_vect = new Vector();
	}
	int size_mlg = 0;
	size_mlg =  mlg_vect.size();
	if ( Message.isDebugOn ) {
		Message.printDebug( 25, routine,
		"Total Number of MeasLocGroup objects = " + size_mlg );
	}
	//go through and pull out number, ID, name
	List measlocgrp_vect = new Vector();
	RiversideDB_MeasLocGroup mlg = null;
	String mlg_str = null;
	for ( int i=0; i<size_mlg; i++ ) {
		mlg = (RiversideDB_MeasLocGroup) mlg_vect.get(i);
		if ( mlg == null ) {
			continue;
		}
		mlg_str = String.valueOf( mlg.getMeasLocGroup_num() ) + " - " +
		mlg.getIdentifier() + " - " + mlg.getName();

		if ( mlg_str.length() > 50 ) {
			mlg_str = mlg_str.substring( 0, 45 ) + "...";
		}

		measlocgrp_vect.add( mlg_str );
		mlg =null;
	}

	//create JComboBox
 	__station_measlocgrp_JComboBox = new SimpleJComboBox( measlocgrp_vect );
 	__station_measlocgrp_JComboBox.setEditable( false );
 	__station_measlocgrp_JComboBox.setBackground( Color.lightGray );

	try {
		//ASSEMBLE GUI PANEL
		int y =0;
		int x =0;
		//now add all pieces to main container panel
		//ID
		JGUIUtil.addComponent(
 		__top_station_info_JPanel, station_id_JLabel,
		x, y, 1, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.EAST );

		JGUIUtil.addComponent(
 		__top_station_info_JPanel, __station_id_JTextField,
		++x, y, 3, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

		x=0;
		//Name
		JGUIUtil.addComponent(
 		__top_station_info_JPanel, station_name_JLabel,
		x, ++y, 1, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.EAST );
		//GridBagConstraints.WEST );

		JGUIUtil.addComponent(
 		__top_station_info_JPanel, __station_name_JTextField,
		++x, y, 3, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

		x=0;
		//Source
		JGUIUtil.addComponent(
 		__top_station_info_JPanel, station_source_JLabel,
		x, ++y, 1, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.EAST );

		JGUIUtil.addComponent(
 		__top_station_info_JPanel, __station_source_JComboBox,
		++x, y, 3, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

		x=0;
		//Type
		JGUIUtil.addComponent(
 		__top_station_info_JPanel, station_type_JLabel,
		x, ++y, 1, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.EAST );

		JGUIUtil.addComponent(
 		__top_station_info_JPanel, __station_type_JTextField,
		++x, y, 1, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

		//MeasLocGroup
		JGUIUtil.addComponent(
 		__top_station_info_JPanel, station_measlocgrp_JLabel,
		++x, y, 1, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.EAST );

		JGUIUtil.addComponent(
 		__top_station_info_JPanel, __station_measlocgrp_JComboBox,
		++x, y, 1, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

	}
	catch ( Exception e ) {
		Message.printWarning( 2, routine,
			"Error laying out the top portion of the GUI " +
			"with the MeasLoc Station/Point information." );
		Message.printWarning( 2, routine, e );
	}

} //end create_top_panel

/**
FiLLs __stageDischargeRating_vect and __ratingTable_worksheet_vect
Vectors known throughout this class by reading directly from the database.
*/
protected void fillStageDischargeRatingAndRatingTable_vectors( ) {
	fillStageDischargeRatingAndRatingTable_vectors( false);
}

/**
FiLLs __stageDischargeRating_vect and __ratingTable_worksheet_vect
Vectors known throughout this class by reading directly from the database.
@param boolean to indicate this is coming from the constructor. This is
important in case we are creating a GUI for a MeasLoc that does not already
have a StageDischargeRating object.
*/
protected void fillStageDischargeRatingAndRatingTable_vectors(
boolean fromConstructor) {
	String routine = __class +
	"fillStageDischargeRatingAndRatingTable_vectors";

	// __dmi.setDumpSQLOnExecution( true );
	try {
 		__stageDischargeRating_vect =
 		__dmi.readStageDischargeRatingListForMeasLoc_num(
 		__db_RTi_MeasLoc.getMeasLoc_num() );
	}
	catch ( Exception e ) {
		Message.printWarning( 2, routine, e );
		Message.printWarning( 2, routine,
		"Unable to determine the " +
		"StageDischargeRating objects associated " +
		"with Location identified by MeasLoc_num: " +
 		__db_RTi_MeasLoc.getMeasLoc_num() );
 		__stageDischargeRating_vect =  new Vector();
	}

	//get related RatingTable items to put in JWorksheets
 	__ratingTable_worksheet_vect.clear( );
	int size  = __stageDischargeRating_vect.size();
	RiversideDB_StageDischargeRating sdr = null;
	for ( int i=0; i<size; i++ ) {
		sdr = (RiversideDB_StageDischargeRating)
 		__stageDischargeRating_vect.get(i);
		if ( sdr == null ) {
			continue;
		}
		List v = null;
		try {
			v = __dmi.readRatingTableListForRatingTable_num(
			sdr.getRatingTable_num() );
		}
		catch ( Exception e ) {
			Message.printWarning( 2, routine, e );
			v = new Vector();
		}
		//__dmi.setDumpSQLOnExecution( false );

		JWorksheet worksheet = null;
		RiversideDB_RatingTable_TableModel tmr = null;
		try {
			tmr =
			new RiversideDB_RatingTable_TableModel(__dmi, v);
			RiversideDB_RatingTable_CellRenderer crr =
			new RiversideDB_RatingTable_CellRenderer(tmr);

			worksheet = new JWorksheet(
			crr, tmr, __worksheet_PropList);
		}
		catch (Exception e) {
			Message.printWarning(2, routine, e);
			worksheet = new JWorksheet(
			0, 0, __worksheet_PropList );
		}
		//set worksheet so it is known to TableModel and can
		//set is dirty!
		tmr.setWorksheet( worksheet );

		//add JWorksheet to global vector
 		__ratingTable_worksheet_vect.add( worksheet );
		worksheet=null;
		v= null;
	}
	if ( size == 0 ) {
		 if( fromConstructor ) {
			//do nothing

		 }

		else { //used Add Dates button
			//make empty objects to pass in.
			DateTime dt = new DateTime( DateTime.DATE_CURRENT );
			try {
				update_stagedischargerating_dates(
				dt.toString(),
				"9999-12-31 00:00" );
			}
			catch ( Exception e) {
				Message.printWarning( 2, routine, e);
			}
		}
	}
} //end fillStageDischargeRatingAndRatingTable_vectors

/**
Finalizes and cleans up.
*/
protected void finalize() throws Throwable {

	if ( __rating_newDates_JDialog != null ) {
 		__rating_newDates_JDialog = null;
	}

 	__insets = null;
 	__gridbag = null;
 	__RTi_MeasLoc_vect = null;
 	__dmi = null;
 	__main_JPanel = null;
 	__top_station_info_JPanel = null;
 	__tabbedInfo_JPanel = null;
 	__close_JButton = null;
 	__cancel_JButton = null;
 	__apply_JButton = null;
 	__station_id_JTextField = null;
 	__station_name_JTextField = null;
 	__station_source_JComboBox = null;
 	__station_type_JTextField = null;
 	__station_measlocgrp_JComboBox = null;
 	__geog_tab_latitude_JTextField = null;
 	__geog_tab_longitude_JTextField = null;
 	__geog_tab_x_JTextField = null;
 	__geog_tab_y_JTextField = null;
 	__geog_tab_country_JTextField = null;
 	__geog_tab_state_JTextField = null;
 	__geog_tab_county_JTextField = null;
 	__geog_tab_elevation_JTextField = null;
 	__db_RTi_GeoLoc = null;
 	__db_RTi_MeasLoc = null;
 	__RTi_MeasLoc_vect = null;
 	__info_JTabbedPane = null;

	// Finalize the base RiversideDB_EditorBase_JFrame class
	super.finalize();

}


/**
This method is called from the constructor to create and layout the
GUI components.  It calls the method: <i>create_main_panel</i>, which
in turn calls methods named such as: <i>assemble_tab_geography()</i>,
<i>assemble_tab_ratings</i>, etc.  These methods all create
GUI components and put them together in a <i>GridBagLayout</i>. They
do not worry about setting correct values in the components' fields, but just
gets the components set up.  The main components in the GUI consists of:
<ul><li>JPanel that contains general information pertinent to the MeasLoc
object at the top of the GUI</li>
<li>a series of tabs in a JTabbedPane with fields for the GeoLoc and Ratings
objects related to the current MeasLoc, seperated by general topic. Tab
topics include: <ul><li>geography </li> <li>ratings </li>
</ul> </li>
<li>a panel added at the bottom that includes the standard buttons for:
<ul><li>apply</li><li>close</li><li>cancel</li></ul></li></ul>
At the end of <i>init_layout_gui</i>, a
call to <i>update_gui_fields</i> is made which fills in all the
fields of the GUI according to the MeasLoc and GeoLoc objects
currently being worked with.
*/
private void init_layout_GUI( ) {
	String routine = __class + ".init_layout_GUI";

	try {
 		__main_JPanel = new JPanel();
 		__main_JPanel.setLayout( __gridbag );

		//Creates the JPanel: __top_measLoc_JPanel
		create_top_panel( );

		//create the panel that holds the
		//tabbed panes with additional info
		//about the selected product
		//Creates the JPanel: __tabbedInfo_JPanel
		create_tabbed_panel( );

		//close panel
		JPanel close_JPanel = new JPanel();
		close_JPanel.setLayout( new GridBagLayout() );

 		__close_JButton = new SimpleJButton( "Close", this );
 		__cancel_JButton = new SimpleJButton( "Cancel", this );
 		__apply_JButton = new SimpleJButton( "Apply", this  );

		JGUIUtil.addComponent(
			close_JPanel, __apply_JButton,
			0, 0, 1, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.EAST );

		JGUIUtil.addComponent(
			close_JPanel, __close_JButton,
			1, 0, 1, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.CENTER );
		JGUIUtil.addComponent(
			close_JPanel, __cancel_JButton,
			2, 0, 1, 1, 0.0, 0.0, __insets,
			GridBagConstraints.NONE,
			GridBagConstraints.WEST );

		//NOW that the panels have
		//been created - fill in the values for all the FIELDS!
		update_GUI_fields();

		//now assemble GUI
		int vcnt = 0;

		if ( __top_station_info_JPanel != null ) {
			JGUIUtil.addComponent(
 			__main_JPanel, __top_station_info_JPanel,
			0, vcnt, 1, 1, 0.0, 0.0, __insets,
			GridBagConstraints.BOTH,
			GridBagConstraints.CENTER );

			vcnt++;
		}

		if ( __tabbedInfo_JPanel != null ) {
			JGUIUtil.addComponent(
 			__main_JPanel, __tabbedInfo_JPanel,
			0, vcnt, 1, 1, 0.0, 0.0, __insets,
			GridBagConstraints.BOTH,
			GridBagConstraints.CENTER );

			vcnt++;
		}

		JGUIUtil.addComponent(
 		__main_JPanel, close_JPanel,
		0, vcnt, 1, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.CENTER );

		vcnt++;

		//pack and set visible
		getContentPane().add( "Center", __main_JPanel );
		pack();
		JGUIUtil.center( this );
		setVisible( true );
	}
	catch ( Exception e ) {
		Message.printWarning( 2, routine,
		"Error laying out GUI." );
		Message.printWarning( 2, routine, e );
	}

} //end init_layout_GUI

/**
Sets the fields in the Ratings Tab gui based on the
RiversideDB_StageDischargeRating object passed in. Assumes that the
Start and End dates are already selected in the JComoBox.
@param sdr RiversideDB_StageDischargeRating object to update fields with.
If null, sets default values.
@param index Index of the StageDischargeRating object passed in above
to use to find the correlcating JWorksheet.
*/
protected void set_rating_tab_fields( RiversideDB_StageDischargeRating sdr,int index ) {
	if ( sdr != null ) {
		//_previous_RTi_StageDischargeRating =
		//new RiversideDB_StageDischargeRating( sdr );

		//and fill in other fields according to the
		//data for the first date
 		__rating_tab_datum_JTextField.setText(
		String.valueOf(sdr.getGage_Zero_Datum()) );

		try {
			JGUIUtil.selectTokenMatches(
 			__rating_tab_datum_units_JComboBox, true,
			" - ", 0, 0, sdr.getGage_Datum_Units(), "" );
		}
		catch (Exception e ) {}

 		__rating_tab_warning_stage_JTextField.setText(
		String.valueOf(sdr.getWarning_Level()) );

 		__rating_tab_flood_stage_JTextField.setText(
		String.valueOf(sdr.getFlood_Level() ) );

		try {
			JGUIUtil.selectTokenMatches(
 			__rating_tab_interpol_JComboBox, true,
			" - ", 0, 0 , sdr.getInterpolation_Method(),"");

			JGUIUtil.selectTokenMatches(
 			__rating_tab_stage_units_JComboBox, true,
			" - ", 0, 0, sdr.getStage_Units(), "" );

			JGUIUtil.selectTokenMatches(
 			__rating_tab_discharge_units_JComboBox, true,
			" - ", 0, 0, sdr.getDischarge_Units(), "" );
		}
		catch (Exception e ) {}

		//update JWorksheet
 		__rating_JWorksheet = (JWorksheet) __ratingTable_worksheet_vect.
		get( index );
		//update Jscrollpane
		if ( __rating_JWorksheet != null  ) {
 			__rating_worksheet_JScrollPane.setViewportView(
 			__rating_JWorksheet );
		}
	}
}//end set_rating_tab_fields

/**
This method: <ul>
<li>makes a confirmation message to verify that the user wants to save the
changes (and lists out all the changes from the <i>__dirty_vect</i>) <b>if</b>
a new MeasLoc was <b>not</b> created (if a new MeasLoc was created,
we do not want to re-confirm every change)</li>
<li>writes the <i>__gui</i> version of the objects (MeasLoc, GeoLoc,
StageDischargeRating) to the database</li>
<li>if the objects were successfully written to the database, the
<i>__gui</i> objects are marked as <b>not</b> dirty
( <i>setDirty(false)</i></li>
<li><i>__dirty_vect</i> is cleared out</li>
<li>if we created a new MeasLoc object (<i>__bln_new_object == true</i>),
add a new node on the JTree in the main application  - <b>or</b> -  update the
existing MeasLoc node on the JTree with the new changes.</li>
</ul>
@exception Exception thrown if error encountered.
*/
protected void update_database( ) throws Exception {
	String routine = __class + ".update_database";

	//holds messages from __dirty_vect
	StringBuffer b = new StringBuffer();
	for ( int i=0; i< __dirty_vect.size(); i++ ) {
		if ( i == ( __dirty_vect.size()-1) ) {
			b.append( (String) __dirty_vect.get(i) );
		}
		else {
			b.append( (String) __dirty_vect.get(i) + "\n" );
		}
	}

	boolean sdr_dirty = false;
	if ( __db_RTi_MeasLoc.getMeas_loc_type().equalsIgnoreCase( "P" ) ) {
		//go through vector StageDischargeRating objects to see if it is
		//dirty.
		int numb_sdr = __stageDischargeRating_vect.size();
		RiversideDB_StageDischargeRating sdr =null;
		for ( int i=0;i<numb_sdr;i++ ) {
			sdr = (RiversideDB_StageDischargeRating)
 			__stageDischargeRating_vect.get(i);
			if ( sdr == null ) {
				continue;
			}
			if ( sdr.isDirty() ) {
				sdr_dirty = true;
				break;
			}
		}
	}
	//if we are running in cautious mode and if we
	//are changing an already existing object ( not a completely new one),
	//then prompt the user before writing to the database
	if( ( __cautious_mode ) && ( ! __bln_new_object ) ) {
		if (( __gui_RTi_GeoLoc.isDirty()) ||
		( __gui_RTi_MeasLoc.isDirty() ) ||
		sdr_dirty ) {

			//write out a confirmation message.
			 if( b.length() > 0 ) {
				int x = new ResponseJDialog(
				this, "Confirm Changes to be saved to "+
				"database", "Confirm Changes:\n" +b.toString(),
				ResponseJDialog.YES | ResponseJDialog.NO ).
				response();

				if ( x == ResponseJDialog.YES ) {
					Message.printStatus( 1, routine,
					"Saving changes to the database. ");

					//write to log file
					Message.printStatus( 5, routine,
					"User confirmed changes: " +b.toString() );

				}
				else {
					//write to log file
					Message.printStatus( 5, routine,
					"User denied changes: " +b.toString() );
					//empty out dirty vector
 					__dirty_vect.clear();
					throw new Exception (
					"User choose not to write changes "+
					"back to database." );
				}
			}
		}
	}

	//update GEOLOC first so that we get the autonum that
	//measloc needs
	RiversideDB_Geoloc gl = null;
	long gl_num = -999;
	//get the GeoLoc num from the existing GeoLoc object.  If we
	//are creating a brand new GeoLoc object, then this will be -999
	//at this point, but will be updated after the writeGeoLoc below.
	gl_num = __db_RTi_GeoLoc.getGeoloc_num();
	if ( __gui_RTi_GeoLoc.isDirty() ) {
		try {
			gl = __dmi.writeGeoloc( __gui_RTi_GeoLoc );
		}
		catch ( Exception e ) {
			Message.printWarning( 2, routine, e );
			Message.printWarning( 1, routine,
			"Failure to write the Geoloc object " +
			" to the database.", this );

 			__gui_RTi_GeoLoc.setDirty( true );

			throw new Exception (
			"Writing of Geoloc object to the database failed." );
		}
		//if the write succeeded, set object to be clean
 		__gui_RTi_GeoLoc.setDirty( false );

		if ( gl == null )  {
			//then we updated an EXISTING GeoLoc object
			//so can use the GeoLoc num from the existing GeoLoc
			//object that we got above.
		}
		else {
			//we wrote a NEW GeoLoc Object, so
			//need to get its Geoloc_num
			gl_num = gl.getGeoloc_num();
		}
	}

	//UPDATE MEASLOC NEXT
	if ( __gui_RTi_MeasLoc.isDirty() ) {
		RiversideDB_MeasLoc new_measloc = null;
		if ( gl_num > 0 ) {
			//update title - identifier may have changed for
			//a current MeasLoc Or, if we are adding a new
			//measloc, need to update title from "New xx" to
			//use the identifier.
			if ( __title.indexOf( "Area" ) >= 0 ) {
				//update title on JFrame
				this.setTitle( "RiverTrak Assistant - " +
				"Area Properties - " +
 				__station_id_JTextField.getText().trim() );
			}
			else {
				//update title on JFrame
				this.setTitle( "RiverTrak Assistant - " +
				"Station/Point Properties - " +
 				__station_id_JTextField.getText().trim() );
			}

			//update MeasLoc object to have the Geoloc
 			__gui_RTi_MeasLoc.setGeoloc_num( gl_num );
			try {
				//write object to database
				new_measloc =
 				__dmi.writeMeasLoc( __gui_RTi_MeasLoc );
			}
			catch ( Exception e ) {
				Message.printWarning( 2, routine, e );
				Message.printWarning( 1, routine,
				"Failure to write the MeasLoc object " +
				" to the database.", this );

 				__gui_RTi_MeasLoc.setDirty( true );

				throw new Exception(
				"Unable to write the MeasLoc object " +
				" to the database." );

			}
		}
		else {
			Message.printWarning( 1, routine,
			"Unable to write new MeasLoc " +
			"with GeoLoc number: " + gl_num, this );

			throw new Exception( "Unable to write new MeasLoc " +
			"with GeoLoc number: " + gl_num );
		}
		//if we added a New node, add node to tree.
		//use title string to identify parent
		if ( __bln_new_object ) {
			//grandparent( MeasLocGroup ), child ( MeasLoc ID),
			//and new MeasLoc object
			//get Location Group String in format (for example):
			// "1 - HYDRO - Hydro Data"
			String locgrp =null;
			String full_locgrp = (String)
 			__station_measlocgrp_JComboBox.
			getSelected();

			//remove the MeasLocGroup num before the text.
			int ind = -999;
			ind = full_locgrp.indexOf(" -");
			if( ind >= 0 ) {
				locgrp = full_locgrp.substring( ind +2 ).trim();
			}

			//need to assign new MeasLoc_num
 			__gui_RTi_MeasLoc.setMeasLoc_num( new_measloc.
			getMeasLoc_num() );
			new_measloc= null;

 			addMeasLocNode(	locgrp,
 					__gui_RTi_MeasLoc );

			//update flag
 			__bln_new_object = false;
		}
		else { //update existing Node on tree
			//String gui_name = null;
			//gui_name = ( __station_id_JTextField.getText())
			//.trim() + " - " +
			//( __station_name_JTextField.getText()).trim();

 			updateMeasLocNode( __gui_RTi_MeasLoc,
 					   __db_RTi_MeasLoc );
		}

		//update object to indicate it is no longer dirty.
 		__gui_RTi_MeasLoc.setDirty( false );

		//write to log file
		Message.printStatus( 5, routine,
		"Changes written to database: " +b.toString() );

		//update local copy of MeasLoc vector so
		//new MeasLoc objects can be located in it.
 		__RTi_MeasLoc_vect.clear();
 		__RTi_MeasLoc_vect = null;
		try {
 			__RTi_MeasLoc_vect = __dmi.readMeasLocList();
		}
		catch ( Exception e ) {
			Message.printWarning( 2, routine, e );
			Message.printWarning( 2, routine,
			"Unable to get a list of MeasLoc objects" );
 			__RTi_MeasLoc_vect = new Vector();
		}
	}

	//update the StageDischargeRating and RatingTable objects
	if ( sdr_dirty ) {
		int numb_sdr = __stageDischargeRating_vect.size();
		RiversideDB_StageDischargeRating sdr = null;
		for ( int i=0; i< numb_sdr; i++ ) {
			sdr = (RiversideDB_StageDischargeRating)
 			__stageDischargeRating_vect.get(i);
			if ( sdr == null ) {
				continue;
			}
			//update is db
			RiversideDB_StageDischargeRating temp_sdr = null;
			try {
				temp_sdr =
 				__dmi.writeStageDischargeRating(
				sdr );
			}
			catch (Exception e ) {
				Message.printWarning( 2, routine, e );
			}
			//go through ratingTables assoc with this
			long rt_num =-999;
			if ( sdr.getRatingTable_num() != DMIUtil.
			MISSING_DOUBLE )  {
				rt_num = sdr.getRatingTable_num();
			}
			else if ( temp_sdr != null ){
				sdr.setRatingTable_num(
				temp_sdr.getRatingTable_num() );
				rt_num = temp_sdr.getRatingTable_num();
			}

			//now delete all RatingTable records for this one
			try {
 				__dmi.deleteRatingTableForRatingTable_num(
				(int)rt_num );

			}
			catch ( Exception e ) {
				Message.printWarning( 2, routine,  e);
			}
			//now write all from the GUI back to the database
			//get worksheet associated with this same SDR obj
			JWorksheet worksheet = (JWorksheet)
 			__ratingTable_worksheet_vect.get( i );

			//now get data from worksheet
			List v = worksheet.getAllData();
			int numb_rt = v.size();
			RiversideDB_RatingTable rt = null;
			for ( int k=0; k< numb_rt; k++ ) {
				try {
					rt = (RiversideDB_RatingTable)v.get(k);
 					__dmi.writeRatingTable(rt);
					//(RiversideDB_RatingTable)
					//v.elementAt(k) );
					rt = null;
				}
				catch ( Exception e ) {
					Message.printWarning( 2, routine, e);
				}
			}
		}
	}

	//empty out dirty vector
 	__dirty_vect.clear();
} //end update_database

/**
Updates the Vector of RiversideDB_StageDischargeRating objects with new
object's data.  Also updates the related JWorksheet (from RatingTable).
*/
protected void update_previous_StageDischargeRating_obj( ) {

	double datum_elv = ( StringUtil.atod(
 	__rating_tab_datum_JTextField.getText() ) );

	String datum_units = (String)
 	__rating_tab_datum_units_JComboBox.getSelected();
	int index = -999;
	index = datum_units.indexOf("-");
	if ( index >= 0 ) {
		datum_units = (datum_units.substring(0, index)).trim();
	}

	double warn_level = ( StringUtil.atod(
 	__rating_tab_warning_stage_JTextField.getText() ) );

	double flood_level = ( StringUtil.atod(
 	__rating_tab_flood_stage_JTextField.getText() ) );

	String stage_units = (String)
 	__rating_tab_stage_units_JComboBox.getSelected();
	index = -999;
	index = stage_units.indexOf("-");
	if ( index >= 0 ) {
		stage_units = (stage_units.substring(0, index)).trim();
	}


	String discharge_units = (String)
 	__rating_tab_discharge_units_JComboBox.getSelected();
	index = -999;
	index = discharge_units.indexOf("-");
	if ( index >= 0 ) {
		discharge_units =
		(discharge_units.substring(0, index)).trim();
	}

	String interp = (String)
 	__rating_tab_interpol_JComboBox.getSelected();

 	__previous_RTi_StageDischargeRating.setDischarge_Units(
	discharge_units);
 	__previous_RTi_StageDischargeRating.setFlood_Level(
	flood_level);
 	__previous_RTi_StageDischargeRating.setGage_Datum_Units(
	datum_units);
 	__previous_RTi_StageDischargeRating.setGage_Zero_Datum(
	datum_elv);
 	__previous_RTi_StageDischargeRating.setInterpolation_Method(
	interp );
 	__previous_RTi_StageDischargeRating.setStage_Units(
	stage_units);
 	__previous_RTi_StageDischargeRating.setWarning_Level(
	warn_level);

	//now update this puppy in the Vector of
	//StageDischargeRating objects.
	int size = __stageDischargeRating_vect.size();
	RiversideDB_StageDischargeRating sdr =null;

	DateTime start_dt = new DateTime(
 	__previous_RTi_StageDischargeRating.getStart_Date() );

	DateTime end_dt = new DateTime(
 	__previous_RTi_StageDischargeRating.getEnd_Date() );

	int ind = 0;
	for ( int i=0; i<size; i++ ) {
		sdr = (RiversideDB_StageDischargeRating)
 		__stageDischargeRating_vect.get(i);
		DateTime s = new DateTime(sdr.getStart_Date());
		DateTime e = new DateTime(sdr.getEnd_Date());
		if( ( start_dt.equals( s,
		DateTime.PRECISION_MINUTE ) ) &&
		( end_dt.equals( e,
		DateTime.PRECISION_MINUTE ) ) ) {
			//we found the object in the Vector
			//that we need to update
 			__stageDischargeRating_vect.remove(i);
 			__stageDischargeRating_vect.add(i, __previous_RTi_StageDischargeRating);
			s = null;
			e = null;
			ind = i;
			break;
		}
	}
	start_dt = null;
	end_dt = null;

	//also update the data from RatingTable worksheet if
	//it has changed.
	if ( __rating_JWorksheet.isDirty() ) {
 		__rating_JWorksheet = (JWorksheet)
 		__ratingTable_worksheet_vect.get(ind);

		//get worksheet and
		//replace it in global Vector of Vector that
		//contains the RatingTable objects.
 		__ratingTable_worksheet_vect.remove(ind);

		/*
		//DEBUGGINg
		for (int i=0;i<v.size();i++ ) {
			Message.printStatus(1,"","ERASE:::: in ws right now:: " +
			((RiversideDB_RatingTable) v.elementAt(i)).toString() + "\n" );

		}
		*/
 		__ratingTable_worksheet_vect.add( ind, __rating_JWorksheet );
	}

} //end update_previous_StageDischargeRating_obj


/**
Method to update the number of days that appears in the
Days JComboBox of the JDialog used to set new start and end
Rating dates.
@param s String representing either start or end dates to verify.  String
can be "start" or "end"
@exception Exception thrown if error encountered- for instance if non-integer
entered in Year JTextField
*/
protected void update_rating_days_in_month( String s ) throws Exception {
	String routine = __class + ".update_rating_days_in_month";
	String yr_str = null;
	String mo_str = null;
	int yr = -999;
	int mo = -999;
	int numb_days = 0;
	if ( s.equalsIgnoreCase( "start" )  ) {
		yr_str = __rating_tab_popup_start_YYYY_JTextField.getText();
		if ( !StringUtil.isInteger( yr_str ) ) {
			DateTime dt = new DateTime( DateTime.DATE_CURRENT);
 			__rating_tab_popup_start_YYYY_JTextField.setText(
			String.valueOf(dt.getYear() ));
			dt = null;

			throw new Exception(
			"You must enter an integer in the YEAR (YYYY) field.");
		}
		yr = StringUtil.atoi( yr_str);

		mo_str =(String) __rating_tab_popup_start_MM_JComboBox.
		getSelected();
		mo = StringUtil.atoi( mo_str );

		numb_days = TimeUtil.numDaysInMonth( mo, yr);
		int size = __rating_tab_popup_start_DD_model.getSize();

		if ( numb_days != size ) {
 			__rating_tab_popup_start_DD_model.removeAllElements();
			for ( int i=1; i<=numb_days; i++ ) {
 				__rating_tab_popup_start_DD_model.addElement(
				StringUtil.formatString( String.valueOf(i),
				"%02d" ) );
			}
		}
		if ( Message.isDebugOn ) {
			Message.printDebug( 8, routine,
			"Number of days in month: "+ mo + " of year: " +
			yr + " is: " + numb_days );
		}
	}
	else if ( s.equalsIgnoreCase( "end" )  ) {

		yr_str = __rating_tab_popup_end_YYYY_JTextField.getText();
		if ( !StringUtil.isInteger( yr_str ) ) {
			DateTime dt = new DateTime( DateTime.DATE_CURRENT);
 			__rating_tab_popup_end_YYYY_JTextField.setText(
			String.valueOf(dt.getYear() ) );
			dt = null;

			throw new Exception(
			"You must enter an integer in the YEAR (YYYY) field.");
		}
		yr = StringUtil.atoi( yr_str );

		mo_str =(String) __rating_tab_popup_end_MM_JComboBox.
		getSelected();
		mo = StringUtil.atoi( mo_str );

		numb_days = TimeUtil.numDaysInMonth( mo, yr);
		int size = __rating_tab_popup_end_DD_model.getSize();
		if ( numb_days != size ) {
 			__rating_tab_popup_end_DD_model.removeAllElements();
			for ( int i=1; i<=numb_days; i++ ) {
 				__rating_tab_popup_end_DD_model.addElement(
				StringUtil.formatString( String.valueOf(i),
				"%02d" ) );
			}
		}
		if ( Message.isDebugOn ) {
			Message.printDebug( 8, routine,
			"Number of days in month: "+ mo + " of year: " +
			yr + " is: " + numb_days );
		}
	}
}//end update_rating_days_in_month


/**
This method:<ul>
<li><b>creates the <i>__gui</i> versions of the objects!</b> This includes: <ul><li>__gui_RTi_MeasLoc</li><li>__gui_RTi_GeoLoc</li></ul> The
<i>__gui</i> versions are created in this method by copying the <i>__db</i>
versions (which were originally created and set up in the constructor)</li>
<li>calls the <i>verify_xxx</i> methods. These include:<ul>
<li><i>verify_top_fields()</i></li>
<li><i>verify_geography_tab()</i></li>
<li><i>verify_ratings_tab()</i></li>
The <i>verify_xxx</i> methods:<ul><li> fill in the <i>__gui</i> verions of the objects
in memory with the values that are currently set in the GUI</li>
<li>compares the values in the <i>__gui</i> version of the objects to the
<i>__db</i> version of the objects.  If the <i>__gui</i> versions differ
from the <i>__db</i> verions:<ul>
<li>the <i>__gui</i> versions are marked dirty (<i>.setDirty(true)</i>)</li>
<li>messages are added to the <i>__dirty_vect</i> indicating how the
<i>__gui</i> differs from the <i>__db</i> version (the <i>__db</i> version
remember, represents how the object is in the database itself) </li></ul>
</li></ul></ul>
@param Exception thrown if error encountered.
*/
protected void update_RiversideDB_objects( ) throws Exception {
	String routine = __class + ".update_RiversideDB_objects";

	boolean continue_verification = true;

	//make a copy of the object in memory that we
	//operate on until we know that the user wants to
	//commit their changes
 	__gui_RTi_GeoLoc = new RiversideDB_Geoloc( __db_RTi_GeoLoc );
 	__gui_RTi_MeasLoc = new RiversideDB_MeasLoc( __db_RTi_MeasLoc );

	//get the Top values and then verify the tabs
	try {
		verify_top_fields();
	}
	catch ( Exception e ) {
		continue_verification = false;
		Message.printWarning( 2, routine, e);
		throw new Exception (
		"Error while validating top fields");
	}


	if ( continue_verification) {
		//verify all tabs
		try {
			verify_geography_tab();
		}
		catch ( Exception e ) {
			Message.printWarning( 2, routine, e);
		}
		if ( __db_RTi_MeasLoc.getMeas_loc_type().
		equalsIgnoreCase( "P" ) ) {
			if ( __rating_tab_dates_model.getSize() > 0 ) {

				//make sure we have the current status
				update_previous_StageDischargeRating_obj();
				try {
					verify_rating_tab();
				}
				catch ( Exception e ) {
					Message.printWarning( 2, routine, e);
				}
			}
		}
		try {
			verify_area_tab();
		}
		catch ( Exception e ) {
			Message.printWarning( 2, routine, e);
		}
		try {
			verify_station_tab();
		}
		catch ( Exception e ) {
			Message.printWarning( 2, routine, e);
		}
	}

} //end update_RiversideDB_objects

/**
Takes the new Start and Dates set in the __ratings_newDates_JDialog
and adds them to the drop-down list of start to end date ranges on
the Ratings Tab.  If there is already atleast one set of dates in the
drop-down, will change the end date of the latest set of dates to be
1 minute before the start date of the new dates entered. This is called
after the "Add Date Range" button is used (and a new StageDischargeRating
object is added.)
@exception thrown if error encountered.
*/
protected void update_stagedischargerating_dates( String start_str,
String end_str ) throws Exception {
	String routine = __class + ".update_stagedischargerating_dates";

	Message.printStatus( 4, routine, "Using start date: " + start_str +
	" and end date: " + end_str + " to update " +
	"RiversideDB_StageDischargeRating object in Ratings tab of GUI." );

	//Make new StageDischargeRating object
	RiversideDB_StageDischargeRating sdr =
	new RiversideDB_StageDischargeRating();

	//set MeasLoc_num
	sdr.setMeasLoc_num( __db_RTi_MeasLoc.getMeasLoc_num() );

	//set Dates
	DateTime start_dt = DateTime.parse(
	start_str, DateTime.FORMAT_YYYY_MM_DD_HH_mm );
	sdr.setStart_Date( start_dt.getDate() );
	start_dt = null;
	DateTime end_dt = DateTime.parse(
	end_str, DateTime.FORMAT_YYYY_MM_DD_HH_mm );
	sdr.setEnd_Date( end_dt.getDate() );
	end_dt = null;

	//set Numeric fields to 0
	sdr.setGage_Zero_Datum( 0 );
	sdr.setWarning_Level( 0 );
	sdr.setFlood_Level( 0 );

	//set TextFields
	sdr.setGage_Datum_Units("M");
	sdr.setDischarge_Units("CMS");
	sdr.setStage_Units("CM");
	sdr.setInterpolation_Method("LINEAR");

	//In order to get the RatingTable_num, need to write this
	//new guy to the DB
	RiversideDB_StageDischargeRating temp_sdr =  null;
	try {
		temp_sdr = __dmi.writeStageDischargeRating( sdr );
	}
	catch (Exception e ) {
		Message.printWarning( 2, routine, e );
	}

	//set the RatingTable_num now...
	long rt_num =-999;
	if ( temp_sdr != null ) {
		rt_num =  temp_sdr.getRatingTable_num();
	}
	else {
		Message.printWarning( 2, routine, "Error writing new " +
		"StageDischargeRating object to database.  Please see " +
		"log file." );
	}
	sdr.setRatingTable_num ( rt_num);
	temp_sdr = null;


	// if we are creating a brand new SDR for the first time for
	//the measloc, assign  it to __previous_RTi_StageDischargeRating
	if ( __previous_RTi_StageDischargeRating == null ) {
		//we are creating the first SDR for this MEasLoc.
		//need to assign dates.
 		__previous_RTi_StageDischargeRating =
		new RiversideDB_StageDischargeRating( sdr );
	}
///
	/*
	if ( Message.isDebugOn ) {
		Message.printDebug( 3, routine,
		"Added new StageDischargeRating object to the database " +
		"with dates: " + start_str + " - " + end_str +
		" and RatingTable_num = " + temp_sdr.getRatingTable_num() );
	}
	*/
///
	temp_sdr = null;

	//will need to make new RatingTable JWorksheet to go with new
	//StageDischargeRating object
	RiversideDB_RatingTable rt = new RiversideDB_RatingTable();
	rt.setRatingTable_num( rt_num);
	List v = new Vector();
	v.add( rt );
	JWorksheet worksheet = null;
	RiversideDB_RatingTable_TableModel tmr = null;
	try {
		tmr =
		new RiversideDB_RatingTable_TableModel( __dmi, v );
		RiversideDB_RatingTable_CellRenderer crr =
		new RiversideDB_RatingTable_CellRenderer(tmr);

		worksheet = new JWorksheet(
		crr, tmr, __worksheet_PropList);
	}
	catch (Exception e) {
		Message.printWarning(2, routine, e);
		worksheet = new JWorksheet(
		0, 0, __worksheet_PropList );
	}
	//set worksheet so it is known to TableModel and can
	//set is dirty!
	tmr.setWorksheet( worksheet );

	//see how many stage discharge rating objects there are.
	int size = 0;
	if ( __stageDischargeRating_vect != null ) {
	 	size = __stageDischargeRating_vect.size();
	}
	if ( size <= 0 ) {
		//adding first stagedischargerating object.
		//add this to the Global vector
 		__stageDischargeRating_vect.add( sdr );

		//add worksheet
 		__ratingTable_worksheet_vect.add( worksheet );
		v = null;
	}
	else {
		//we need to change END DATE of latest start-end date series
		//(top item in dates JComboBox) to be 1 minute before the
		//new start date we are adding.
		RiversideDB_StageDischargeRating sdr_old =
		(RiversideDB_StageDischargeRating)
 		__stageDischargeRating_vect.get(0);

		DateTime new_end_date= DateTime.parse(
		start_str, DateTime.FORMAT_YYYY_MM_DD_HH_mm);
		new_end_date.addMinute( -1) ;

		//set this as end date in object
		sdr_old.setEnd_Date( new_end_date.getDate() );
		//update vectors
 		__stageDischargeRating_vect.remove(0);
 		__stageDischargeRating_vect.add(0,sdr_old);
		//now add the completely new object with the new date range
 		__stageDischargeRating_vect.add(0,sdr);

		//make sure we update Vector of RatingTable worksheets too.
		//add entirely new JWorksheet
		//Vector v = __rating_JWorksheet.getAllData();
 		__ratingTable_worksheet_vect.add(0, worksheet );
	}

	//update JComboBox field in GUI accordingly
	size = __stageDischargeRating_vect.size();
	//clear out model that holds the start-to-end date ranges
 	__rating_tab_dates_model.removeAllElements();

	RiversideDB_StageDischargeRating new_sdr = null;
	DateTime sd= null;
	DateTime ed= null;
	for ( int i=0; i<size; i++ ) {
		new_sdr = (RiversideDB_StageDischargeRating)
 		__stageDischargeRating_vect.get(i);
		if ( new_sdr == null ) {
			continue;
		}
		sd= new DateTime( new_sdr.getStart_Date() );
		ed= new DateTime( new_sdr.getEnd_Date() );
		if ( Message.isDebugOn ) {
			Message.printDebug( 2, routine,
			"Start date for Ratings is: " + sd.toString() +
			" and end date is: " + ed.toString() );
		}
		//format dates: MM/DD/YY HH:mm:SS
 		__rating_tab_dates_model.addElement( sd.toString() +
		" to " + ed.toString() );
	}
	new_sdr = null;

	//update the fields
	set_rating_tab_fields( sdr,0 );
	sdr  = null;

} //end update_stagedischargerating_dates


/**
This method: <ul><li>determines if the current user, already known to the DMI,
has write permissions.  If the user does not have write permissions, the
<b>apply</b> and <b>close</b> buttons are disabled, leaving only the
<b>cancel</b> button enabled.</li><li>Fills in all the GUI fields according
to the data in the MeasLoc and related GeoLoc and StageDischargeRating
objects.</li></ul>
*/
protected void update_GUI_fields( ) {
	String routine = __class + ".update_GUI_fields";

	//first update Apply and Close buttons depending on
	//if user has write permissions
	if ( ! __canWriteMeasLoc ) {
 		JGUIUtil.setEnabled( __apply_JButton, false );
 		JGUIUtil.setEnabled( __close_JButton, false );
	}
	//////////////////////////////////
	///////// TOP Panel /////////////
	//////////////////////////////////
	//use the information from the MeasLoc
	//object to fill in the top fields.  The ID, we already have,
	//since it was preselected in the Tree.

	//ID -REQUIRED (guaranteed to have a value after verify_top_fields() )
 	__station_id_JTextField.setText( __preselected_ID_string );

	//NAME
	String name_string = null;
	name_string = __db_RTi_MeasLoc.getMeasLoc_name();

	if ( Message.isDebugOn ) {
		Message.printDebug( 15, routine, "Name for \"" +
 		__preselected_ID_string + "\" is \"" + name_string + "\"." );
	}

	//set the text in the TextField
 	__station_name_JTextField.setText( name_string );

	//SOURCE
	String source_string = null;
	source_string = __db_RTi_MeasLoc.getSource_abbrev();

	if ( Message.isDebugOn ) {
		Message.printDebug( 15, routine, "source for \"" +
 		__preselected_ID_string + "\" is \"" + source_string + "\"." );
	}
	if ( source_string != null ) {
		//set the source as selected in the JComboBox
		try {
			JGUIUtil.selectTokenMatches(
 			__station_source_JComboBox, true,
				" - ", 0, 0, source_string, NONE_STRING );
		}
		catch ( Exception e ) {
			Message.printWarning( 50, routine, e );
		}
	}

	//TYPE
	//Find the Station Type (A(area) or P(point) )for the type
	//Really do not need to use the Meas_loc_type object
	//because we know if an area is selected, it is
	//of type "A" and if a station is selected, it
	//is of Type "P".  The user can not change this (uneditable).
	//Already filled in the TextField when it was created

	//Measlocgroup
	int measlocgrp_num = -999;
	measlocgrp_num = __db_RTi_MeasLoc.getMeasLocGroup_num();
	if ( Message.isDebugOn ) {
		Message.printDebug( 15, routine, "MeasLocGroup for \"" +
 		__preselected_ID_string + "\" is \"" +
		measlocgrp_num + "\"." );
	}
	try {
		JGUIUtil.selectTokenMatches(
 		__station_measlocgrp_JComboBox, true,
		" - ", 0, 0, String.valueOf(measlocgrp_num), NONE_STRING );
	}
	catch ( Exception e ) {
		Message.printWarning( 50, routine, e );
	}
 	JGUIUtil.setEnabled( __station_measlocgrp_JComboBox, false );




	String source = null;
	source = __db_RTi_MeasLoc.getSource_abbrev();
	//set the source as selected in the JComboBox
	try {
		JGUIUtil.selectTokenMatches(
 		__station_source_JComboBox, true,
		" - ", 0, 0, source, NONE_STRING );
	}
	catch ( Exception e ) {
		Message.printWarning( 50, routine, e );
	}

	//////////////////////////////////
	///////// GEOGRAPHY TAB //////////
	//////////////////////////////////
	//Latitude
	double lat = -999.0;
	String lat_str = null;
	if ( !DMIUtil.isMissing( __db_RTi_GeoLoc.getLatitude() ) ) {
		lat = __db_RTi_GeoLoc.getLatitude();
		//format output precsion so format them at 6
		lat_str = StringUtil.formatString( lat, "%.6f" );
		//format string
 		__geog_tab_latitude_JTextField.setText( lat_str );
	}

	//longitude
	double lon = -999.0;
	String lon_str = null;
	if ( !DMIUtil.isMissing( __db_RTi_GeoLoc.getLongitude() ) ) {

		lon = __db_RTi_GeoLoc.getLongitude();
		//format output precsion
		lon_str = StringUtil.formatString( lon, "%.6f" );

 		__geog_tab_longitude_JTextField.setText( lon_str );
	}

	//X
	double x = -999.0;
	String x_str = null;
	if ( !DMIUtil.isMissing( __db_RTi_GeoLoc.getX() ) ) {
		x = __db_RTi_GeoLoc.getX();
		//format output precsion at 2
		x_str = StringUtil.formatString( x, "%.2f" );

 		__geog_tab_x_JTextField.setText( x_str );
	}

	//Y
	double y= -999.0;
	String y_str = null;
	if ( !DMIUtil.isMissing( __db_RTi_GeoLoc.getY() ) ) {
		y = __db_RTi_GeoLoc.getY();
		//format output precsion
		y_str = StringUtil.formatString( y, "%2.4f" );

 		__geog_tab_y_JTextField.setText(y_str );

	}

	//Country
	String country_string = null;
	country_string = __db_RTi_GeoLoc.getCountry();

 	__geog_tab_country_JTextField.setText( country_string);

	//State
	String state_string = null;
	state_string = __db_RTi_GeoLoc.getState();

 	__geog_tab_state_JTextField.setText( state_string);

	//Province
	String prov_string = null;
	prov_string = __db_RTi_GeoLoc.getCounty();

 	__geog_tab_county_JTextField.setText( prov_string);

	//Elevation
	double elev = -999.0;
	String elev_str = null;
	if ( !DMIUtil.isMissing( __db_RTi_GeoLoc.getElevation() ) ) {
		elev = __db_RTi_GeoLoc.getElevation();
		//format output precsion
		String prec = DataUnits.getOutputFormatString( "FT", 0, 3 );

		elev_str = StringUtil.formatString( elev, prec );
 		__geog_tab_elevation_JTextField.setText( elev_str );
	}
	//Units JComboBox
	String units_string = null;
	units_string = __db_RTi_GeoLoc.getElevation_units();

	if ( units_string != null ) {
		try {
			JGUIUtil.selectTokenMatches(
 			__geog_tab_units_JComboBox, true,
			" - ", 0, 0, units_string, "" );
		}
		catch ( Exception e ){
			Message.printWarning( 50, routine, e );
		}

	}

	//////////////////////////////////
	///////// RATING TAB //////////
	//////////////////////////////////
	//If MeasLoc is of type Point, should have the RATING Tab
	if ( __db_RTi_MeasLoc.getMeas_loc_type().equalsIgnoreCase( "P" ) ) {
		//update the JComboBox list model and then fill in
		//other fields.

		//update JComboBox field in GUI accordingly
		int size = __stageDischargeRating_vect.size();
		RiversideDB_StageDischargeRating new_sdr = null;
		DateTime sd= null;
		DateTime ed= null;
		for ( int i=0; i<size; i++ ) {
			new_sdr = (RiversideDB_StageDischargeRating)
 			__stageDischargeRating_vect.get(i);
			if ( new_sdr == null ) {
				continue;
			}
			if ( i == 0 ) {
				//since first item will be the one
				//selected by default, set it to be
				//the stagedischargerating object in memory
 				__previous_RTi_StageDischargeRating =
				new RiversideDB_StageDischargeRating(new_sdr );
			}
			sd= new DateTime( new_sdr.getStart_Date() );
			ed= new DateTime( new_sdr.getEnd_Date() );
			if ( Message.isDebugOn ) {
				Message.printDebug( 2, routine,
				"Start date for Ratings is: " + sd.toString() +
				" and end date is: " + ed.toString() );
			}
			//format dates: MM/DD/YY HH:mm:SS
 			__rating_tab_dates_model.addElement( sd.toString() +
			" to " + ed.toString() );
		}
		new_sdr = null;

		//update other GUI fields.
		if ( __stageDischargeRating_vect.size() > 0 ) {
			set_rating_tab_fields(
			(RiversideDB_StageDischargeRating)
 			__stageDischargeRating_vect.get(0), 0 );
		}
		/* should not be
		else {
			//make empty objects to pass in
			RiversideDB_StageDischargeRating sdr = new
			RiversideDB_StageDischargeRating();

			set_rating_tab_fields(
			(RiversideDB_StageDischargeRating) null, -999);
		}
		*/
	}
} //end update_GUI_fields


/**
Verifies and stores all the information on the AREA tab.
Currently not utilized.
The method <ul><li> fills in the <i>__gui</i> verions of the objects
in memory with the values that are currently set in the GUI</li>
<li>compares the values in the <i>__gui</i> version of the objects to the
<i>__db</i> version of the objects.  If the <i>__gui</i> versions differ
from the <i>__db</i> verions:<ul>
<li>the <i>__gui</i> versions are marked dirty (<i>.setDirty(true)</i>)</li>
<li>messages are added to the <i>__dirty_vect</i> indicating how the
<i>__gui</i> differs from the <i>__db</i> version (the <i>__db</i> version
remember, represents how the object is in the database itself) </li></ul>
</li></ul></ul>
@exception Exception if error encountered.
*/
public void verify_area_tab() throws Exception {
}//end verify_area_tab


/**
Verifies and stores all the information on the GEOGRAPHY tab.
The method <ul><li> fills in the <i>__gui</i> verions of the objects
in memory with the values that are currently set in the GUI</li>
<li>compares the values in the <i>__gui</i> version of the objects to the
<i>__db</i> version of the objects.  If the <i>__gui</i> versions differ
from the <i>__db</i> verions:<ul>
<li>the <i>__gui</i> versions are marked dirty (<i>.setDirty(true)</i>)</li>
<li>messages are added to the <i>__dirty_vect</i> indicating how the
<i>__gui</i> differs from the <i>__db</i> version (the <i>__db</i> version
remember, represents how the object is in the database itself) </li></ul>
</li></ul></ul>
@exception Exception thrown if error encountered.
*/
public void verify_geography_tab() throws Exception {
	String routine = __class + ".verify_geography_tab";

	//LATITUDE
	double db_lat = -999;
	double gui_lat = -999;
	String gui_lat_str = null;
	gui_lat_str = ( __geog_tab_latitude_JTextField.getText()).trim();

	//if what the user has entered is not a number, stop here.
	if ((gui_lat_str.length() > 0 ) &&
	( !StringUtil.isDouble( gui_lat_str ) ) ) {
		Message.printWarning( 1, routine,
		"Please enter a numeric value for the Latitude.", this );

		throw new Exception( "Geography Tab: Please add a " +
		"numeric value for the Latitude." );
	}

	//get value from object in memory
	db_lat = __db_RTi_GeoLoc.getLatitude();

	//if the lat is null in the GUI
	if (( gui_lat_str == null ) || ( gui_lat_str.length() <=0 ) ) {
		//if it is not null in the database, then there is a change
		//if ( db_lat != DMIUtil.MISSING_DOUBLE ) {}
		if ( !DMIUtil.isMissing( db_lat ) ) {
			//there is a difference
 			__gui_RTi_GeoLoc.setDirty( true );
 			__dirty_vect.add(
			"Change latitude from \"" + db_lat + "\" to \"" +
			DMIUtil.MISSING_DOUBLE + "\"");

 			__gui_RTi_GeoLoc.setLatitude( DMIUtil.MISSING_DOUBLE );
		}
	}
	else {
		//convert gui lat value to DOUBLE
		gui_lat = StringUtil.atod( gui_lat_str );

		//Values in the GUI -see if they match values from database
		if ( DMIUtil.isMissing(db_lat) ) {
			//there is a difference because we have a value in the
			//gui and not in the database
 			__gui_RTi_GeoLoc.setDirty( true );
 			__dirty_vect.add(
			"Change latitude from \"" + DMIUtil.MISSING_DOUBLE +
			"\" to \"" + gui_lat_str + "\"");

 			__gui_RTi_GeoLoc.setLatitude( gui_lat);
		}
		else {
			//format the values to same precision
			//to compare it to the original value,
			//format it to %.6f
			String formatted_gui_str = null;
			String formatted_db_str = null;
			formatted_gui_str = StringUtil.formatString(
			gui_lat, "%.6f" );
			formatted_db_str = StringUtil.formatString(
			db_lat, "%.6f" );
			if (! formatted_gui_str.equalsIgnoreCase( formatted_db_str ) ) {
				//update object
 				__gui_RTi_GeoLoc.setDirty( true );
 				__dirty_vect.add(
				"Change latitude from \"" + db_lat +
				"\" to \"" + gui_lat + "\"");

 				__gui_RTi_GeoLoc.setLatitude( gui_lat );
			}
		}
	}

	//LONGITUDE
	double db_lon = -999;
	double gui_lon = -999;
	String gui_lon_str= null;
	gui_lon_str= ( __geog_tab_longitude_JTextField.getText()).trim();

	//if what the user has entered is not a number, stop here.
	if ((gui_lon_str.length() > 0 ) &&
	( !StringUtil.isDouble( gui_lon_str ) ) ) {
		Message.printWarning( 1, routine,
		"Please enter a numeric value for the Longitude.", this );

		throw new Exception( "Geography Tab: Please add a " +
		"numeric value for the Longitude." );
	}

	//get value from object in memory
	db_lon = __db_RTi_GeoLoc.getLongitude();

	//if the lon is null in the GUI
	if (( gui_lon_str == null ) || ( gui_lon_str.length() <=0 ) ) {
		//if it is not null in the database, then there is a change
		//if ( db_lon != DMIUtil.MISSING_DOUBLE ) {
		if ( !DMIUtil.isMissing(db_lon) ) {
			//there is a difference
 			__gui_RTi_GeoLoc.setDirty( true );
 			__dirty_vect.add(
			"Change longitude from \"" + db_lon + "\" to \"" +
			DMIUtil.MISSING_DOUBLE + "\"");

 			__gui_RTi_GeoLoc.setLongitude( DMIUtil.MISSING_DOUBLE );
		}
	}
	else {
		//convert gui lon value to DOUBLE
		gui_lon = StringUtil.atod( gui_lon_str );

		//Values in the GUI -see if they match values from database
		if ( DMIUtil.isMissing(db_lon) ) {
			//there is a difference because we have a value in the
			//gui and not in the database
 			__gui_RTi_GeoLoc.setDirty( true );
 			__dirty_vect.add(
			"Change longitude from \"" + DMIUtil.MISSING_DOUBLE +
			"\" to \"" + gui_lon_str + "\"");

 			__gui_RTi_GeoLoc.setLongitude( gui_lon);
		}
		else {
			//format the values to same precision
			//to compare it to the original value,
			//format it to %.6f
			String formatted_gui_str = null;
			String formatted_db_str = null;
			formatted_gui_str = StringUtil.formatString(
			gui_lon, "%.6f" );
			formatted_db_str = StringUtil.formatString(
			db_lon, "%.6f" );
			if (! formatted_gui_str.equalsIgnoreCase( formatted_db_str ) ) {
				//update object
 				__gui_RTi_GeoLoc.setDirty( true );
 				__dirty_vect.add(
				"Change longitude from \"" + db_lon +
				"\" to \"" + gui_lon +"\"" );

 				__gui_RTi_GeoLoc.setLongitude( gui_lon );
			}
		}
	}

	//X
	double db_x = -999;
	double gui_x = -999;
	String gui_x_str= null;
	gui_x_str= ( __geog_tab_x_JTextField.getText()).trim();

	//if what the user has entered is not a number, stop here.
	if ((gui_x_str.length() > 0 ) &&
	( !StringUtil.isDouble( gui_x_str ) ) ) {
		Message.printWarning( 1, routine,
		"Please enter a numeric value for the X.", this );

		throw new Exception( "Geography Tab: Please add a " +
		"numeric value for the X." );
	}

	//get value from object in memory
	db_x = __db_RTi_GeoLoc.getX();

	//if the x is null in the GUI
	if (( gui_x_str == null ) || ( gui_x_str.length() <=0 ) ) {
		//if it is not null in the database, then there is a change
		//if ( db_x != DMIUtil.MISSING_DOUBLE ) {}
		if ( !DMIUtil.isMissing( db_x  ) ) {
			//there is a difference
 			__gui_RTi_GeoLoc.setDirty( true );
 			__dirty_vect.add(
			"Change X from \"" + db_x + "\" to \"" +
			DMIUtil.MISSING_DOUBLE + "\"");

 			__gui_RTi_GeoLoc.setX( DMIUtil.MISSING_DOUBLE );
		}
	}
	else {
		//convert gui x value to Double
		gui_x = StringUtil.atod( gui_x_str );

		//Values in the GUI -see if they match values from database
		if ( DMIUtil.isMissing(db_x) ) {
			//there is a difference because we have a value in the
			//gui and not in the database
 			__gui_RTi_GeoLoc.setDirty( true );
 			__dirty_vect.add(
			"Change X from \"" + DMIUtil.MISSING_DOUBLE +
			"\" to \"" + gui_x_str + "\"" );

 			__gui_RTi_GeoLoc.setX( gui_x);
		}
		else {
			//format the values to same precision
			//to compare it to the original value,
			//format it to %.6f
			String formatted_gui_str = null;
			String formatted_db_str = null;
			formatted_gui_str = StringUtil.formatString(
			gui_x, "%.6f" );
			formatted_db_str = StringUtil.formatString(
			db_x, "%.6f" );
			if (! formatted_gui_str.equalsIgnoreCase( formatted_db_str ) ) {
				//update object
 				__gui_RTi_GeoLoc.setDirty( true );
 				__dirty_vect.add(
				"Change X from \"" + db_x +
				"\" to \"" + gui_x + "\"" );

 				__gui_RTi_GeoLoc.setX( gui_x );
			}
		}
	}

	//Y
	double db_y = -999;
	double gui_y = -999;
	String gui_y_str= null;
	gui_y_str= ( __geog_tab_y_JTextField.getText()).trim();

	//if what the user has entered is not a number, stop here.
	if ( (gui_y_str.length() > 0 ) &&
	( !StringUtil.isDouble( gui_y_str ) ) ) {
		Message.printWarning( 1, routine,
		"Please enter a numeric value for the Y.", this );

		throw new Exception( "Geography Tab: Please add a " +
		"numeric value for the Y." );
	}

	//get value from object in memory
	db_y = __db_RTi_GeoLoc.getY();

	//if the Y is null in the GUI
	if (( gui_y_str == null ) || ( gui_y_str.length() <=0 ) ) {
		//if it is not null in the database, then there is a change
		if ( db_y != DMIUtil.MISSING_LONG ) {
			//there is a difference
 			__gui_RTi_GeoLoc.setDirty( true );
 			__dirty_vect.add(
			"Change Y from \"" + db_y + "\" to \"" +
			DMIUtil.MISSING_LONG + "\"");

 			__gui_RTi_GeoLoc.setY( DMIUtil.MISSING_LONG );
		}
	}
	else {
		//convert gui Y value to Double
		gui_y = StringUtil.atod( gui_y_str );

		//Values in the GUI -see if they match values from database
		if ( db_y == DMIUtil.MISSING_LONG ) {
			//there is a difference because we have a value in the
			//gui and not in the database
 			__gui_RTi_GeoLoc.setDirty( true );
 			__dirty_vect.add(
			"Change Y from \"" + DMIUtil.MISSING_LONG +
			"\" to \"" + gui_y_str + "\"");

 			__gui_RTi_GeoLoc.setY( gui_y);
		}
		else {
			//format the values to same precision
			//to compare it to the original value,
			//format it to %.6f
			String formatted_gui_str = null;
			String formatted_db_str = null;
			formatted_gui_str = StringUtil.formatString(
			gui_y, "%.6f" );
			formatted_db_str = StringUtil.formatString(
			db_y, "%.6f" );
			if (! formatted_gui_str.equalsIgnoreCase( formatted_db_str ) ) {

				//update object
 				__gui_RTi_GeoLoc.setDirty( true );
 				__dirty_vect.add(
				"Change Y from \"" + db_y +
				"\" to \"" + gui_y + "\"");

 				__gui_RTi_GeoLoc.setY( gui_y );
			}
		}
	}


	//Country
	String gui_country =
	( __geog_tab_country_JTextField.getText()).trim().toUpperCase();
	String db_country = __db_RTi_GeoLoc.getCountry();

	if (( gui_country == null ) || (gui_country.length() <=0 ) ) {
		//make sure it was missing in db
		if ( ! db_country.equalsIgnoreCase( DMIUtil.MISSING_STRING)){}
		if ( !DMIUtil.isMissing( db_country ) ) {
			//object dirty
 			__gui_RTi_GeoLoc.setDirty( true );
 			__dirty_vect.add(
			"Change Country from \"" + db_country +
			"\" to \"" + gui_country + "\"" );

 			__gui_RTi_GeoLoc.setCountry( gui_country );
		}
	}
	else {
		if (( DMIUtil.isMissing( db_country ) ) ||
		( !db_country.equalsIgnoreCase( gui_country ) ) ) {

 			__gui_RTi_GeoLoc.setDirty( true );
 			__dirty_vect.add(
			"Change Country from \"" + db_country +
			"\" to \"" + gui_country + "\"" );

 			__gui_RTi_GeoLoc.setCountry( gui_country );
		}
	}


	//State
	String gui_state =
	( __geog_tab_state_JTextField.getText()).trim().toUpperCase();
	String db_state = __db_RTi_GeoLoc.getState();

	if (( gui_state == null ) || (gui_state.length() <=0 ) ) {
		//make sure it was missing in db
		if ( ! DMIUtil.isMissing( db_state ) ) {
			//object dirty
 			__gui_RTi_GeoLoc.setDirty( true );
 			__dirty_vect.add(
			"Change State from \"" + db_state +
			" to \"" + gui_state + "\"");

 			__gui_RTi_GeoLoc.setState( gui_state );
		}
	}
	else {
		if (( DMIUtil.isMissing( db_state ) ) ||
		( !db_state.equalsIgnoreCase( gui_state ) ) ) {

 			__gui_RTi_GeoLoc.setDirty( true );
 			__dirty_vect.add(
			"Change State from \"" + db_state +
			"\" to \"" + gui_state + "\"");

 			__gui_RTi_GeoLoc.setState( gui_state );
		}
	}

	//County
	String gui_county =
	( __geog_tab_county_JTextField.getText()).trim().toUpperCase();
	String db_county = __db_RTi_GeoLoc.getCounty();

	if (( gui_county == null ) || (gui_county.length() <=0 ) ) {
		//make sure it was missing in db
		if ( ! DMIUtil.isMissing( db_county ) ) {
			//object dirty
 			__gui_RTi_GeoLoc.setDirty( true );
 			__dirty_vect.add(
			"Change County from \"" + db_county +
			"\" to \"" + gui_county + "\"" );

 			__gui_RTi_GeoLoc.setCounty( gui_county );
		}
	}
	else {
		if (( DMIUtil.isMissing( db_county ) ) ||
		( !db_county.equalsIgnoreCase( gui_county ) ) ) {

 			__gui_RTi_GeoLoc.setDirty( true );
 			__dirty_vect.add(
			"Change County from \"" + db_county +
			"\" to \"" + gui_county +"\"" );

 			__gui_RTi_GeoLoc.setCounty( gui_county );
		}
	}

	//ELEVATION
	double db_elev = -999;
	double gui_elev = -999;
	String gui_elev_str= null;
	gui_elev_str= ( __geog_tab_elevation_JTextField.getText()).trim();

	//if what the user has entered is not a number, stop here.
	if ((gui_elev_str.length() > 0 ) &&
	( !StringUtil.isDouble( gui_elev_str ) ) ) {
		Message.printWarning( 1, routine,
		"Please enter a numeric value for the Elevation.", this );

		throw new Exception( "Geography Tab: Please add a " +
		"numeric value for the Elevation." );
	}

	//get value from object in memory
	db_elev = __db_RTi_GeoLoc.getElevation();

	//if the Elevation is null in the GUI
	if (( gui_elev_str == null ) || ( gui_elev_str.length() <=0 ) ) {
		//if it is not null in the database, then there is a change
		if ( !DMIUtil.isMissing( db_elev ) ) {
		//if ( db_elev != DMIUtil.MISSING_LONG ) {}
			//there is a difference
 			__gui_RTi_GeoLoc.setDirty( true );
 			__dirty_vect.add(
			"Change Elevation from \"" + db_elev + "\" to \"" +
			DMIUtil.MISSING_LONG + "\"");

 			__gui_RTi_GeoLoc.setElevation( DMIUtil.MISSING_LONG );
		}
	}
	else {
		//convert gui Elevation value to DOUBLE
		gui_elev = StringUtil.atod( gui_elev_str );

		//Values in the GUI -see if they match values from database
		if ( db_elev == DMIUtil.MISSING_LONG ) {}
		if ( DMIUtil.isMissing( db_elev ) ) {
			//there is a difference because we have a value in the
			//gui and not in the database
 			__gui_RTi_GeoLoc.setDirty( true );
 			__dirty_vect.add(
			"Change Elevation from \"" + DMIUtil.MISSING_LONG +
			"\" to \"" + gui_elev_str +"\"" );

 			__gui_RTi_GeoLoc.setElevation( gui_elev);
		}
		else {
			//format the values to same precision
			//to compare it to the original value,
			//format it to %.6f
			String formatted_gui_str = null;
			String formatted_db_str = null;
			formatted_gui_str = StringUtil.formatString(
			gui_elev, "%.6f" );
			formatted_db_str = StringUtil.formatString(
			db_elev, "%.6f" );
			if (! formatted_gui_str.equalsIgnoreCase( formatted_db_str ) ) {

				//update object
 				__gui_RTi_GeoLoc.setDirty( true );
 				__dirty_vect.add(
				"Change Elevation from \"" + db_elev +
				"\" to \"" + gui_elev +"\"" );

 				__gui_RTi_GeoLoc.setElevation( gui_elev );
			}
		}
	}

	//ELEVATION Data Units -even if elevation is null, units are required
	String gui_units = (String)
 	__geog_tab_units_JComboBox.getSelected();
	int ind=-999;
	ind = gui_units.indexOf(" -" );
	if ( ind > 0 ) {
		gui_units = (gui_units.substring(0, ind)).trim();
	}
	String db_units = __db_RTi_GeoLoc.getElevation_units();

	//compare it to original it (CAN BE Null coming from the db)
	if ( ( DMIUtil.isMissing( db_units ) ) ||
	( !db_units.equalsIgnoreCase( gui_units ) ) ) {
		//mark dirty
 		__gui_RTi_GeoLoc.setDirty( true );
 		__dirty_vect.add(
		"Change Elevation Units from \"" +
		db_units + "\" to \"" + gui_units + "\"" );

		//set the new value in memory
 		__gui_RTi_GeoLoc.setElevation_units( gui_units );
	}

} //end verify_geography_tab

/**
Verifies and stores all the information on the RATINGS tab.
This method, reads in a Vector of related StageDischargeRating objects
directly from the database and compares them, field by field, object by
object, to the StageDischargeRating objects currently represented in the
JWorksheet.  If there are differnces:<ul><li> the objects in the JWorksheet
are marked dirty (<i>.setDirty(true)</i>)</li>
<li>messages are added to the <i>__dirty_vect</i> indicating how the
StageDischargeRating object in the JWorksheet differs from the
related StageDischargeRating objects in the database.
@exception Exception thrown if error encountered.
*/
public void verify_rating_tab() throws Exception {
	String routine = __class + ".verify_rating_tab";

	//reread in Vector from Database to compare to the
	//vector of stage discharge rating objects we have in the GUI now.
	List db_sdr_vect = null;
	try {
		db_sdr_vect =
 		__dmi.readStageDischargeRatingListForMeasLoc_num(
 		__db_RTi_MeasLoc.getMeasLoc_num() );
	}
	catch ( Exception e ) {
		Message.printWarning( 2, routine, e );
		Message.printWarning( 2, routine,
		"Unable to determine the " +
		"StageDischargeRating objects associated " +
		"with Location identified by MeasLoc_num: " +
 		__db_RTi_MeasLoc.getMeasLoc_num() );
		db_sdr_vect =  new Vector();
	}

	int gui_sdr_size = db_sdr_vect.size();
	int db_sdr_size = __stageDischargeRating_vect.size();
	//go through and compare object to object... if the objects are out
	//of order, assume they are dirty
	//GUI version has to be same size or less than DB size since we
	//don't let them remove StageDischargeRating objects from GUI

	boolean gui_dirty = false;
	if ( gui_sdr_size != db_sdr_size ) {
		//know we changed things, so just globally update
 		__dirty_vect.add( "Save changes to " +
		"StageDischargeRating objects." );
		gui_dirty = true;
		return;
	}

	//else start going through comparing
	for ( int i=0; i< gui_sdr_size; i++ ) {
		RiversideDB_StageDischargeRating gui_sdr = null;
		gui_sdr =(RiversideDB_StageDischargeRating)
 		__stageDischargeRating_vect.get(i);

		//get Start date - this is the one date that
		//distinguishes if a new StageDischargeRating object has
		//been added
		DateTime gui_start_date = new DateTime(
		gui_sdr.getStart_Date() );
		DateTime gui_end_date = new DateTime( gui_sdr.getEnd_Date() );

		for ( int k=0; k < db_sdr_size; k++ ) {
			RiversideDB_StageDischargeRating db_sdr = null;
			db_sdr =(RiversideDB_StageDischargeRating)
			db_sdr_vect.get(i);

			DateTime db_start_date = new DateTime(
			db_sdr.getStart_Date() );

			if (( !gui_start_date.equals( db_start_date,
			DateTime.PRECISION_MINUTE ) )) {
				//we know the gui has been updated,
				//so mark all objects as dirty
				gui_sdr.setDirty( true );
				gui_dirty = true;
 				__dirty_vect.add(
				"Add new StageDischargeRating object " +
				" and RatingTable values " +
				"with dates: \"" + gui_start_date.toString() +
				"\" to \"" + gui_end_date.toString() + "\"" );
				//that is enough to know changes were made,
				//just return
				break;
			}
			//else start going through fields
			//go through and compare fields
			DateTime db_end_date = new DateTime(
			db_sdr.getEnd_Date() );
			if (!db_end_date.equals( gui_end_date,
			DateTime.PRECISION_MINUTE ) ) {
 				__dirty_vect.add(
				"Update StageDischargeRating object: " +
				"with dates: \"" +
				gui_start_date.toString() +
				"\" to \"" + gui_end_date.toString());
				gui_dirty = true;
				break;
				/*
				"\" to have new End Date of: \"" +
				db_end_date.toString() + "\"" );
				*/
			}

			//discharge units
			if ( !db_sdr.getDischarge_Units().equalsIgnoreCase(
			gui_sdr.getDischarge_Units() )) {
 			__dirty_vect.add(
				"Update StageDischargeRating object: " +
				"with dates: \"" +
				gui_start_date.toString() +
				 "\" to \"" + gui_end_date.toString());
				gui_dirty = true;
				break;
				/*
				" to have Discharge units: \"" +
				gui_sdr.getDischarge_Units() + "\"" );
				*/
			}
			// flood level
			if ( db_sdr.getFlood_Level() !=
			gui_sdr.getFlood_Level() ) {
				gui_dirty = true;
 				__dirty_vect.add(
				"Update StageDischargeRating object: " +
				"with dates: \"" +
				gui_start_date.toString() +
				"\" to \"" + gui_end_date.toString());
				//" to have Flood level: \"" +
				//gui_sdr.getFlood_Level() + "\"" );
				break;
			}
			// Gage datum units
			if ( !db_sdr.getGage_Datum_Units().equalsIgnoreCase(
			gui_sdr.getGage_Datum_Units() )) {
				gui_dirty = true;
 				__dirty_vect.add(
				"Update StageDischargeRating object: " +
				"with dates: \"" +
				gui_start_date.toString() +
				 "\" to \"" + gui_end_date.toString());
				//" to have Datum units: \"" +
				//gui_sdr.getGage_Datum_Units()+"\"" );
				break;
			}
			// gage zero datum
			if ( db_sdr.getGage_Zero_Datum() !=
			gui_sdr.getGage_Zero_Datum() ) {
				gui_dirty = true;
 				__dirty_vect.add(
				"Update StageDischargeRating object: " +
				"with dates: \"" +
				gui_start_date.toString() +
				"\" to \"" + gui_end_date.toString());
				//" to have Gage Datum level: \"" +
				//gui_sdr.getGage_Zero_Datum() + "\"" );
				break;
			}
			// interpolation method
			if ( !db_sdr.getInterpolation_Method().equalsIgnoreCase(
			gui_sdr.getInterpolation_Method() )) {
				gui_dirty = true;
 				__dirty_vect.add(
				"Update StageDischargeRating object: " +
				"with dates: \"" +
				gui_start_date.toString() +
				"\" to \"" + gui_end_date.toString());
				//" to have Interpolation Method: \"" +
				//gui_sdr.getInterpolation_Method() +
				//"\"" );
				break;
			}
			//Stage units
			if ( !db_sdr.getStage_Units().equalsIgnoreCase(
			gui_sdr.getStage_Units() )) {
				gui_dirty = true;
 				__dirty_vect.add(
				"Update StageDischargeRating object: " +
				"with dates: \"" +
				gui_start_date.toString() +
				"\" to \"" + gui_end_date.toString());
				//" to have Stage units: \"" +
				//gui_sdr.getStage_Units() + "\"" );
				break;
			}
			// warning level
			if ( db_sdr.getWarning_Level() !=
			gui_sdr.getWarning_Level() ) {
				gui_dirty = true;
 				__dirty_vect.add(
				"Update StageDischargeRating object: " +
				"with dates: \"" +
				gui_start_date.toString() +
				"\" to \"" + gui_end_date.toString());
				//" to have Warning level: \"" +
				//gui_sdr.getWarning_Level() + "\"" );
				break;
			}

			//now go through the RatingTable objects
			//RiversideDB_RatingTable rt = null;
			List db_rt_v = null;
			try {
				db_rt_v = __dmi.
				readRatingTableListForRatingTable_num(
				db_sdr.getRatingTable_num() );
			}
			catch ( Exception e ){
				Message.printWarning( 2, routine, e );
				//rt = new RiversideDB_RatingTable();
			}

			List gui_rt_v =( (JWorksheet)__ratingTable_worksheet_vect.get( i ) ).getAllData();

			//compare the data in the 2 vectors
			int gui_rt_size = 0;
			int db_rt_size = 0;
			if ( gui_rt_v != null  ) {
				gui_rt_size = gui_rt_v.size();
			}
			if ( db_rt_v != null ) {
				db_rt_size = db_rt_v.size();
			}
			if ( gui_rt_size != db_rt_size ) {
 				__dirty_vect.add(
				"Save changes to the RatingTable for " +
				"StageDischargeRating object "+
				"with dates: \"" +
				gui_start_date.toString() +
				"\" to \"" +
				gui_end_date.toString() );
				gui_dirty = true;
				break;
			}
			else {
				//go through and start comparing values
				RiversideDB_RatingTable db_rt = null;
				RiversideDB_RatingTable gui_rt = null;
				for ( int p=0; p<db_rt_size;p++ ) {
					db_rt =
					(RiversideDB_RatingTable)
					db_rt_v.get(p);

					gui_rt =
					(RiversideDB_RatingTable)
					gui_rt_v.get(p);

					//compare fields
					double gui_v1 =-999;
					double gui_v2 =-999;
					double gui_s1 =-999;
					double db_v1 =-999;
					double db_v2 =-999;
					double db_s1 =-999;
					gui_v1 = gui_rt.getValue1();
					gui_v2 = gui_rt.getValue2();
					gui_s1 = gui_rt.getShift1();
					db_v1 = db_rt.getValue1();
					db_v2 = db_rt.getValue2();
					db_s1 = db_rt.getShift1();
					if (( gui_v1 != db_v1) ||
					(gui_v2 != db_v2) ||
					(gui_s1 != db_s1 ) ) {
 						__dirty_vect.add(
						"Save changes to the "+
						"data of the " +
						"RatingTable for " +
						"StageDischargeRating "+
						"object "+
						"with dates: \"" +
						gui_start_date.
						toString() +
						"\" to \"" +
						gui_end_date.
						toString() );
						gui_dirty = true;
						break;
					}
				}//end p
			}//end else
			db_sdr = null;

			if ( gui_dirty ) {
				break;
			}
		} //end k
		if ( gui_dirty ) {
			break;
		}
		gui_sdr = null;
	}//end i


	if ( gui_dirty ) {
		for ( int i=0; i< gui_sdr_size; i++ ) {
			RiversideDB_StageDischargeRating gui_sdr = null;
			gui_sdr =(RiversideDB_StageDischargeRating)
 			__stageDischargeRating_vect.get(i);
			gui_sdr.setDirty( true );

			//update vector
 			__stageDischargeRating_vect.remove(i);
 			__stageDischargeRating_vect.add(i, gui_sdr);

		}
	}

}//end verify_rating_tab

/**
Verifies and stores all the information on the STATION tab.
The method <ul><li> fills in the <i>__gui</i> verions of the objects
in memory with the values that are currently set in the GUI</li>
<li>compares the values in the <i>__gui</i> version of the objects to the
<i>__db</i> version of the objects.  If the <i>__gui</i> versions differ
from the <i>__db</i> verions:<ul>
<li>the <i>__gui</i> versions are marked dirty (<i>.setDirty(true)</i>)</li>
<li>messages are added to the <i>__dirty_vect</i> indicating how the
<i>__gui</i> differs from the <i>__db</i> version (the <i>__db</i> version
remember, represents how the object is in the database itself) </li></ul>
</li></ul></ul>
Currently not utilized.
@exception Exception thrown if error encountered.
*/
public void verify_station_tab() throws Exception {
}//end verify_station_tab


/**
Verifies all the information in the top portion of the GUI.
The method <ul><li> fills in the <i>__gui</i> verions of the objects
in memory with the values that are currently set in the GUI</li>
<li>compares the values in the <i>__gui</i> version of the objects to the
<i>__db</i> version of the objects.  If the <i>__gui</i> versions differ
from the <i>__db</i> verions:<ul>
<li>the <i>__gui</i> versions are marked dirty (<i>.setDirty(true)</i>)</li>
<li>messages are added to the <i>__dirty_vect</i> indicating how the
<i>__gui</i> differs from the <i>__db</i> version (the <i>__db</i> version
remember, represents how the object is in the database itself) </li></ul>
</li></ul></ul>
@exception Exception thrown if error encountered.
*/
public void verify_top_fields() throws Exception {
	String routine = __class + ".verify_top_fields";

	//IDENTIFIER
	String gui_id = ( __station_id_JTextField.getText()).trim().toUpperCase();
	String db_id = __db_RTi_MeasLoc.getIdentifier();

	//assign it to global variables - if a totally new MeasLoc
	//object is being created, the __preselected_ID_string will
	//be filled in here for the first time with the name of the new MeasLoc
 	__preselected_ID_string = gui_id;

	//Set the setDirty flag if the current state of the
	//MeasLoc object in the GUI does not match that of
	//the MeasLoc object as stored in memory.
	//Check the Identifier
	if ( !db_id.equalsIgnoreCase( gui_id ) ) {
		//make sure it is a unique ID--
		//can not have repeats of same type in the same MeasLocGroup.
		long gui_measLocGroup_num =
 		__db_RTi_MeasLoc.getMeasLocGroup_num();

		//base type off title...
		String gui_type = null;
		if ( __title.indexOf( "Station" ) >= 0 ) {
			gui_type = "P";
		}
		else { gui_type = "A"; }

		//now check through vector of all
		//measlocs to make sure there is not
		//already a measloc with same id and type.
		int size=0;
		if ( __RTi_MeasLoc_vect != null ) {
			size = __RTi_MeasLoc_vect.size();
		}
		RiversideDB_MeasLoc ml = null;
		String ml_id= null;
		for ( int i=0; i<size; i++ ) {
			ml =( RiversideDB_MeasLoc)__RTi_MeasLoc_vect.get(i);

			//get measloc_ids
			ml_id =ml.getIdentifier();

			//check to see if TYPE is the same...
			//and if MeasLocGroup is the same...
			if( ( ml_id.equalsIgnoreCase( gui_id ) ) &&
			ml.getMeas_loc_type().equalsIgnoreCase( gui_type) &&
			(ml.getMeasLocGroup_num() ==  gui_measLocGroup_num ) ) {

				Message.printWarning( 1, routine,
				"Unable to add Duplicate " +
				"MeasLoc Identifier: \"" +
				ml_id + "\".", this );

				throw new Exception (
				"Duplicate MeasLoc " +
				"Identifier. Please assign a " +
				"unique MeasLoc Identifier. " +
				"Unable to save current " +
				"MeasLoc information." );
			}
		}

		//else we have a new and unique id, so can continue on.
		//set object dirty
 		__gui_RTi_MeasLoc.setDirty( true );
 		__dirty_vect.add("Change Identifier from \"" +
		db_id + "\" to \"" + gui_id + "\"" );

		//set the new value in memory
 		__gui_RTi_MeasLoc.setIdentifier( gui_id );
	}

	//NAME - REQUIRED
	String gui_name =
	( __station_name_JTextField.getText()).trim().toUpperCase();
	String db_name = __db_RTi_MeasLoc.getMeasLoc_name();

	//if the name was originally null in the database (it is
	//required in the GUI ) or if there is a different in values,
	//update object in memory
	if ( ( DMIUtil.isMissing( db_name ) ) ||
	( !db_name.equalsIgnoreCase( gui_name ) ) ) {

		//mark dirty
 		__gui_RTi_MeasLoc.setDirty( true );
 		__dirty_vect.add("Change Name from \"" +
		db_name + "\" to \"" + gui_name + "\"" );

		//set the new value in memory
 		__gui_RTi_MeasLoc.setMeasLoc_name( gui_name );
	}

	//SOURCE
	String gui_source = (String)
 	__station_source_JComboBox.getSelected();

	String db_source = __db_RTi_MeasLoc.getSource_abbrev();
	int ind = -999;
	ind = gui_source.indexOf( " -" );
	if ( ind > 0 ) {
		gui_source = (gui_source.substring(0, ind)).trim();
	}
	//compare it to original it (CAN BE Null coming from the db)
	if ( ( DMIUtil.isMissing( db_source ) ) ||
	( !db_source.equalsIgnoreCase( gui_source ) ) ) {
		//mark dirty
 		__gui_RTi_MeasLoc.setDirty( true );
 		__dirty_vect.add("Change Type from \"" +
		db_source + "\" to \"" + gui_source + "\"" );

		//set the new value in memory
 		__gui_RTi_MeasLoc.setSource_abbrev( gui_source );
	}

	//TYPE - non editable textfield... and set in memory in constructor.

} //end verify_top_fields


/////////////////////////////////////////////////////////////////
////////////////////////  ACTIONS ///////////////////////////////
/////////////////////////////////////////////////////////////////
/**
The event handler manages action events.
@param event Event to handle.
*/
public void actionPerformed (ActionEvent event) {
	String routine = __class + ".actionPerformed";

	Object source = event.getSource();
	if ( source.equals( __apply_JButton ) ) {

		boolean blnUpdated = true;

		//REQUIRED Fields
		try {
			checkRequiredInput();
		}
		catch ( Exception e ) {
			//then there was an error so do not
			//update object in memory or in database.
			Message.printWarning( 2, routine, e );
			blnUpdated= false;
		}

		//update the "GUI" object in memory
		if ( blnUpdated ) {
			try {
				update_RiversideDB_objects();
			}
			catch( Exception e ) {
				Message.printWarning( 2, routine, e );
				blnUpdated=false;
			}
		}
		if ( blnUpdated ) {
			try {
				//update database itself
				update_database();
			}
			catch( Exception e ) {
				Message.printWarning( 2, routine, e );
				blnUpdated=false;
				//keep __db_RTi_GeoLoc
				//and __db_RTi_MeasLoc in memory!

				//update the __gui_ versions to be the
				//the memory version again since update failed.
 				__gui_RTi_GeoLoc = null;
 				__gui_RTi_MeasLoc = null;
 				__gui_RTi_GeoLoc =
				new RiversideDB_Geoloc( __db_RTi_GeoLoc );
 				__gui_RTi_MeasLoc =
				new RiversideDB_MeasLoc( __db_RTi_MeasLoc );

				//FIlls __stageDischargeRating_vect and
				//_ratingTable_worksheet_vect vectors!
				fillStageDischargeRatingAndRatingTable_vectors();
			}
		}

		if ( blnUpdated ) {
			//if we got this far, the database was updated,
			//so update objects in memory.  The __gui_ object
			//was written to the database, so now the
			//_db_ object should equal the __gui_ object
 			__db_RTi_GeoLoc = null;
 			__db_RTi_MeasLoc = null;
 			__db_RTi_GeoLoc =
			new RiversideDB_Geoloc( __gui_RTi_GeoLoc );
 			__db_RTi_MeasLoc =
			new RiversideDB_MeasLoc( __gui_RTi_MeasLoc );
 			__db_RTi_GeoLoc.setDirty( false );
 			__db_RTi_MeasLoc.setDirty( false );

 			__gui_RTi_GeoLoc = null;
 			__gui_RTi_MeasLoc = null;

			//FIlls __stageDischargeRating_vect and
			//_ratingTable_worksheet_vect vectors!
			fillStageDischargeRatingAndRatingTable_vectors();
		}

	} //end apply
	else if ( source.equals( __cancel_JButton ) ) {
		if( ( __cautious_mode ) && ( ! __bln_new_object ) ) {
			//create and update __gui_ objects in memory
			//The only reason to do this is to provide the
			//user with a Confirm Cancel message.
			try {
				update_RiversideDB_objects();
			}
			catch( Exception e ) {
				Message.printWarning( 2, routine, e);

				windowManagerClose();
			}
			boolean sdr_dirty = false;
			if ( __db_RTi_MeasLoc.getMeas_loc_type().
			equalsIgnoreCase( "P" ) ) {
				//go through vector StageDischargeRating
				//objects to see if it is dirty.
				int numb_sdr = __stageDischargeRating_vect.size();
				RiversideDB_StageDischargeRating sdr =null;
				for ( int i=0;i<numb_sdr;i++ ) {
					sdr = (RiversideDB_StageDischargeRating)
 					__stageDischargeRating_vect.get(i);
					if ( sdr == null ) {
						continue;
					}
					if ( sdr.isDirty() ) {
						sdr_dirty = true;
						break;
					}
				}
			}

			if ( ( __gui_RTi_GeoLoc.isDirty()) ||
			( __gui_RTi_MeasLoc.isDirty() ) ||
			sdr_dirty ) {
				//holds messages from __dirty_vect
				StringBuffer b = new StringBuffer();
				for ( int i=0; i< __dirty_vect.size(); i++ ) {
					b.append( (String)
 					__dirty_vect.get(i) + "\n" );
				}

				//write out a confirmation message.
				int x = new ResponseJDialog(
				this, "Cancel Changes",
				"Are you sure you want to " +
				"Cancel the following changes?\n" +
				b.toString(),
				ResponseJDialog.YES | ResponseJDialog.NO ).
				response();

				if ( x == ResponseJDialog.YES ) {
					//write to log file
					Message.printStatus( 5, routine,
					"User canceled changes: " +
					b.toString() );

					windowManagerClose();

					//empty out dirty vector
 					__dirty_vect.clear();

				}
				else {
					//do nothing.. leave GUI open
 					__dirty_vect.clear();
				}

				b = null;
			}
			else {
				//Nothing has been changed, so
				//just do a normal cancel- close gui
				windowManagerClose();
			}
		}
		else {
			//just do a normal cancel- close gui
			windowManagerClose();
		}
	}
	else if ( source.equals( __close_JButton ) ) {
		closeGUI();
	}

	else if ( source.equals( __rating_tab_add_dates_JButton ) ) {
		if ( ! __rating_tab_dates_JComboBox.isEnabled()) {
			//un-gray out fields.
 			JGUIUtil.setEnabled( __rating_tab_dates_JComboBox, true );
 			JGUIUtil.setEnabled( __rating_tab_datum_JTextField,true);
 			JGUIUtil.setEnabled( __rating_tab_warning_stage_JTextField,true);
 			JGUIUtil.setEnabled( __rating_tab_flood_stage_JTextField,true);
 			JGUIUtil.setEnabled( __rating_JWorksheet,true);
 			__rating_JWorksheet.setBackground(Color.white);
		}

		//open new JFrame
		if ( __rating_newDates_JDialog == null ) {
 			__rating_newDates_JDialog = createNewDatesJDialog();
		}
		else {
			try {
				update_rating_days_in_month("start");
				update_rating_days_in_month("end");
			}
			catch ( Exception e ) {
				Message.printWarning( 2, routine, e );
			}
 			__rating_newDates_JDialog.setVisible( true );
		}
	}

	else if ( source.equals( __rating_tab_popup_cancel_JButton ) ) {
 		__rating_newDates_JDialog.setVisible( false );
	}
	else if ( source.equals( __rating_tab_popup_ok_JButton ) ) {
		//get dates
		String start_str =
 		__rating_tab_popup_start_YYYY_JTextField.getText() +
		"-" + (String)
 		__rating_tab_popup_start_MM_JComboBox.getSelected() +
		"-" + (String)
 		__rating_tab_popup_start_DD_JComboBox.getSelectedItem() +
		" " + (String)
 		__rating_tab_popup_start_HH_JComboBox.getSelected() +
		":" + (String)
 		__rating_tab_popup_start_mm_JComboBox.getSelected() ;

		String end_str =
 		__rating_tab_popup_end_YYYY_JTextField.getText() +
		"-" + (String)
 		__rating_tab_popup_end_MM_JComboBox.getSelected() +
		"-" + (String)
 		__rating_tab_popup_end_DD_JComboBox.getSelectedItem() +
		" " + (String)
 		__rating_tab_popup_end_HH_JComboBox.getSelected() +
		":" + (String)
 		__rating_tab_popup_end_mm_JComboBox.getSelected() ;

		//save dates
		Message.printStatus( 4, routine,
		"Adding new dates ( " + start_str + " to " + end_str +
		") to rating GUI." );

		try {
			update_stagedischargerating_dates( start_str, end_str );
		}
		catch ( Exception e) {
			Message.printWarning( 2, routine, e );
			Message.printWarning( 2, routine,
			"Error updating the start date (" +start_str + ") " +
			"and end date (" + end_str + ") for Ratings in the " +
			"Ratings tab of the Locations GUI." );
		}

 		__rating_newDates_JDialog.setVisible( false );
	}
	else if ( source.equals( __rating_tab_rating_add_JButton ) ) {
		RiversideDB_RatingTable rt = new RiversideDB_RatingTable();
		rt.setRatingTable_num(
 		__previous_RTi_StageDischargeRating.getRatingTable_num() );
 		__rating_JWorksheet.addRow(rt);
 		__rating_JWorksheet.scrollToLastRow();
 		__rating_JWorksheet.selectLastRow();

	}
	else if ( source.equals( __rating_tab_rating_delete_JButton ) ) {
		int row = __rating_JWorksheet.getSelectedRow();
		//get total number of rows--- cannot delete last row
		int total_num = __rating_JWorksheet.getRowCount();
		if( ( total_num ==1 ) || ( total_num == 0 ) ) {
			Message.printWarning( 1, routine,
			"Unable to delete the last row of data. ");
		}
		else if ( row != -1 ) {
   			int x = new ResponseJDialog(this,
    			"Delete row", "Delete row?",
    			ResponseJDialog.YES | ResponseJDialog.NO)
    			.response();

   			if (x == ResponseJDialog.NO) {
    				return;
   			}
 			__rating_JWorksheet.cancelEditing();
 			__rating_JWorksheet.deleteRow(row);
		}
		else {
			Message.printWarning( 1, routine,
			"You must select a row to delete. " , this );
		}
	}


} //end actionPerformed

/**
Respond to ItemEvents.
@param event ItemEvent to listen for.
*/
public void itemStateChanged ( ItemEvent event ) {
	String routine = __class + ".itemStateChanged";
	Object source = event.getItemSelectable();
	if ( event.getStateChange() == ItemEvent.DESELECTED ) {
		if ( source == __rating_tab_dates_JComboBox ) {
			boolean err_caught = false;
			StringBuffer buffer = null;
			try {
				buffer =checkRequiredInput_ratingTab();
			}
			catch( Exception e ) {
				Message.printWarning(2, routine, e );
				err_caught = true;
			}
			if (( buffer.length() >0 ) ||( err_caught ) ) {
				buffer.append( "Please make sure all " +
				"TextFields have valid numeric entries " +
				"or cancel. \nWill not save changes." );
				JOptionPane.showMessageDialog( this,
				buffer.toString(), "Warning",
				JOptionPane.WARNING_MESSAGE);
				return;
			}
			buffer = null;

			update_previous_StageDischargeRating_obj();
		}
	}

	if ( event.getStateChange() == ItemEvent.SELECTED ) {
		if ( ( __rating_tab_dates_JComboBox == null ) ||
		( __previous_RTi_StageDischargeRating == null ) ) {
			return;
		}
		if ( source == __rating_tab_dates_JComboBox ) {
			//Set the global variable: __previous_RTi_StageDischarge
			//so that we know which object we are currently
			//working on.

			//get date range string
			String date_range = (String)
 			__rating_tab_dates_JComboBox.getSelectedItem();

			int index = -999;
			index = date_range.indexOf( " to " );
			String start_str = null;
			String end_str = null;
			if ( index > 0 ) {
				start_str = date_range.substring( 0, index).
				trim();
				end_str = date_range.substring(index+4).trim();
			}
			DateTime start_dt =null;
			DateTime end_dt =null;
			try {
				start_dt = DateTime.parse( start_str,
				DateTime.FORMAT_YYYY_MM_DD_HH_mm );
				end_dt =  DateTime.parse( end_str,
				DateTime.FORMAT_YYYY_MM_DD_HH_mm );

			}
			catch (Exception e ) {
				Message.printWarning( 2, routine, e);
			}

			int size = __stageDischargeRating_vect.size();
			RiversideDB_StageDischargeRating sdr =null;

			int ind = 0;
			for ( int i=0; i<size; i++ ) {
				sdr = (RiversideDB_StageDischargeRating)__stageDischargeRating_vect.get(i);
				DateTime s = new DateTime(sdr.getStart_Date());
				DateTime e = new DateTime(sdr.getEnd_Date());
				if( ( start_dt.equals( s,
				DateTime.PRECISION_MINUTE ) ) &&
				( end_dt.equals( e,
				DateTime.PRECISION_MINUTE ) ) ) {
					//Found the correct one!  Set
					//it to global variable
 					__previous_RTi_StageDischargeRating =
					new RiversideDB_StageDischargeRating(
					sdr );
					ind = i;
					s = null;
					e = null;
					break;
				}
			}
			start_dt = null;
			end_dt = null;

			//Now we need to update GUI to reflect what is
			//now displayed ( based on date_range selected )

			//go through vector and find dates that match
			set_rating_tab_fields( sdr, ind);
			sdr = null;
		}

	}
} //end itemStateChanged

//WINDOW EVENTS
public void windowActivated ( WindowEvent e )
{
}

/**
This class is listening for GeoViewGUI closing so it can gracefully handle.
*/
public void windowClosed ( WindowEvent e )
{
}

/**
We don't want user to be able to close the GUI with the "x".
*/
public void windowClosing ( WindowEvent e ) {
	if ( __canWriteMeasLoc ) {
	 	closeGUI();
	}
	else {
		//just close as a cancel
		windowManagerClose();
	}
}

public void windowDeactivated ( WindowEvent e )
{
}

public void windowDeiconified ( WindowEvent e )
{
}

public void windowIconified ( WindowEvent e )
{
}

public void windowOpened ( WindowEvent e )
{
}

private void windowManagerClose() {

	Message.printStatus(6, "", "WindowManager Close");
	if (__originallyNewObject) {
		_windowManager.closeWindowInstance(
			_windowManager.WINDOW_MEASLOC,
			"CREATING NEW OBJECT");
	}
	else {

		//the measloc_num is the unique ID for this window.
		_windowManager.closeWindowInstance(
			_windowManager.WINDOW_MEASLOC,
			new Long(__db_MeasLoc_num));
	}
}

/////////////////////////////////////////////////////////////////
/////////////////////// END ACTIONS /////////////////////////////
/////////////////////////////////////////////////////////////////

}// end RiversideDB_Location_JFrame class
