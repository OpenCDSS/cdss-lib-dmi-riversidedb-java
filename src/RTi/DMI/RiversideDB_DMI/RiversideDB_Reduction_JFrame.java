//--------------------------------------------------------------------------
// RiversideDB_Reduction_JFrame -
//
//	Contains the code used to create the GUI for
//	Reductions
//
//--------------------------------------------------------------------------
// Copyright:	See the COPYRIGHT file.
//--------------------------------------------------------------------------
// History:
//
// 2003-04-15	Morgan Sheedy, RTi	Initial Implementation
// 2003-04-28	AML, RTi		Note: pack() and validate()
//					used in conjunction to adjust
//					gui size when panels changed.
//
// 2003-06-03	AML, RTi		Update to use new TS classes.
//
// 2003-06-08	AML, RTi		DBUser, DBGroup, DBPermissions
//					implemented for security.
//
// 2003-07-01	AML, RTi		code cleanup
//
// 2003-07-01	AML, RTi		code cleanup
//
// 2003-10-22	AML, RTi		MAP and MAT reductions added
//					use JWorksheet and have field
//					for weights (MeasReducRelation).
//
// 2004-01-16	AML, RTi		Updated to use JTree that contains
//					objects instead of just String
//					representations of the objects.
//
//
// 2004-04-13	AML, RTi		Changed property field for
//					DIURNAL_VARIATION (MAT Reduction)
//					from JComboBox to JTextField.
//
//					Added property to CHANGEINT reduction:
//					NEWDATATYPE as a JTextField.
//
//					Added property: 
//					SAVE_TRANSFORMED_INPUT_TS (t/f) to
//					reductions:
//					fillfloodmonitor, map, mapx, mat
//
// 2004-04-14	AML, RTi		Added property:
//					MAXMISSINGPERCENT to 
//					reduction: CHANGEINT 
//
// 2004_07_14	AML, RTi		*.setEnabled() and setBackgroundColor()
//					replaced by JGUIUtil.setEnabled().
//					*general code cleaning.
// 2004-10-25 Luiz Teixeira, RTi	Upgraded by moving it from the 
//					main application (RiverTrak Assistant)
//					to the RiversideDB_DMI library.
// 2004_10_29 Luiz Teixeira, RTi	Created the class
//					RiversideDB_BaseEditor_JFrame.java to 
// 					be used as base for all the editor
//					that needed to communicate back to the
//					calling classes. This is now done via
//					the RiversideDB_System_Listener which
//					is implemented in the base class
//					RiversideDB_BaseEditor_JFrame. The
//					base class also implements the 
//					addRiversideDBSystemListener(...)
//					and the private array member
//					RiversideDB_System_Listener []
//					_listeners to keep the assingned
//					listeners. This class now extends
// 					from RiversideDB_BaseEditor_JFrame.
// 2004_10_29 Luiz Teixeira, RTi	Removed the definition and all
//					reference to all __calling_class.
//					From now on using the 
//					RiversideDB_System_Listener implemen
//					ted in RiversideDB_BaseEditor_JFrame
// 2004-12-07 Luiz Teixeira, RTi	Because I moved the following methods
//						addVectors,
//						findAdditions,
//						findRemovals and
//					        removeDuplicateStringsFromVector 
//					from the RiversideDB_Util to this class
//					base (RiversideDB_EditorBase) all the 
//					preceeding "RiversideDB_Util." reference
//					to these methods were deleted.
// 2005-01-05 Luiz Teixeira, RTi	Added the argument __dmi to the calls to
//						RiversideDB_..._TableModel
// 2005-01-07 Luiz Teixeira, RTi 	Replaced the JWorksheet property names
//					by the new ones.
// 2005-01-10 Luiz Teixeira, RTi	Upgraded to either use the pre-03.00.00
//					Active field(setActive() and getActive()
//					methods) or the 03.00.00 IsActive field
//					(setIsActive() and getIsActive() method)
// 2005-02-15 Luiz Teixeira, RTi 	Remove NEWDATATYPE property from CHANGINT
// 2005-02-15 Luiz Teixeira, RTi 	Remove SCENARIO_FOR_COMPUTATION property
//					from FILLFLOODMONITOR	
// 2005-02-15 Luiz Teixeira, RTi 	Remove CONVERSION property
//					from STAGEDISCHARGERATING	
// 2005-04-11 J. Thomas Sapienza, RTi	The table model changed to use the
//					new version of row numbering, in which
//					the row numbers are not returned by the
//					table model but are generated by the
//					worksheet, so the properties for 
//					the worksheet in have been changed.
//--------------------------------------------------------------------------

package RTi.DMI.RiversideDB_DMI;

import  java.awt.Color;
import  java.awt.Dimension;
import  java.awt.GridBagConstraints;
import  java.awt.GridBagLayout;
import  java.awt.Insets;
import  java.awt.event.ActionEvent;
import  java.awt.event.ActionListener;
import  java.awt.event.WindowEvent;
import  java.awt.event.WindowListener;
import  java.util.Vector;

import 	javax.swing.BorderFactory;
import 	javax.swing.border.Border;
import 	javax.swing.DefaultListModel;
import 	javax.swing.event.ListSelectionEvent;
import 	javax.swing.event.ListSelectionListener;
import 	javax.swing.JFrame;
import 	javax.swing.JLabel;
import 	javax.swing.JList;
import 	javax.swing.JOptionPane;
import 	javax.swing.JPanel;
import 	javax.swing.JScrollPane;
import 	javax.swing.JTextField;
import 	javax.swing.ListSelectionModel;

import  RTi.TS.TSIdent;

import  RTi.Util.GUI.JGUIUtil;
import  RTi.Util.GUI.JWorksheet;
import  RTi.Util.GUI.ResponseJDialog;
import  RTi.Util.GUI.SimpleJButton;
import  RTi.Util.GUI.SimpleJComboBox;
import  RTi.Util.IO.PropList;
import	RTi.Util.Message.Message;
import  RTi.Util.String.StringUtil;

import 	RTi.DMI.DMIUtil;
import 	RTi.DMI.RiversideDB_DMI.RiversideDB_DBUser;
import 	RTi.DMI.RiversideDB_DMI.RiversideDB_DMI;
import 	RTi.DMI.RiversideDB_DMI.RiversideDB_MeasReduction;
import 	RTi.DMI.RiversideDB_DMI.RiversideDB_MeasReducRelation;
import 	RTi.DMI.RiversideDB_DMI.RiversideDB_MeasReductionType;
import 	RTi.DMI.RiversideDB_DMI.RiversideDB_MeasType;
import 	RTi.DMI.RiversideDB_DMI.RiversideDB_Scenario;
import 	RTi.DMI.RiversideDB_DMI.RiversideDB_StationWeights_CellRenderer;
import 	RTi.DMI.RiversideDB_DMI.RiversideDB_StationWeights_TableModel;


/**
RiversideDB_Reduction_JFrame.
This class is laid out similarly to the other RiverTrakAssistant classes.
The general format of the class is laid out below, with the major
methods listed with their key functions.  The main object types from 
RiversideDB that are manipulated by this class are:<br><ul>
<li>RiversideDB_MeasReduction (abbreviated MeasReduction)</li>
<li>RiversideDB_MeasType (abbreviated MeasType)</li></ul><br>
<p><b>Constructor</b><br>
The constructor is called by an action in one of the JTrees of the 
main application.  The main application passes to this class a 
RiversideDB_Measreduction.  This class is called in one of two cases: <br>
<ul><li>to view the properties of a current Measreduction</li>
<li>to create a new Measreduction</li></ul>
In the case of viewing a current Measreduction, the Measreduction object
passed to this class is already defined and all required properties 
already known.  In the case of creating a totally new Measreduction, the 
Measreduction passed in to this class is essentially an empty skeleton,
with only the MeasType_num (parent of the MeasReduction in the JTree)
filled in. <br>
It is important to distinguish in the constructor, if we are dealing with
an existing MeasReduction and just changing some of its fields or if
we are creating a totally new MeasReduction.  If the Create Method of the
related MeasType object (the MeasReduction's parent) is NOT "REDUCTION",
we know that the MeasReduction object is a NEW one and that we will also have
to update the parent (the MeasType) to set the create method to reduction.
In the constructor then, set the <i>__bln_new_object = true </i> flag.  
The <b><i>__bln_new_object</i></b> flag is important because:<br>
<ul>
<li>we can mark the object as dirty (using the <i>setDirty(true)</i> flag)
 since it is an entirely new object</li>
<li>we need to add the fields for <i>DBUser</i>, <i>DBGroup</i>, and 
<i>DBPermissions</i> based on the information already known by the DMI for 
this user.</li>
<li> we do not have to confirm changes made to a totally new object like we do 
if the user is changing an existing object</li>
<li>we need to know how to add the node on the JTree</li></ul> <br><br> 
At this point, whether we are creating a new MeasReduction or modifying an
existing one, we assign the MeasReduction to the variable known throughout
this class as: <b><i>__gui_RTi_MeasReduction</i></b>.  We also set up
the variable known throughout this class as: <b><i>
__gui_RTi_MeasType</i></b> which is the parent to this MeasReduction. <br><br>
Finally, the constructor also:<ul><li> sets up Vectors of (static) reference data, 
read directly from the database thay will be used throughout the class</li>
<li>calls method: <i>init_layout_GUI()</i> which creates and sets up the 
GUI components</li></ul><br> 
</p>
<p><b>init_layout_gui</b><br>
This method is called from the constructor to create and layout the
GUI components.  It calls the method: <i>create_main_panel</i>, which
creates the GUI components and puts them together in a <i>GridBagLayout</i>.
The main components in the GUI consists of:
<ul><li>JPanel that contains general information pertinent to the MeasReduction 
object at the top of the GUI</li>
<li>a panel added at the bottom that includes the standard buttons for: 
<ul><li>apply</li><li>close</li><li>cancel</li></ul></li></ul>
At the end of <i>init_layout_gui</i>, a 
call to <i>update_gui_fields</i> is made which fills in all the 
fields of the GUI according to the MeasReduction object currently being 
worked with.
</p>
<p><b>update_gui_fields</b><br>
This method: <ul><li>determines if the current user, already known to the DMI,
has write permissions.  If the user does not have write permissions, the 
<b>apply</b> and <b>close</b> buttons are disabled, leaving only the 
<b>cancel</b> button enabled.</li><li>Fills in all the GUI fields according
to the data in the MeasReduction object.</li></ul>
</p><br>
At this point the GUI is essentially laid out and we wait for actions...  The 
major methods triggered by actions include: <ul>
<li><i>checkRequiredInput()</i></li>
<li><i>update_RiversideDB_objects()</i></li>
<li><i>update_database()</i></li></ul>
Each of these will be detailed below.

<p><b>checkRequiredInput</b><br>
This method simply goes through all the fields in the GUI and checks that 
each fields is: <ul> <li>filled in if it is a required field </li>
<li>contains valid values (for JTextFields, for example)</li>
</ul>If an invalid entry is encountered, the method displays a warning message,
indicating the fields with invalid values.
</ul>
</p>

<p><b>update_RiversideDB_objects</b><br>
This method:<ul>
<li><b>creates the <i>__gui</i> versions of the objects!</b> This includes: <ul><li>__gui_RTi_MeasReduction</li><li>__gui_RTi_MeasType</li></ul> The 
<i>__gui</i> versions are created in this method by copying the <i>__db</i> 
versions (which were originally created and set up in the constructor)</li>
<li>calls the <i>verify_xxx</i> methods. These include:<ul>
<li><i>verify_top_fields()</i></li>
<li><i>verify_inputTS_fields()</i></li>
<li><i>verify_outputTS_fields()</i></li>
The <i>verify_xxx</i> methods:<ul><li> fill in the <i>__gui</i> verions of the objects
in memory with the values that are currently set in the GUI</li>
<li>compares the values in the <i>__gui</i> version of the objects to the 
<i>__db</i> version of the objects.  If the <i>__gui</i> versions differ 
from the <i>__db</i> verions:<ul>
<li>the <i>__gui</i> versions are marked dirty (<i>.setDirty(true)</i>)</li>
<li>messages are added to the <i>__dirty_vect</i> indicating how the 
<i>__gui</i> differs from the <i>__db</i> version (the <i>__db</i> version 
remember, represents how the object is in the database itself) </li></ul>
</li></ul></ul>
</p>
<p><b>update_database</b><br>
This method: <ul>
<li>makes a confirmation message to verify that the user wants to save the 
changes (and lists out all the changes from the <i>__dirty_vect</i>) <b>if</b>
a new MeasReduction was <b>not</b> created (if a new MeasReduction was created, 
we do not want to re-confirm every change)</li>
<li>writes the <i>__gui</i> version of the objects to the database</li>
<li>if the objects were successfully written to the database, the 
<i>__gui</i> objects are marked as <b>not</b> dirty 
( <i>setDirty(false)</i></li>
<li><i>__dirty_vect</i> is cleared out</li>
<li>if we created a new MeasReduction object (<i>__bln_new_object == true</i>),
add an updated node on the JTree in the main application (change creation 
method to REDUCTION)</li>
</ul>
</p>

<br>
<p><b>ACTIONS and the events they trigger</b><br>
The main actions in the GUI are fired off when the user selects one of the
following buttons:<ul><li>cancel</li><li>close</li><li>apply</li></ul>
<ul><li><b>cancel</b><br>
Items that are checked before the GUI is closed:<ul>
<li>if the user was changing the properties of an existing MeasReduction, 
<ul><li><i>update_RiversideDB_objects()</i> is called to <b>create</b> and 
update the <i><b>__gui_RTi_MeasReduction</b></i> and <i>
<b>__gui_RTi_MeasType</b></i> objects in memory, mark them dirty, and 
add messages to the <i>__dirty_vect</i> Vector.</li><li>Print a confirmation 
message, confirming the user wants to cancel the changes (that are stored 
in the <i>__dirty_vect</i>) </li></ul> </li> </ul> </li>
<li><b>close</b> (close Button and "X" in application window bar)<br>
The method: <i>closeGUI()</i>is called which does the following:<ul>
<li>calls <i>checkRequiredInput</i> which makes sure all the required fields in the GUI are filled out and have valid entries</li>
<li>calls <i>update_RiversideDB_objects</i> which is called to 
<b>create</b> and update the <i><b>__gui_RTi_MeasRduction</b></i> and 
<i> <b>__gui_RTi_MeasType</b></i> objects in memory, mark them dirty, 
and add messages to the <i>__dirty_vect</i> Vector.
</li>
<li>creates a confirmation message if the <i>__gui</i> versions are dirty, 
prompting the user to verify if they want to save their changes
(all the changes are listed out from the <i>__dirty_vect</i>)</li>
<li>updates the database by calling, <i>update_database</i></li>
<li>closes the GUI and destroys it</li>
</ul> </li>
<li><b>apply</b><br>
After the <b>apply</b> button is pressed, methods are called that follow a 
similar pattern as those called after the <b>close</b> button outlined above.
These methods are:<ul>
<li>checkRequired_input</li>
<li>update_RiversideDB_objects</li>
<li>update_database</li>
<li>Then, since the GUI is not being closed, the objects need to be updated
in memory to represent the new states.  Since the <i>__gui</i> objects have
been written to the database, the <i>__db</i> objects need to be updated to
represent the new database status.  To do so:<ul><li> the 
<i>__db_RTi_MeasReduction</i> object is re-created, using the copy 
constructor and passing in the <i>__gui_RTi_MeasReduction</i> object: <br>
<i>__db_RTi_MeasReduction = new RiversideDB_MeasReduction
( __gui_RTi_MeasReduction) </i> </li><li>the <i>__db_RTi_MeasType</i> 
object is likewise updated.</li></ul> </li>
</ul>
</li>
</ul>
*/
public class RiversideDB_Reduction_JFrame
	extends    RiversideDB_EditorBase_JFrame
	implements ActionListener,
		   ListSelectionListener,
		   WindowListener
{
	
// Class name
private static String __class = "RiversideDB_Reduction_JFrame";

//variables passed in with constructor.
//RiversideDB_DMI object - already opened
private RiversideDB_DMI __dmi = null;

//Shared Layout parameters
private Insets __insets = null;

//indicated what the current action is-
//ie, if a new Reduction Time Series (Meas Type) node is being added.
private boolean __bln_new_object = false;

//Dimension for vertical scrollbars
private Dimension __scroll_dim = new Dimension( 200, 100 );
private Dimension __worksheet_dim = new Dimension( 250, 100 );
private Dimension __half_scroll_dim = new Dimension( 200, 50 );

//CLOSE PANEL
//components for close panel
private SimpleJButton __close_JButton = null;
private SimpleJButton __cancel_JButton = null;
private SimpleJButton __apply_JButton = null;

//String for "NONE" selection in the SimpleJComboBox
String DEFAULT_STRING = "(DEFAULT)";

///  TIME SERIES / MEASUREMENT TYPES
/////////////////////////////////////////////////////////
//Holds name of Time Series that is selected in the JTree
private String __preselected_TSID_string = null;

//For the TOP part of TS panel
private String __move_inputTS_right_JButton_string = " > ";
private String __remove_selected_inputTS_JButton_string = "Clear Selected";
private String __inputTS_JPanel_string = "Input Time Series";
private String __all_inputTS_JList_string = "Choices";
private String __inputTS_JList_string = "Selected Input Time Series";
private String __props_JLabel_string = "Properties";

//All the inputTS to select from
private JList __sel_inputTS_JList = null;
private JList __all_inputTS_JList = null;
private DefaultListModel __sel_inputTS_ListModel = null;
private DefaultListModel __all_inputTS_ListModel = null;
private SimpleJButton __move_inputTS_right_JButton = null;
private SimpleJButton __remove_selected_inputTS_JButton = null;

//Holds the current value for the items in the top panel for TS
private String __processor_type = null;
private String __processor_desc = null;

//panel with TS
private JPanel __inputTS_JPanel = null;

//changedatatype INPUT TS
private String __props_3_changedatatype_JLabel_string = "GAGE_TYPE";
private String __props_3_changedatatype_desc = "If 'ROCKET', avoid false precipitation.";
private String __props_4_changedatatype_JLabel_string = "MAX_ALERT_DATA_AGE";
private String __props_4_changedatatype_desc = "Interval to search for available " +
"ALERT data.";
private String __props_2_changedatatype_JLabel_string = "MAX_SENSORCOUNT";
private String __props_2_changedatatype_desc= "Compute PTPX value when PTPA is at max.";
private String __props_5_changedatatype_JLabel_string = "SAVE_TRANSFORMED_INPUT_TS";
private String __props_5_changedatatype_desc = "Save intermediate input TS transformed "+ "to output TS interval.";
private String __props_1_changedatatype_JLabel_string = "SET_NEG_INC_TO_MISSING";
private String __props_1_changedatatype_desc = "True sets the PTPX value to missing.";
private SimpleJComboBox __props_1_changedatatype_JComboBox = null;
private SimpleJComboBox __props_2_changedatatype_JComboBox = null;
private SimpleJComboBox __props_3_changedatatype_JComboBox = null;
private SimpleJComboBox __props_4_changedatatype_JComboBox = null;
private SimpleJComboBox __props_5_changedatatype_JComboBox = null;

//changeint INPUT TS
private String __props_1_changeint_JLabel_string = "COMPUTE_UP_TO_CURRENT_TIME";
private String __props_1_changeint_desc = "Compute data up to the current time.";
private String __props_2_changeint_JLabel_string = "MAX_ALERT_DATA_AGE";
private String __props_2_changeint_desc = "Interval to search for available ALERT data.";
//private String __props_3_changeint_desc = "New data type designator for the output time series";
private String __props_4_changeint_JLabel_string = "MAXMISSINGPERCENT";
private String __props_4_changeint_desc = "Percentage of Missing input data values per output interval";

//private String __props_3_changeint_desc = "Use output time series interval for " +
//"input time series.";
private SimpleJComboBox __props_1_changeint_JComboBox = null;
private SimpleJComboBox __props_2_changeint_JComboBox = null;
private JTextField __props_3_changeint_JTextField = null;
private SimpleJComboBox __props_4_changeint_JComboBox = null;
//Obsolete - SimpleJComboBox __props_3_changeint_JComboBox = null;

//fillfloodmonitor INPUT TS
//Obsolete - private String __props_1_fillfloodmonitor_JLabel_string = "SCENARIO_FOR_COMPUTATION";
//Obsolete - private String __props_1_fillfloodmonitor_desc = "Scenario for FloodMonitor statistics.";
private SimpleJComboBox __props_1_fillfloodmonitor_JComboBox = null;
private String __props_2_fillfloodmonitor_JLabel_string = "SAVE_TRANSFORMED_INPUT_TS";
private String __props_2_fillfloodmonitor_desc = "Save intermediate input TS transformed "+ "to output TS interval.";
private SimpleJComboBox __props_2_fillfloodmonitor_JComboBox = null;

//fillrepeat INPUT TS
//no properties

//map INPUT TS
private String __props_1_map_JLabel_string = "ALPHA";
private String __props_1_map_desc = "Re-weights stations if 1+ stations report MISSING.";
private String __props_2_map_JLabel_string = "SET_TO_ZERO";
private String __props_2_map_desc = "If it cannot be computed, True sets the MAP value to ZERO.";
private String __props_3_map_JLabel_string = "SAVE_TRANSFORMED_INPUT_TS";
private String __props_3_map_desc = "Save intermediate input TS transformed "+
"to output TS interval.";
private SimpleJComboBox __props_3_map_JComboBox = null;
private SimpleJComboBox __props_1_map_JComboBox = null;
private SimpleJComboBox __props_2_map_JComboBox = null;
private JWorksheet __weights_JWorksheet = null;
private PropList __worksheet_props = null;
int [] __weights_worksheet_widths = null;

//mapx INPUT TS
private String __props_1_mapx_JLabel_string = "SET_MISSING_TO_ZERO";
private String __props_1_mapx_desc = "True sets the MAPX value to ZERO.";
//OBSOLETE private String __props_2_mapx_JLabel_string = "SAVE_TRANSFORMED_INPUT_TS";
//private String __props_2_mapx_desc = "Save intermediate input TS transformed to output TS interval.";
private SimpleJComboBox __props_1_mapx_JComboBox = null;
private SimpleJComboBox __props_2_mapx_JComboBox = null;

//mat INPUT TS
private String __props_1_mat_JLabel_string = "BLEND_DURATION";
private String __props_1_mat_desc = "Window used to blend the last observations.";
private String __props_2_mat_JLabel_string = "DIURNAL_VARIATION";
private String __props_2_mat_desc = "Temperature variation throughout the day.";
private String __props_3_mat_JLabel_string = "SAVE_TRANSFORMED_INPUT_TS";
private String __props_3_mat_desc = "Save intermediate input TS transformed "+ 
"to output TS interval.";
private SimpleJComboBox __props_1_mat_JComboBox = null;
private JTextField __props_2_mat_JTextField = null;
private SimpleJComboBox __props_3_mat_JComboBox = null;

//shapefile INPUT TS

//powerfunc INPUT TS

//stagedischargerating INPUT TS
//Obsolete private String __props_1_stagedischargerating_JLabel_string = "CONVERSION";
//Obsolete private String __props_1_stagedischargerating_desc = "Conversion type.";
private SimpleJComboBox __props_1_stagedischargerating_JComboBox = null;
private String __props_2_stagedischargerating_JLabel_string = "MAX_ALERT_DATA_AGE";
private String __props_2_stagedischargerating_desc = "Interval to search " +
"for available ALERT data.";
private SimpleJComboBox __props_2_stagedischargerating_JComboBox = null;
private String __props_3_stagedischargerating_JLabel_string = "SAVE_TRANSFORMED_INPUT_TS";
private String __props_3_stagedischargerating_desc = "(See Documentation)";
//"Save intermediate input TS transformed to output TS interval";
private SimpleJComboBox __props_3_stagedischargerating_JComboBox = null;

//TOP PANEL -- info on selected TS (MeasType)
private JTextField __processor_JTextField = null;
private SimpleJComboBox __order_JComboBox = null;
private SimpleJComboBox __active_JComboBox = null;

//Output TS
private JTextField __outputTS_JTextField = null;

//Items for types of Processes
private String __proc_changedatatype_str = "CHANGEDATATYPE";
private String __proc_changeint_str = "CHANGEINT";
private String __proc_fillfloodmonitor_str = "FILLFLOODMONITOR";
private String __proc_fillrepeat_str = "FILLREPEAT";
private String __proc_map_str = "MAP";
private String __proc_mapx_str = "MAPX";
private String __proc_mat_str = "MAT";
private String __proc_shapefile_str = "SHAPEFILE";
private String __proc_powerfunc_str = "POWERFUNC";
private String __proc_stagedischargerating_str = "STAGEDISCHARGERATING";
//create orders assoc with the processes
long __proc_changedatatype_order= 2;
long __proc_changeint_order= 4;
long __proc_fillfloodmonitor_order= 201;
long __proc_fillrepeat_order= 1;
long __proc_map_order= 11;
long __proc_mapx_order= 13;
long __proc_mat_order= 12;
long __proc_shapefile_order= -999;
long __proc_powerfunc_order= -999;
long __proc_stagedischargerating_order= 3; //or 103


//all the OBJECTS that are manipulated in this GUI.
//MeasType object that is currently being used...
RiversideDB_MeasType __db_RTi_MeasType = null;
RiversideDB_MeasReduction __db_RTi_MeasReduction = null;
//private Vector __RTi_MeasReduction_vect = null;
private Vector __RTi_MeasReductionType_vect = null;
private Vector __db_RTi_MeasReducRelation_vect = new Vector();

//holds name and description of MeasReductionTypes
private Vector __process_vect = null;

//this is the MeastType.MeasTypeNum and the MeasReduction.OutputMeasTypeNum
long __db_MeasType_num = -999;
long __db_MeasLoc_num = -999;

//Holds a Vector of status information-- each
//field that has been changed is recored in this vector.
private Vector __dirty_vect = new Vector();

//Holds objects with current, but uncommitted changes 
RiversideDB_MeasType __gui_RTi_MeasType = null;
RiversideDB_MeasReduction __gui_RTi_MeasReduction = null;
private Vector __gui_RTi_MeasReducRelation_vect = new Vector();

//Flag to indicate if we are running in CAUTIOUS MODE---
//aka, if we prompt the user for confirmation of changes
private boolean __cautious_mode = true;

//flag to indicate if current user has write permissions.
private boolean __canWriteMeasReduction = false;

//holds DBUser
private RiversideDB_DBUser __DBUser = null;

/**
RiversideDB_Reduction_JFrame constructor.  This GUI is based on the
RiversideDB MeasReduction Table.  The constructor is called by an 
action in one of the JTrees of the main application.  The main application 
passes to this class a RiversideDB_MeasType and a 
RiversideDB_MeasReduction object.  This class is called in one of two cases: 
<br> <ul><li>to view the properties of a current MeasReduction</li>
<li>to create a new MeasReduction</li></ul>
In the case of viewing a current MeasReduction, the MeasReduction object
passed to this class is already defined and all required properties 
already known.  In the case of creating a totally new MeasReduction, the 
MeasReduction passed in to this class is essentially an empty skeleton,
but it's MeasType parent is passed in with it.  <br>
It is important to distinguish in the constructor, if we are dealing with
an existing MeasReduction and just changing some of its fields or if
we are creating a totally new MeasReduction.  If the MeasType parent
for the MeasReduction has a create method that is NOT "REDUCTION", 
then we know that we are creating a new MeasReduction object.  
In the constructor then, set
the <i>__bln_new_object = true </i> flag.  The <b><i>__bln_new_object</i></b>
flag is important because:<br>
<ul>
<li>we can mark the object as dirty (using the <i>setDirty(true)</i> flag)
 since it is an entirely new object</li>
<li>we need to add the fields for <i>DBUser</i>, <i>DBGroup</i>, and 
<i>DBPermissions</i> based on the information already known by the DMI for 
this user.</li>
<li> we do not have to confirm changes made to a totally new object like we do 
if the user is changing an existing object</li>
<li>we need to know how to edit the node to the JTree</li></ul> <br><br> 
At this point, whether we are creating a new MeasReduction or modifying an
existing one, we assign the MeasReduction to the variable known throughout
this class as: <b><i>__gui_RTi_MeasReduction</i></b>.  We also set up
the variable known throughout this class as: <b><i>
__gui_RTi_MeasType</i></b> which is the parent to the  
<i>__gui_RTi_MeasReduction object</i>.  The MeasType (parent) will
be know if we are creating a totally new MeasReduction or not.  <br><br>
Finally, the constructor also:<ul><li> sets up Vectors of (static) 
reference data, read directly from the database thay will be used throughout 
the class</li> <li>calls method: <i>init_layout_GUI()</i> which creates
and sets up the GUI components</li></ul><br> 
@param dmi Instance of RiversideDB_DMI that has already been opened.
@param title String for title of JFrame.
@param mt RiversideDB_MeasType object to display in this GUI. 
@param mr RiversideDB_MeasReduction object to display in this GUI. If a 
NEW MeasReduction object is being created by this GUI, then the MeasType.
create_method field will NOT be "REDUCTION".
*/
public RiversideDB_Reduction_JFrame(
				RiversideDB_DMI dmi,
				RiversideDB_WindowManager windowManager,
				String title,
				RiversideDB_MeasType mt,
				RiversideDB_MeasReduction mr ) {
	super( title );
	String routine = __class + ".constructor";

	//RTi icon
	JGUIUtil.setIcon( this, JGUIUtil.getIconImage() );

	// Set global variables
 	__dmi = dmi;
 
 	// Set protected member in the base RiversideDB_EditorBase_JFrame class.
 	_windowManager = windowManager;

	try {
 		__preselected_TSID_string = (mt.toTSIdent()).toString();
	}
	catch ( Exception e ) {
		Message.printWarning( 2, routine, e );
 		__preselected_TSID_string = "";
	}
	//determine if we are editing an existing reduction or creating
	//a new one
	if ( mt.getCreate_method().equalsIgnoreCase("REDUCTION") ) {
 		__bln_new_object = false;
	}
	else { 
 		__bln_new_object = true;
	}
	//assign MeasType object to the global variable __db_RTi_MeasType.
 	__db_RTi_MeasType = mt;
	//assign MeasReduction object to the global variable 
	//_db_RTi_MeasReduction.
 	__db_RTi_MeasReduction = mr;

	//get other variables we repeatedly use.
 	__db_MeasType_num = __db_RTi_MeasType.getMeasType_num();
 	__db_MeasLoc_num = __db_RTi_MeasType.getMeasLoc_num();

	if ( Message.isDebugOn ) {
		Message.printDebug( 2, routine, 
		"MeasType_num for selected time series: \"" + 
 		__preselected_TSID_string + "\" is: " + __db_MeasType_num +
		" and MeasLoc_num is: " + __db_MeasLoc_num  );
	}
	
	try {
 		__DBUser = __dmi.getDBUser();
	}
	catch ( Exception e ) {
		Message.printWarning( 2, routine, e );
	}

	//get the list of all MeasTypes for this MeasLoc
	//long ml_num = -999;
	//ml_num = __db_RTi_MeasType.getMeasLoc_num();
	/*
	try {
 		__db_RTi_MeasType_vect =
 		__dmi.readMeasTypeListforMeasLoc_num( __db_MeasLoc_num);
	}
	catch ( Exception e ) {
		Message.printWarning( 2, routine, e);
	}
	*/

	//get all the MeasReduction objects
	try {
		//get MeasReduction objects vector
 		//__RTi_MeasReduction_vect = __dmi.readMeasReductionList();
	}
	catch ( Exception e ) {
		Message.printWarning( 2, routine, e );
 		__db_RTi_MeasType = null;
	}

	//get MeasReduction Types- used in __processor_JTextField
	//These are also HARDCODED as "private String __proc_xxx_str" variables
	try {
 		__RTi_MeasReductionType_vect =
 		__dmi.readMeasReductionTypeList();
	}
	catch ( Exception e ) {
		Message.printWarning( 2, routine, e);
	}

 	__process_vect = getProcessChoices();
	if ( __process_vect == null ) {
 		__process_vect = new Vector();
	}

	//for the MeasReduction object, either we are editing the 
	//properties of a current MeasReduction or
	//we are changing an UNKNOWN (or other type) to a REDUCTION Time Series.
	//int size = 0;
	//if ( __RTi_MeasReduction_vect != null ) {
	//	size = __RTi_MeasReduction_vect.size();
	//}
	//if ( __db_RTi_MeasReduction. == null ) {}
	//mark MeasType dirty if we are changing a node to be a reduction
	if ( __bln_new_object ) {
 		__db_RTi_MeasType.setDirty( true );
 		__db_RTi_MeasType.setCreate_method( "REDUCTION" );
		//also query user for Reduction process type
		if ( __process_vect.size() == 0 ) {
			Message.printWarning( 1, routine, 
			"Unable to create Reduction time series for " +
 			__preselected_TSID_string + ".\n "+
			"Please make sure meas reduction " +
			"type is correct." ,this  );
		}

		Object options[]= __process_vect.toArray();

		Object selectedValue = JOptionPane.showInputDialog(
		this, "Choose the Reduction Process Type for new Reduction",
		"Reduction Process Type", JOptionPane.INFORMATION_MESSAGE,
		null, options, options[0] );

		if( (selectedValue == null ) || 
		((selectedValue.toString()).equalsIgnoreCase("null")) ) {
			//cancel was pressed...
			//setVisible(false);
			//dispose();
			windowManagerClose();
		}
		//set processor and description strings
		int ind =0;
		ind = ( (String)selectedValue).indexOf( "-" );
		if ( ind >=0 ) {
 			__processor_type = (((String)selectedValue).
			substring( 0, ind )).trim();
 			__processor_desc = ((String)selectedValue).
			substring( ind +1);
		}

		Message.printStatus( 3 , routine, 
		"Creating new MeasReduction object of type: \"" +
 		__processor_type + "\" with description: \"" +
 		__processor_desc + "\"." );

		//we are creating a new MeasReduction instance and
		//can assign it OutputMeasType_num
		//_db_RTi_MeasReduction = new RiversideDB_MeasReduction();
 		__db_RTi_MeasReduction.setDirty( true );
 		__db_RTi_MeasReduction.setMethod( __proc_changeint_str);
 		__db_RTi_MeasReduction.setOutputMeasType_num( 
 		__db_MeasType_num );
 		__db_RTi_MeasReduction.setMethod( __proc_changeint_str);
		//should not have to set these manually - the object
		//should set defaults when it is created.
 		__db_RTi_MeasReduction.setCreate_order( 4 );
 		if ( __dmi.isDatabaseVersionAtLeast(RiversideDB_DMI._VERSION_030000_20041001) ) {
 			__db_RTi_MeasReduction.setIsActive( "Y" );
		} else {
			__db_RTi_MeasReduction.setActive  ( "Y" );		
		}
 		__db_RTi_MeasReduction.setProperties( "" );

		//set permissions for new Object
 		__db_RTi_MeasReduction.setDBUser_num( __DBUser.getDBUser_num());
 		__db_RTi_MeasReduction.setDBGroup_num( 
 		__DBUser.getPrimaryDBGroup_num() );
 		__db_RTi_MeasReduction.setDBPermissions( 
 		__DBUser.getDefault_DBPermissions() );
	}

	//use MeasType_num to get the MeasReducRelation objects
	if ( ! __bln_new_object ) {
		//set the type and processor description 
 		__processor_type  = __db_RTi_MeasReduction.getMethod();
 		__processor_desc  = getProcessorDescription( __processor_type );

		try {
 			__db_RTi_MeasReducRelation_vect = __dmi.
			readMeasReducRelationListForOutputMeasType_num(
 			__db_MeasType_num );
		}
		catch ( Exception e ) {
			Message.printWarning( 2, routine, e);
			Message.printWarning( 2, routine,
			"Unable to get list of MeasReducRelation Objects");
		}

	}
	else {
 		__db_RTi_MeasReducRelation_vect = new Vector();
		//we just created a new MeasReduction objects
		//so we won't have a list of related MeasReducRelation Object
	}

	//see if user has permissions to change the MeasReduction object
	try {
 		__canWriteMeasReduction =
 		__dmi.canWrite( __db_RTi_MeasReduction.getDBUser_num(),
 		__db_RTi_MeasReduction.getDBGroup_num(),
 		__db_RTi_MeasReduction.getDBPermissions() );
	}
	catch ( Exception e ) {
		Message.printWarning ( 2, routine, e);
 		__canWriteMeasReduction = false;
	}
	

	//Insets order: top, left, bottom, right
 	__insets = new Insets( 2, 2, 5, 2);

	// create/layout the GUI ...
	init_layout_GUI();

	//add window listener
	addWindowListener ( this );

	//setup frame to do nothing on close so that we can take over
	//control of window events.
	setDefaultCloseOperation( JFrame.DO_NOTHING_ON_CLOSE );

	setResizable( false );
}

/**
Assembles panel to display Input Time Series for time series
type: changedatatype.
@return Assembled JPanel.
*/
protected JPanel assemble_inputTS_changedatatype_panel ( ) {
	String routine = __class + ".assemble_inputTS_changedatatype_panel";
	JPanel panel = new JPanel();
	panel.setLayout( new GridBagLayout() );

	JPanel ts_panel = new JPanel();
	ts_panel.setLayout( new GridBagLayout() );

	JPanel props_panel = new JPanel();
	props_panel.setLayout( new GridBagLayout() );

	//make border for all inputTS panels
	Border ts_titled_border=BorderFactory.createTitledBorder( __inputTS_JPanel_string );

	ts_panel.setBorder( ts_titled_border);

	Border props_titled_border=
	BorderFactory.createTitledBorder( __props_JLabel_string );

	//add titled border to panel
	props_panel.setBorder( props_titled_border);

	//label for left list (list of all inputTS possiblities)
	JLabel all_inputTS_JLabel = new JLabel( __all_inputTS_JList_string + ":");
	all_inputTS_JLabel.setToolTipText("List of all input time series" );

	//list of all possibilities
 	__all_inputTS_ListModel = new DefaultListModel();
 	__all_inputTS_JList = new JList(
 	__all_inputTS_ListModel );
 	__all_inputTS_JList.setVisibleRowCount( 5 );
 	__all_inputTS_JList.setSelectionMode(
	ListSelectionModel.MULTIPLE_INTERVAL_SELECTION );

	JScrollPane all_inputTS_JScrollPane = new JScrollPane(
 	__all_inputTS_JList);
	all_inputTS_JScrollPane.setVerticalScrollBarPolicy(
		JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
	all_inputTS_JScrollPane.setPreferredSize( __scroll_dim );
	all_inputTS_JScrollPane.setMinimumSize( __scroll_dim );

	//label for the selected inputTS
	JLabel inputTS_JLabel = new JLabel( __inputTS_JList_string + ":");
	inputTS_JLabel.setToolTipText("List of selected time series");
	//list for selected input TS
 	__sel_inputTS_ListModel = new DefaultListModel();
 	__sel_inputTS_JList = new JList(
 	__sel_inputTS_ListModel );
 	__sel_inputTS_JList.setVisibleRowCount( 5 );
	
	JScrollPane inputTS_JScrollPane = new JScrollPane(
 	__sel_inputTS_JList);
	inputTS_JScrollPane.setVerticalScrollBarPolicy(
		JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
	inputTS_JScrollPane.setPreferredSize( __half_scroll_dim );
	inputTS_JScrollPane.setMaximumSize( __half_scroll_dim );
	inputTS_JScrollPane.setMinimumSize( __half_scroll_dim );

	//button to move time series from the "all" list to the
	//"selected" list
 	__move_inputTS_right_JButton = new SimpleJButton(
 	__move_inputTS_right_JButton_string,
 	__move_inputTS_right_JButton_string, this );
	
	//button to remove a TS from the selected list
 	__remove_selected_inputTS_JButton = new SimpleJButton(
 	__remove_selected_inputTS_JButton_string,
 	__remove_selected_inputTS_JButton_string, this );

	//make properties
	//"SET_NEG_INC_TO_MISSING"
	JLabel prop_1_JLabel = new JLabel(
 	__props_1_changedatatype_JLabel_string + ":");
	JLabel prop_1_desc = new JLabel (
 	__props_1_changedatatype_desc );
	prop_1_JLabel.setToolTipText("Optional: Select True to indicate " +
	"that negative incremental precipitation PTPX is treated as zero.");

	//"MAX_SENSORCOUNT"
	JLabel prop_2_JLabel = new JLabel(
 	__props_2_changedatatype_JLabel_string + ":");
	JLabel prop_2_desc = new JLabel (
 	__props_2_changedatatype_desc );
	prop_2_JLabel.setToolTipText("Optional: If specified, a PTPX value "+
	"will be computed when the PTPA is reset at the maximum sensor count.");

	//"GAGE_TYPE"
	JLabel prop_3_JLabel = new JLabel(
 	__props_3_changedatatype_JLabel_string + ":");
	JLabel prop_3_desc = new JLabel (
 	__props_3_changedatatype_desc );
	prop_3_JLabel.setToolTipText("Optional: Select type of gage");

	//"MAX_ALERT_DATA_AGE"
	JLabel prop_4_JLabel = new JLabel(
 	__props_4_changedatatype_JLabel_string + ":");
	JLabel prop_4_desc = new JLabel (
 	__props_4_changedatatype_desc );
	prop_4_JLabel.setToolTipText( "Optional: Specify the interval " +
	"that will be searched for a value to carry forward when missing "+
	"data are encountered.");

	//"SAVE_TRANSORMED_INPUT_TS"
	JLabel prop_5_JLabel = new JLabel(
 	__props_5_changedatatype_JLabel_string + ":");
	JLabel prop_5_desc = new JLabel (
 	__props_5_changedatatype_desc );
	prop_5_JLabel.setToolTipText("<html>Optional: Save the intermediate " +
	"time series to the database<br>when an output time series is of " +
	"different interval than the input time series and a <br>CHANGEINT " +
	"reduction is (automatically) performed.</html>");

	//make vector for comboboxes...
	Vector prop_1_vect = new Vector();
	prop_1_vect.addElement( DEFAULT_STRING + " - FALSE" );
	prop_1_vect.addElement( "TRUE" );

	Vector prop_2_vect = new Vector();
	prop_2_vect.addElement(DEFAULT_STRING + " - 0");
	prop_2_vect.addElement("30000");
	prop_2_vect.addElement("31000");
	prop_2_vect.addElement("32000");
	prop_2_vect.addElement("33000");
	prop_2_vect.addElement("34000");
	prop_2_vect.addElement("35000");
	prop_2_vect.addElement("36000");

	Vector prop_3_vect = new Vector();
	prop_3_vect.addElement(DEFAULT_STRING + " - REGULAR");
	prop_3_vect.addElement("ROCKET");

	Vector prop_4_vect = new Vector();
	prop_4_vect.addElement(DEFAULT_STRING + " - 2DAY" );
	for ( int i=1;i<32; i++ ) {
		if ( i != 2 ) {
			prop_4_vect.addElement(i + "DAY" );
		}
	}

	Vector prop_5_vect = new Vector();
	prop_5_vect.addElement( DEFAULT_STRING + " - FALSE" );
	prop_5_vect.addElement("TRUE");

 	__props_1_changedatatype_JComboBox =
	new SimpleJComboBox( prop_1_vect );

 	__props_2_changedatatype_JComboBox =
	new SimpleJComboBox( prop_2_vect );

 	__props_3_changedatatype_JComboBox =
	new SimpleJComboBox( prop_3_vect );

 	__props_4_changedatatype_JComboBox =
	new SimpleJComboBox( prop_4_vect );

 	__props_5_changedatatype_JComboBox =
	new SimpleJComboBox( prop_5_vect );

	try {
		int x = 0;
		int y = 0;
		//all inputTS label
		JGUIUtil.addComponent(
		ts_panel, all_inputTS_JLabel,
		x, y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

		//all inputTS list
		JGUIUtil.addComponent(
		ts_panel, all_inputTS_JScrollPane,
		x, ++y, 1, 2, 1, 0, __insets,
		GridBagConstraints.BOTH,
		GridBagConstraints.WEST );

		//move right button
		JGUIUtil.addComponent(
		ts_panel, __move_inputTS_right_JButton,
		++x, ++y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.CENTER );

		--y;
		//label for selected time series
		JGUIUtil.addComponent(
		ts_panel, inputTS_JLabel,
		++x, --y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

		//List of selected time series
		JGUIUtil.addComponent(
		ts_panel, inputTS_JScrollPane,
		x, ++y, 1, 2, 1, 0, __insets,
		GridBagConstraints.BOTH,
		GridBagConstraints.EAST );

		//button to delete a selected time series
		JGUIUtil.addComponent(
		ts_panel, __remove_selected_inputTS_JButton,
		++x, ++y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.EAST );

		//top, left, bottom, right
		//Insets insets = new Insets( 15, 5, 15, 5 );
		x=0;
		++y;
		++y;
		JGUIUtil.addComponent(
		props_panel, prop_3_JLabel,
		x, ++y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.EAST );

		JGUIUtil.addComponent(
		props_panel, __props_3_changedatatype_JComboBox,
		++x, y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

		JGUIUtil.addComponent(
		props_panel, prop_3_desc,
		++x, y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

		x=0;
		JGUIUtil.addComponent(
		props_panel, prop_4_JLabel,
		x, ++y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.EAST );

		JGUIUtil.addComponent(
		props_panel, __props_4_changedatatype_JComboBox,
		++x, y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

		JGUIUtil.addComponent(
		props_panel, prop_4_desc,
		++x, y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

		x=0;
		JGUIUtil.addComponent(
		props_panel, prop_2_JLabel,
		x, ++y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.EAST );

		JGUIUtil.addComponent(
		props_panel, __props_2_changedatatype_JComboBox,
		++x, y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

		JGUIUtil.addComponent(
		props_panel, prop_2_desc,
		++x, y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

		x=0;
		JGUIUtil.addComponent(
		props_panel, prop_5_JLabel,
		x, ++y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.EAST );

		JGUIUtil.addComponent(
		props_panel, __props_5_changedatatype_JComboBox,
		++x, y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

		JGUIUtil.addComponent(
		props_panel, prop_5_desc,
		++x, y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

		x=0;
		JGUIUtil.addComponent(
		props_panel, prop_1_JLabel,
		x, ++y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.EAST );

		JGUIUtil.addComponent(
		props_panel, __props_1_changedatatype_JComboBox,
		++x, y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

		JGUIUtil.addComponent(
		props_panel, prop_1_desc,
		++x, y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

		//put 2 panels together in main panel
		JGUIUtil.addComponent(
		panel, ts_panel,
		0, 0, 1, 1, 1, 0, __insets,
		GridBagConstraints.BOTH,
		GridBagConstraints.CENTER );

		JGUIUtil.addComponent(
		panel, props_panel,
		0, 1, 1, 1, 1, 0, __insets,
		GridBagConstraints.BOTH,
		GridBagConstraints.CENTER );
	}
	catch ( Exception e) {
		Message.printWarning( 2, routine,
		"Error laying out the Input Time Series " +
		"panel for type: " + __proc_changedatatype_str );
		Message.printWarning( 2, routine, e );
	}

	//clean up
	prop_1_vect = null;
	prop_2_vect = null;
	prop_3_vect = null;

	return panel;
} //end assemble_inputTS_changedatatype_panel


/**
Assembles panel to display Input Time Series for time series
type: changeint.
@return Assembled JPanel.
*/
protected JPanel assemble_inputTS_changeint_panel ( ) {
	String routine = __class + ".assemble_inputTS_changeint_panel";
	JPanel panel = new JPanel();
	panel.setLayout( new GridBagLayout() );

	JPanel ts_panel = new JPanel();
	ts_panel.setLayout( new GridBagLayout() );

	JPanel props_panel = new JPanel();
	props_panel.setLayout( new GridBagLayout() );

	//make border for all inputTS panels
	Border ts_titled_border=BorderFactory.createTitledBorder( __inputTS_JPanel_string );

	ts_panel.setBorder( ts_titled_border);

	Border props_titled_border=
	BorderFactory.createTitledBorder( __props_JLabel_string );

	//add titled border to panel
	props_panel.setBorder( props_titled_border);

	//label for left list (list of all inputTS possiblities)
	JLabel all_inputTS_JLabel = new JLabel( __all_inputTS_JList_string + ":");
	all_inputTS_JLabel.setToolTipText("List of all available time series");

	//list of all possibilities
 	__all_inputTS_ListModel = new DefaultListModel();
 	__all_inputTS_ListModel.ensureCapacity( 5 );

 	__all_inputTS_JList = new JList(
 	__all_inputTS_ListModel );
 	__all_inputTS_JList.setVisibleRowCount(5);
 	__all_inputTS_JList.setSelectionMode(
	ListSelectionModel.MULTIPLE_INTERVAL_SELECTION );

	JScrollPane all_inputTS_JScrollPane = new JScrollPane(
 	__all_inputTS_JList);
	all_inputTS_JScrollPane.setVerticalScrollBarPolicy(
		JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
	all_inputTS_JScrollPane.setPreferredSize( __scroll_dim );
	all_inputTS_JScrollPane.setMinimumSize( __scroll_dim );

	//label for the selected inputTS
	JLabel inputTS_JLabel = new JLabel( __inputTS_JList_string + ":");
	inputTS_JLabel.setToolTipText("List of selected time series");
	//list for selected input TS
 	__sel_inputTS_ListModel = new DefaultListModel();
 	__sel_inputTS_JList = new JList(
 	__sel_inputTS_ListModel );
 	__sel_inputTS_JList.setVisibleRowCount( 5 );

	JScrollPane inputTS_JScrollPane = new JScrollPane(
 	__sel_inputTS_JList);
	inputTS_JScrollPane.setVerticalScrollBarPolicy(
		JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
	inputTS_JScrollPane.setPreferredSize( __scroll_dim );

	//button to move time series from the "all" list to the
	//"selected" list
 	__move_inputTS_right_JButton = new SimpleJButton(
 	__move_inputTS_right_JButton_string,
 	__move_inputTS_right_JButton_string, this );

	//button to remove a TS from the selected list
 	__remove_selected_inputTS_JButton = new SimpleJButton(
 	__remove_selected_inputTS_JButton_string,
 	__remove_selected_inputTS_JButton_string, this );

	//Labels and vectors for comoboxes
	// "COMPUTE_UP_TO_CURRENT_TIME";
	JLabel prop_1_JLabel = new JLabel(
 	__props_1_changeint_JLabel_string + ":" );
	JLabel prop_1_desc = new JLabel(
 	__props_1_changeint_desc );
	prop_1_JLabel.setToolTipText("Optional: Compute up to the current time");

	//"MAX_ALERT_DATA_AGE";
	JLabel prop_2_JLabel = new JLabel(
 	__props_2_changeint_JLabel_string + ":" );
	JLabel prop_2_desc = new JLabel(
 	__props_2_changeint_desc );
	prop_2_JLabel.setToolTipText("Optional: Maximum age of alert type data" );

	//"NEWDATATYPE";
/*      OBSOLETE
	JLabel prop_3_JLabel = new JLabel(
 	__props_3_changeint_JLabel_string + ":" );
	JLabel prop_3_desc = new JLabel(
	__props_3_changeint_desc );
	prop_3_JLabel.setToolTipText("Optional: New data type designator for the output time series");
*/

	//MAXMISSINGPERCENT
	JLabel prop_4_JLabel = new JLabel(
 	__props_4_changeint_JLabel_string + ":" );
	JLabel prop_4_desc = new JLabel(
 	__props_4_changeint_desc );
	prop_4_JLabel.setToolTipText("<html>Optional: an integer between " +
	"0 and 100 to <br>define the percentage of allowed missing <br>input " +
	"data values per output interval.</html>" );

	Vector prop_1_vect = new Vector();
	prop_1_vect.addElement( DEFAULT_STRING + " - FALSE" );
	prop_1_vect.addElement( "TRUE" );

	Vector prop_2_vect = new Vector();
	prop_2_vect.addElement( DEFAULT_STRING + " - 2DAY" );
	for ( int i=1;i<32; i++ ) {
		if ( i != 2 ) {
			prop_2_vect.addElement(i + "DAY" );
		}
	}

	Vector prop_3_vect = new Vector();
	prop_3_vect.addElement( DEFAULT_STRING + " - FALSE" );
	prop_3_vect.addElement( "TRUE" );

	Vector prop_4_vect = new Vector();
	for ( int i=0; i<=100; i++ ) {
		prop_4_vect.addElement( String.valueOf( i ) );
	}

	//JComboBoxes
	//COMPUTE_UP_TO
 	__props_1_changeint_JComboBox =
	new SimpleJComboBox( prop_1_vect );

	//MAX_ALERT
 	__props_2_changeint_JComboBox =
	new SimpleJComboBox( prop_2_vect );

	//JTextField - NEWDATATYPE
 	__props_3_changeint_JTextField =
	new JTextField( 10 );

	//JTextField - NEWDATATYPE
 	__props_4_changeint_JComboBox =
	new SimpleJComboBox( prop_4_vect );

	try {
		int x = 0;
		int y = 0;
		//all inputTS label
		JGUIUtil.addComponent(
		ts_panel, all_inputTS_JLabel,
		x, y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

		//all inputTS list
		JGUIUtil.addComponent(
		ts_panel, all_inputTS_JScrollPane,
		x, ++y, 1, 2, 1, 0, __insets,
		GridBagConstraints.BOTH,
		GridBagConstraints.WEST );

		//move right button
		JGUIUtil.addComponent(
		ts_panel, __move_inputTS_right_JButton,
		++x, ++y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.CENTER );

		--y;
		//label for selected time series
		JGUIUtil.addComponent(
		ts_panel, inputTS_JLabel,
		++x, --y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

		//List of selected time series
		JGUIUtil.addComponent(
		ts_panel, inputTS_JScrollPane,
		x, ++y, 1, 2, 1, 0, __insets,
		GridBagConstraints.BOTH,
		GridBagConstraints.EAST );

		//button to delete a selected time series
		JGUIUtil.addComponent(
		ts_panel, __remove_selected_inputTS_JButton,
		++x, ++y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.EAST );

		//Insets insets = new Insets ( 15, 5, 10, 5 );
		x=0;
		++y;
		++y;
		JGUIUtil.addComponent(
		props_panel, prop_1_JLabel,
		x, ++y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.EAST );

		JGUIUtil.addComponent(
		props_panel, __props_1_changeint_JComboBox,
		++x, y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

		JGUIUtil.addComponent(
		props_panel, prop_1_desc,
		++x, y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

		x=0;
		JGUIUtil.addComponent(
		props_panel, prop_2_JLabel,
		x, ++y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.EAST );

		JGUIUtil.addComponent(
		props_panel, __props_2_changeint_JComboBox,
		++x, y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

		JGUIUtil.addComponent(
		props_panel, prop_2_desc,
		++x, y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

/*Obsolete	x=0;
		JGUIUtil.addComponent(
		props_panel, prop_3_JLabel,
		x, ++y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.EAST );

		JGUIUtil.addComponent(
		props_panel, __props_3_changeint_JTextField,
		++x, y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

		JGUIUtil.addComponent(
		props_panel, prop_3_desc,
		++x, y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );
*/
		x=0;
		JGUIUtil.addComponent(
		props_panel, prop_4_JLabel,
		x, ++y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.EAST );

		JGUIUtil.addComponent(
		props_panel, __props_4_changeint_JComboBox,
		++x, y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

		JGUIUtil.addComponent(
		props_panel, prop_4_desc,
		++x, y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

		//put 2 panels together in main panel
		JGUIUtil.addComponent(
		panel, ts_panel,
		0, 0, 1, 1, 1, 0, __insets,
		GridBagConstraints.BOTH,
		GridBagConstraints.CENTER );

		JGUIUtil.addComponent(
		panel, props_panel,
		0, 1, 1, 1, 1, 0, __insets,
		GridBagConstraints.BOTH,
		GridBagConstraints.CENTER );
	}
	catch ( Exception e) {
		Message.printWarning( 2, routine,
		"Error laying out the Input Time Series " +
		"panel for type: " + __proc_changeint_str );
		Message.printWarning( 2, routine, e );
	}

	//clean up
	prop_1_vect = null;
	prop_2_vect = null;
	prop_3_vect = null;

	return panel;
} //end assemble_inputTS_changeint_panel

/**
Assembles panel to display Input Time Series for time series
type: fillfloodmonitor.
@return Assembled JPanel.
*/
protected JPanel assemble_inputTS_fillfloodmonitor_panel ( ) {
	String routine = __class + ".assemble_inputTS_fillfloodmonitor_panel";
	JPanel panel = new JPanel();
	panel.setLayout( new GridBagLayout() );

	JPanel ts_panel = new JPanel();
	ts_panel.setLayout( new GridBagLayout() );

	JPanel props_panel = new JPanel();
	props_panel.setLayout( new GridBagLayout() );

	//make border for all inputTS panels
	Border ts_titled_border=BorderFactory.createTitledBorder( __inputTS_JPanel_string );

	ts_panel.setBorder( ts_titled_border);

	Border props_titled_border=
	BorderFactory.createTitledBorder( __props_JLabel_string );

	//add titled border to panel
	props_panel.setBorder( props_titled_border);


	//label for left list (list of all inputTS possiblities)
	JLabel all_inputTS_JLabel = new JLabel( __all_inputTS_JList_string + ":");
	all_inputTS_JLabel.setToolTipText("List of all available time series");

	//list of all possibilities
 	__all_inputTS_ListModel = new DefaultListModel();
 	__all_inputTS_JList = new JList(
 	__all_inputTS_ListModel );
 	__all_inputTS_JList.setVisibleRowCount(5);
 	__all_inputTS_JList.setSelectionMode(
	ListSelectionModel.MULTIPLE_INTERVAL_SELECTION );

	JScrollPane all_inputTS_JScrollPane = new JScrollPane(
 	__all_inputTS_JList);
	all_inputTS_JScrollPane.setVerticalScrollBarPolicy(
		JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
	all_inputTS_JScrollPane.setPreferredSize( __scroll_dim );
	all_inputTS_JScrollPane.setMinimumSize( __scroll_dim );

	//label for the selected inputTS
	JLabel inputTS_JLabel = new JLabel( __inputTS_JList_string + ":");
	inputTS_JLabel.setToolTipText("List of selected time series");
	//list for selected input TS
 	__sel_inputTS_ListModel = new DefaultListModel();
 	__sel_inputTS_JList = new JList(
 	__sel_inputTS_ListModel );
 	__sel_inputTS_JList.setVisibleRowCount( 5 );

	JScrollPane inputTS_JScrollPane = new JScrollPane(
 	__sel_inputTS_JList);
	inputTS_JScrollPane.setVerticalScrollBarPolicy(
		JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
	inputTS_JScrollPane.setPreferredSize( __scroll_dim );

	//button to move time series from the "all" list to the
	//"selected" list
 	__move_inputTS_right_JButton = new SimpleJButton(
 	__move_inputTS_right_JButton_string,
 	__move_inputTS_right_JButton_string, this );
	
	//button to remove a TS from the selected list
 	__remove_selected_inputTS_JButton = new SimpleJButton(
 	__remove_selected_inputTS_JButton_string,
 	__remove_selected_inputTS_JButton_string, this );

	//properties for FILLFLOODMONITOR
	//Labels  for combobox
	//"SCENARIO_FOR_COMPUTATION";
/*Obsolete
	JLabel prop_1_JLabel = new JLabel(
 	__props_1_fillfloodmonitor_JLabel_string + ":" );
	JLabel prop_1_desc = new JLabel(
 	__props_1_fillfloodmonitor_desc );
	prop_1_JLabel.setToolTipText("Optional: Scenario for FloodMonitor "+
	"statistics" );
*/

	//SAVE_TRANSFORMED_INPUT_TS
	JLabel prop_2_JLabel = new JLabel(
 	__props_2_fillfloodmonitor_JLabel_string + ":" );
	JLabel prop_2_desc = new JLabel(
 	__props_2_fillfloodmonitor_desc );
	prop_2_JLabel.setToolTipText("<html>Optional: Save the intermediate " +
	"time series to the database<br>when an output time series is of " +
	"different interval than the input time series and a <br>CHANGEINT " +
	"reduction is (automatically) performed.</html>");

	//vector for comboboxes

	Vector prop_1_vect = new Vector();
	Vector prop_1_scen_vect = null;
	try {
		prop_1_scen_vect= __dmi.readScenarioList();
	}
	catch ( Exception e) {
		Message.printWarning( 2, routine, e );
	}
	if ( prop_1_scen_vect ==  null ) {
		prop_1_scen_vect = new Vector();
	}
	//go through vector and trim strings to 50 
	int size = 0;
	size = prop_1_scen_vect.size();
	String s= null;

	for ( int i=0; i<size; i++ ) {
	RiversideDB_Scenario rs = null;
		try {
			rs = (RiversideDB_Scenario) 
			prop_1_scen_vect.elementAt(i);

		} catch (Exception e) {Message.printWarning( 2, routine, e); }
		if ( rs == null ) {
			continue;
		}
		s = rs.getIdentifier() ;
		if (s.length() > 50 )  {
			s = s.substring( 0, 50 ) + "..." ;
		}
		prop_1_vect.addElement( s );
	}

	//one more property to vector
	prop_1_vect.insertElementAt( DEFAULT_STRING + 
	" - SIMULATION.ZERO_QPF_SCENARIO", 0 );

	Vector prop_2_vect = new Vector();
	prop_2_vect.addElement( DEFAULT_STRING + " - FALSE" );
	prop_2_vect.addElement("TRUE");

	//JComboBoxes
 	__props_1_fillfloodmonitor_JComboBox = new SimpleJComboBox( prop_1_vect );
 	__props_2_fillfloodmonitor_JComboBox = new SimpleJComboBox( prop_2_vect );

	try {

		int x = 0;
		int y = 0;
		//all inputTS label
		JGUIUtil.addComponent(
		ts_panel, all_inputTS_JLabel,
		x, y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

		//all inputTS list
		JGUIUtil.addComponent(
		ts_panel, all_inputTS_JScrollPane,
		x, ++y, 1, 2, 1, 0, __insets,
		GridBagConstraints.BOTH,
		GridBagConstraints.WEST );

		//move right button
		JGUIUtil.addComponent(
		ts_panel, __move_inputTS_right_JButton,
		++x, ++y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.CENTER );

		--y;
		//label for selected time series
		JGUIUtil.addComponent(
		ts_panel, inputTS_JLabel,
		++x, --y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

		//List of selected time series
		JGUIUtil.addComponent(
		ts_panel, inputTS_JScrollPane,
		x, ++y, 1, 2, 1, 0, __insets,
		GridBagConstraints.BOTH,
		GridBagConstraints.EAST );

		//button to delete a selected time series
		JGUIUtil.addComponent(
		ts_panel, __remove_selected_inputTS_JButton,
		++x, ++y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.EAST );

		//Insets insets = new Insets ( 15, 5, 10, 5 );
		x=0;
		++y;
		++y;
		
/* Obsolete		
		JGUIUtil.addComponent(
		props_panel, prop_1_JLabel,
		x, ++y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.EAST );

		JGUIUtil.addComponent(
		props_panel, __props_1_fillfloodmonitor_JComboBox,
		++x, y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

		JGUIUtil.addComponent(
		props_panel, prop_1_desc,
		++x, y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );
*/
		//SAVE_TRANSFORMED...
		x=0;
		JGUIUtil.addComponent(
		props_panel, prop_2_JLabel,
		x, ++y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.EAST );

		JGUIUtil.addComponent(
		props_panel, __props_2_fillfloodmonitor_JComboBox,
		++x, y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

		JGUIUtil.addComponent(
		props_panel, prop_2_desc,
		++x, y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

		//put 2 panels together in main panel
		JGUIUtil.addComponent(
		panel, ts_panel,
		0, 0, 1, 1, 1, 0, __insets,
		GridBagConstraints.BOTH,
		GridBagConstraints.CENTER );

		JGUIUtil.addComponent(
		panel, props_panel,
		0, 1, 1, 1, 1, 0, __insets,
		GridBagConstraints.BOTH,
		GridBagConstraints.CENTER );
	}
	catch ( Exception e) {
		Message.printWarning( 2, routine,
		"Error laying out the Input Time Series " +
		"panel for type: " + __proc_fillfloodmonitor_str );
		Message.printWarning( 2, routine, e );
	}
	return panel;
} //end assemble_inputTS_fillfloodmonitor_panel


/**
Assembles panel to display Input Time Series for time series
type: fillrepeat.
@return Assembled JPanel.
*/
protected JPanel assemble_inputTS_fillrepeat_panel ( ) {
	String routine = __class + ".assemble_inputTS_fillrepeat_panel";
	JPanel panel = new JPanel();
	panel.setLayout( new GridBagLayout() );

	JPanel ts_panel = new JPanel();
	ts_panel.setLayout( new GridBagLayout() );

	//make border for all inputTS panels
	Border ts_titled_border=BorderFactory.createTitledBorder( __inputTS_JPanel_string );

	panel.setBorder( ts_titled_border);

	//label for left list (list of all inputTS possiblities)
	JLabel all_inputTS_JLabel = new JLabel( __all_inputTS_JList_string + ":");
	all_inputTS_JLabel.setToolTipText("List of all available time series");

	//list of all possibilities
 	__all_inputTS_ListModel = new DefaultListModel();
 	__all_inputTS_JList = new JList(
 	__all_inputTS_ListModel );
 	__all_inputTS_JList.setVisibleRowCount(5);
 	__all_inputTS_JList.setSelectionMode(
	ListSelectionModel.MULTIPLE_INTERVAL_SELECTION );

	JScrollPane all_inputTS_JScrollPane = new JScrollPane(
 	__all_inputTS_JList);
	all_inputTS_JScrollPane.setVerticalScrollBarPolicy(
		JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
	all_inputTS_JScrollPane.setPreferredSize( __scroll_dim );
	all_inputTS_JScrollPane.setMinimumSize( __scroll_dim );

	//label for the selected inputTS
	JLabel inputTS_JLabel = new JLabel( __inputTS_JList_string + ":");
	inputTS_JLabel.setToolTipText("List of selected time series");
	//list for selected input TS
 	__sel_inputTS_ListModel = new DefaultListModel();
 	__sel_inputTS_JList = new JList(
 	__sel_inputTS_ListModel );
 	__sel_inputTS_JList.setVisibleRowCount(5);

	JScrollPane inputTS_JScrollPane = new JScrollPane(
 	__sel_inputTS_JList);
	inputTS_JScrollPane.setVerticalScrollBarPolicy(
		JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
	inputTS_JScrollPane.setPreferredSize( __scroll_dim );

	//button to move time series from the "all" list to the
	//"selected" list
 	__move_inputTS_right_JButton = new SimpleJButton(
 	__move_inputTS_right_JButton_string,
 	__move_inputTS_right_JButton_string, this );

	//button to remove a TS from the selected list
 	__remove_selected_inputTS_JButton = new SimpleJButton(
 	__remove_selected_inputTS_JButton_string,
 	__remove_selected_inputTS_JButton_string, this );

	try {
		int x = 0;
		int y = 0;
		//all inputTS label
		JGUIUtil.addComponent(
		ts_panel, all_inputTS_JLabel,
		x, y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

		//all inputTS list
		JGUIUtil.addComponent(
		ts_panel, all_inputTS_JScrollPane,
		x, ++y, 1, 2, 1, 0, __insets,
		GridBagConstraints.BOTH,
		GridBagConstraints.WEST );

		//move right button
		JGUIUtil.addComponent(
		ts_panel, __move_inputTS_right_JButton,
		++x, ++y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.CENTER );

		--y;
		//label for selected time series
		JGUIUtil.addComponent(
		ts_panel, inputTS_JLabel,
		++x, --y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

		//List of selected time series
		JGUIUtil.addComponent(
		ts_panel, inputTS_JScrollPane,
		x, ++y, 1, 2, 1, 0, __insets,
		GridBagConstraints.BOTH,
		GridBagConstraints.EAST );

		//button to delete a selected time series
		JGUIUtil.addComponent(
		ts_panel, __remove_selected_inputTS_JButton,
		++x, ++y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.EAST );

		//put 2 panels together in main panel
		JGUIUtil.addComponent(
		panel, ts_panel,
		0, 0, 1, 1, 1, 0, __insets,
		GridBagConstraints.BOTH,
		GridBagConstraints.CENTER );

	}
	catch ( Exception e) {
		Message.printWarning( 2, routine,
		"Error laying out the Input Time Series " +
		"panel for type: " + __proc_fillrepeat_str );
		Message.printWarning( 2, routine, e );
	}
	return panel;
} //end assemble_inputTS_fillrepeat_panel


/**
Assembles panel to display Input Time Series for time series
type: map.
@return Assembled JPanel.
*/
protected JPanel assemble_inputTS_map_panel ( ) {
	String routine = __class + ".assemble_inputTS_map_panel";
	JPanel panel = new JPanel();
	panel.setLayout( new GridBagLayout() );

	JPanel ts_panel = new JPanel();
	ts_panel.setLayout( new GridBagLayout() );

	JPanel props_panel = new JPanel();
	props_panel.setLayout( new GridBagLayout() );

	//make border for all inputTS panels
	Border ts_titled_border=BorderFactory.createTitledBorder( __inputTS_JPanel_string );

	ts_panel.setBorder( ts_titled_border);

	Border props_titled_border=
	BorderFactory.createTitledBorder( __props_JLabel_string );

	//add titled border to panel
	props_panel.setBorder( props_titled_border);

	//label for left list (list of all inputTS possiblities)
	JLabel all_inputTS_JLabel = new JLabel( __all_inputTS_JList_string + ":");
	all_inputTS_JLabel.setToolTipText("List of all available time series");

	//list of all possibilities
 	__all_inputTS_ListModel = new DefaultListModel();
 	__all_inputTS_JList = new JList(
 	__all_inputTS_ListModel );
 	__all_inputTS_JList.setVisibleRowCount(5);
 	__all_inputTS_JList.setSelectionMode(
	ListSelectionModel.MULTIPLE_INTERVAL_SELECTION );

	JScrollPane all_inputTS_JScrollPane = new JScrollPane(
 	__all_inputTS_JList);
	all_inputTS_JScrollPane.setVerticalScrollBarPolicy(
		JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);

	all_inputTS_JScrollPane.setPreferredSize( __scroll_dim );
	all_inputTS_JScrollPane.setMinimumSize( __scroll_dim );

	//label for the selected inputTS
	JLabel inputTS_JLabel = new JLabel( __inputTS_JList_string + ":");
	inputTS_JLabel.setToolTipText("List of selected time series");

	if ( __worksheet_props == null ) {
 		__worksheet_props = new PropList(
		"RTiAdminDB_ProjectWorksheet_JPanel.JWorksheet");
 		__worksheet_props.add("JWorksheet.CellFontName=Courier");
 		__worksheet_props.add("JWorksheet.CellFontStyle=Plain");
 		__worksheet_props.add("JWorksheet.CellFontSize=11");
 		__worksheet_props.add("JWorksheet.ColumnHeaderFontName=Arial");
 		__worksheet_props.add("JWorksheet.ColumnHeaderFontStyle=Plain");
 		__worksheet_props.add("JWorksheet.ColumnHeaderFontSize=11");
 		__worksheet_props.add("JWorksheet.ColumnHeaderBackground=LightGray");
 		__worksheet_props.add("JWorksheet.ShowRowHeader=false");
 		__worksheet_props.add("JWorksheet.ShowPopupMenu=true");
 		__worksheet_props.add("JWorksheet.SelectionMode=SingleRowSelection");
	}
	//make worksheet
	Vector v = new Vector();
	String arr[] = {"",""};
	v.add(arr);

	try {
		RiversideDB_StationWeights_TableModel tm =
		new RiversideDB_StationWeights_TableModel( __dmi, v );
			
		RiversideDB_StationWeights_CellRenderer crr =
		new RiversideDB_StationWeights_CellRenderer(tm);
 		__weights_JWorksheet = new JWorksheet (
		crr, tm, __worksheet_props );

			
 		__weights_worksheet_widths = crr.getColumnWidths();
	}
	catch ( Exception e ) {
		Message.printWarning( 2, routine, e );
 		__weights_JWorksheet = new JWorksheet( 0, 0, 
 		__worksheet_props );
	}

	JScrollPane sel_inputTS_JScrollPane = new JScrollPane(
 	__weights_JWorksheet);

	sel_inputTS_JScrollPane.setVerticalScrollBarPolicy(
		JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
	sel_inputTS_JScrollPane.setPreferredSize( __worksheet_dim );
	sel_inputTS_JScrollPane.setMinimumSize( __worksheet_dim );

	//button to move time series from the "all" list to the
	//"selected" list
 	__move_inputTS_right_JButton = new SimpleJButton(
 	__move_inputTS_right_JButton_string,
 	__move_inputTS_right_JButton_string, this );

	//button to remove a TS from the selected list
 	__remove_selected_inputTS_JButton = new SimpleJButton(
 	__remove_selected_inputTS_JButton_string,
 	__remove_selected_inputTS_JButton_string, this );

	//Jlabel for properties
	//"ALPHA";
	JLabel prop_1_JLabel = new JLabel(
 	__props_1_map_JLabel_string + ":" );
	JLabel prop_1_desc = new JLabel(
 	__props_1_map_desc );
	prop_1_JLabel.setToolTipText("Optional: re-weights stations " +
	"if 1+ stations report MISSING.");

	//"SET_TO_ZERO";
	JLabel prop_2_JLabel = new JLabel(
 	__props_2_map_JLabel_string + ":" );
	JLabel prop_2_desc = new JLabel(
 	__props_2_map_desc );
	prop_2_JLabel.setToolTipText("Optional: If cannot be computed, " +
	"sets the MAP value to ZERO." );


	//"SAVE_TRANSFORMED_INPUT_TS";
	JLabel prop_3_JLabel = new JLabel(
 	__props_3_map_JLabel_string + ":" );
	JLabel prop_3_desc = new JLabel(
 	__props_3_map_desc );
	prop_3_JLabel.setToolTipText("<html>Optional: Save the intermediate " +
	"time series to the database<br>when an output time series is of " +
	"different interval than the input time series and a <br>CHANGEINT " +
	"reduction is (automatically) performed.</html>");



	//vector for properties
	Vector prop_1_vect = new Vector();
	prop_1_vect.addElement( DEFAULT_STRING + " - -999" );
	prop_1_vect.addElement( "1.0" );
	prop_1_vect.addElement( "2.0" );
	prop_1_vect.addElement( "3.0" );
	prop_1_vect.addElement( "4.0" );
	prop_1_vect.addElement( "5.0" );
	prop_1_vect.addElement( "6.0" );
	prop_1_vect.addElement( "7.0" );
	prop_1_vect.addElement( "8.0" );
	prop_1_vect.addElement( "9.0" );
	prop_1_vect.addElement( "10.0" );

	Vector prop_2_vect = new Vector();
	prop_2_vect.addElement( DEFAULT_STRING + " - TRUE" );
	prop_2_vect.addElement( "FALSE" );

	Vector prop_3_vect = new Vector();
	prop_3_vect.addElement( DEFAULT_STRING + " - FALSE" );
	prop_3_vect.addElement("TRUE");

	//JComboBoxes
 	__props_1_map_JComboBox = new SimpleJComboBox( prop_1_vect );
	
 	__props_2_map_JComboBox = new SimpleJComboBox( prop_2_vect );

 	__props_3_map_JComboBox = new SimpleJComboBox( prop_3_vect );

	try {
		int x = 0;
		int y = 0;
		//all inputTS label
		JGUIUtil.addComponent(
		ts_panel, all_inputTS_JLabel,
		x, y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

		//all inputTS list
		JGUIUtil.addComponent(
		ts_panel, all_inputTS_JScrollPane,
		x, ++y, 1, 2, 1, 0, __insets,
		GridBagConstraints.BOTH,
		GridBagConstraints.WEST );

		//move right button
		JGUIUtil.addComponent(
		ts_panel, __move_inputTS_right_JButton,
		++x, ++y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.CENTER );

		--y;
		//label for selected time series
		JGUIUtil.addComponent(
		ts_panel, inputTS_JLabel,
		++x, --y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

		/*
		//List of selected time series
		JGUIUtil.addComponent(
		ts_panel, inputTS_JScrollPane,
		x, ++y, 1, 2, 1, 0, __insets,
		GridBagConstraints.BOTH,
		GridBagConstraints.EAST );
		*/
//////////////
		//worksheet of selected time series
		JGUIUtil.addComponent(
		ts_panel, sel_inputTS_JScrollPane,
		x, ++y, 1, 2, 1, 0, __insets,
		GridBagConstraints.BOTH,
		GridBagConstraints.EAST );
//////////////

		//button to delete a selected time series
		JGUIUtil.addComponent(
		ts_panel, __remove_selected_inputTS_JButton,
		++x, ++y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.EAST );

		x=0;
		++y;
		++y;
		JGUIUtil.addComponent(
		props_panel, prop_1_JLabel,
		x, ++y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.EAST );

		JGUIUtil.addComponent(
		props_panel, __props_1_map_JComboBox,
		++x, y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

		JGUIUtil.addComponent(
		props_panel, prop_1_desc,
		++x, y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

		x=0;
		JGUIUtil.addComponent(
		props_panel, prop_2_JLabel,
		x, ++y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.EAST );

		JGUIUtil.addComponent(
		props_panel, __props_2_map_JComboBox,
		++x, y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

		JGUIUtil.addComponent(
		props_panel, prop_2_desc,
		++x, y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

		x=0;
		JGUIUtil.addComponent(
		props_panel, prop_3_JLabel,
		x, ++y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.EAST );

		JGUIUtil.addComponent(
		props_panel, __props_3_map_JComboBox,
		++x, y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

		JGUIUtil.addComponent(
		props_panel, prop_3_desc,
		++x, y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

		//put 2 panels together in main panel
		JGUIUtil.addComponent(
		panel, ts_panel,
		0, 0, 1, 1, 1, 0, __insets,
		GridBagConstraints.BOTH,
		GridBagConstraints.CENTER );

		JGUIUtil.addComponent(
		panel, props_panel,
		0, 1, 1, 1, 1, 0, __insets,
		GridBagConstraints.BOTH,
		GridBagConstraints.CENTER );
	}
	catch ( Exception e) {
		Message.printWarning( 2, routine,
		"Error laying out the Input Time Series " +
		"panel for type: " + __proc_map_str );
		Message.printWarning( 2, routine, e );
	}
	return panel;
} //end assemble_inputTS_map_panel


/**
Assembles panel to display Input Time Series for time series
type: mapx.
@return Assembled JPanel.
*/
protected JPanel assemble_inputTS_mapx_panel ( ) {
	String routine = __class + ".assemble_inputTS_mapx_panel";
	JPanel panel = new JPanel();
	panel.setLayout( new GridBagLayout() );

	JPanel ts_panel = new JPanel();
	ts_panel.setLayout( new GridBagLayout() );

	JPanel props_panel = new JPanel();
	props_panel.setLayout( new GridBagLayout() );

	//make border for all inputTS panels
	Border ts_titled_border=
	BorderFactory.createTitledBorder( __inputTS_JPanel_string );

	ts_panel.setBorder( ts_titled_border);

	Border props_titled_border=
	BorderFactory.createTitledBorder( __props_JLabel_string );

	//add titled border to panel
	props_panel.setBorder( props_titled_border);


	//label for left list (list of all inputTS possiblities)
	JLabel all_inputTS_JLabel = new JLabel( __all_inputTS_JList_string + ":");
	all_inputTS_JLabel.setToolTipText("List of all available time series");

	// list of all possibilities
 	__all_inputTS_ListModel = new DefaultListModel();
 	__all_inputTS_JList = new JList(
 	__all_inputTS_ListModel );
 	__all_inputTS_JList.setVisibleRowCount(5);
 	__all_inputTS_JList.setSelectionMode(
	ListSelectionModel.MULTIPLE_INTERVAL_SELECTION );

	JScrollPane all_inputTS_JScrollPane = new JScrollPane(
 	__all_inputTS_JList);
	all_inputTS_JScrollPane.setVerticalScrollBarPolicy(
		JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
	all_inputTS_JScrollPane.setPreferredSize( __scroll_dim );
	all_inputTS_JScrollPane.setMinimumSize( __scroll_dim );

	//label for the selected inputTS
	JLabel inputTS_JLabel = new JLabel( __inputTS_JList_string + ":");
	inputTS_JLabel.setToolTipText("List of selected time series");
	//list for selected input TS
 	__sel_inputTS_ListModel = new DefaultListModel();
 	__sel_inputTS_JList = new JList(
 	__sel_inputTS_ListModel );
 	__sel_inputTS_JList.setVisibleRowCount(5);

	JScrollPane inputTS_JScrollPane = new JScrollPane(
 	__sel_inputTS_JList);
	inputTS_JScrollPane.setVerticalScrollBarPolicy(
		JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
	inputTS_JScrollPane.setPreferredSize( __scroll_dim );

	//button to move time series from the "all" list to the
	//"selected" list
 	__move_inputTS_right_JButton = new SimpleJButton(
 	__move_inputTS_right_JButton_string,
 	__move_inputTS_right_JButton_string, this );
	
	//button to remove a TS from the selected list
 	__remove_selected_inputTS_JButton = new SimpleJButton(
 	__remove_selected_inputTS_JButton_string,
 	__remove_selected_inputTS_JButton_string, this );

	//jlabel for properties
	//= "SET_MISSING_TO_ZERO";
	JLabel prop_1_JLabel = new JLabel(
 	__props_1_mapx_JLabel_string + ":" );
	JLabel prop_1_desc = new JLabel(
 	__props_1_mapx_desc );
	prop_1_JLabel.setToolTipText("Optional: Select TRUE to set " +
	"MISSING data to be ZERO" );

	// "SAVE_TRANSFORMED_INPUT_TS";
/*Obsolete
	JLabel prop_2_JLabel = new JLabel(
 	__props_2_mapx_JLabel_string + ":" );
	JLabel prop_2_desc = new JLabel(
 	__props_2_mapx_desc );
	prop_2_JLabel.setToolTipText("<html>Optional: Save the intermediate " +
	"time series to the database<br>when an output time series is of " +
	"different interval than the input time series and a <br>CHANGEINT " +
	"reduction is (automatically) performed.</html>");
*/

	//vector for properties
	Vector prop_1_vect = new Vector();
	prop_1_vect.addElement( DEFAULT_STRING + " - FALSE" );
	prop_1_vect.addElement( "TRUE" );

	Vector prop_2_vect = new Vector();
	prop_2_vect.addElement( DEFAULT_STRING + " - FALSE" );
	prop_2_vect.addElement("TRUE");

	//JComobBoxes for properties
 	__props_1_mapx_JComboBox =
	new SimpleJComboBox( prop_1_vect );
 	__props_2_mapx_JComboBox =
	new SimpleJComboBox( prop_2_vect );

	try {

		int x = 0;
		int y = 0;
		//all inputTS label
		JGUIUtil.addComponent(
		ts_panel, all_inputTS_JLabel,
		x, y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

		//all inputTS list
		JGUIUtil.addComponent(
		ts_panel, all_inputTS_JScrollPane,
		x, ++y, 1, 2, 1, 0, __insets,
		GridBagConstraints.BOTH,
		GridBagConstraints.WEST );

		//move right button
		JGUIUtil.addComponent(
		ts_panel, __move_inputTS_right_JButton,
		++x, ++y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.CENTER );

		--y;
		//label for selected time series
		JGUIUtil.addComponent(
		ts_panel, inputTS_JLabel,
		++x, --y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

		//List of selected time series
		JGUIUtil.addComponent(
		ts_panel, inputTS_JScrollPane,
		x, ++y, 1, 2, 1, 0, __insets,
		GridBagConstraints.BOTH,
		GridBagConstraints.EAST );

		//button to delete a selected time series
		JGUIUtil.addComponent(
		ts_panel, __remove_selected_inputTS_JButton,
		++x, ++y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.EAST );

		//Insets insets = new Insets ( 15, 5, 10, 5 );
		x=0;
		++y;
		++y;
		
		JGUIUtil.addComponent(
		props_panel, prop_1_JLabel,
		x, ++y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.EAST );

		JGUIUtil.addComponent(
		props_panel, __props_1_mapx_JComboBox,
		++x, y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

		JGUIUtil.addComponent(
		props_panel, prop_1_desc,
		++x, y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

/*Obsolete
		x=0;
		JGUIUtil.addComponent(
		props_panel, prop_2_JLabel,
		x, ++y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.EAST );

		JGUIUtil.addComponent(
		props_panel, __props_2_mapx_JComboBox,
		++x, y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

		JGUIUtil.addComponent(
		props_panel, prop_2_desc,
		++x, y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );
*/
		//put 2 panels together in main panel
		JGUIUtil.addComponent(
		panel, ts_panel,
		0, 0, 1, 1, 1, 0, __insets,
		GridBagConstraints.BOTH,
		GridBagConstraints.CENTER );

		JGUIUtil.addComponent(
		panel, props_panel,
		0, 1, 1, 1, 1, 0, __insets,
		GridBagConstraints.BOTH,
		GridBagConstraints.CENTER );
	}
	catch ( Exception e) {
		Message.printWarning( 2, routine,
		"Error laying out the Input Time Series " +
		"panel for type: " + __proc_mapx_str );
		Message.printWarning( 2, routine, e );
	}
	return panel;
} //end assemble_inputTS_MAPX_panel


/**
Assembles panel to display Input Time Series for time series
type: mat.
@return Assembled JPanel.
*/
protected JPanel assemble_inputTS_mat_panel ( ) {
	String routine = __class + ".assemble_inputTS_mat_panel";
	JPanel panel = new JPanel();
	panel.setLayout( new GridBagLayout() );

	JPanel ts_panel = new JPanel();
	ts_panel.setLayout( new GridBagLayout() );

	JPanel props_panel = new JPanel();
	props_panel.setLayout( new GridBagLayout() );

	//make border for all inputTS panels
	Border ts_titled_border=BorderFactory.createTitledBorder( __inputTS_JPanel_string );

	ts_panel.setBorder( ts_titled_border);

	Border props_titled_border=
	BorderFactory.createTitledBorder( __props_JLabel_string );

	//add titled border to panel
	props_panel.setBorder( props_titled_border);

	//label for left list (list of all inputTS possiblities)
	JLabel all_inputTS_JLabel = new JLabel( __all_inputTS_JList_string + ":");
	all_inputTS_JLabel.setToolTipText("List of all available time series");

	//list of all possibilities
 	__all_inputTS_ListModel = new DefaultListModel();
 	__all_inputTS_JList = new JList(
 	__all_inputTS_ListModel );
 	__all_inputTS_JList.setVisibleRowCount(5);
 	__all_inputTS_JList.setSelectionMode(
	ListSelectionModel.MULTIPLE_INTERVAL_SELECTION );

	JScrollPane all_inputTS_JScrollPane = new JScrollPane(
 	__all_inputTS_JList);
	all_inputTS_JScrollPane.setVerticalScrollBarPolicy(
		JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
	all_inputTS_JScrollPane.setPreferredSize( __scroll_dim );
	all_inputTS_JScrollPane.setMinimumSize( __scroll_dim );

	//label for the selected inputTS
	JLabel inputTS_JLabel = new JLabel( __inputTS_JList_string + ":");
	inputTS_JLabel.setToolTipText("List of selected time series");
	//Selected inputTS worksheet
	if ( __worksheet_props == null ) {
 		__worksheet_props = new PropList(
		"RTiAdminDB_ProjectWorksheet_JPanel.JWorksheet");
 		__worksheet_props.add("JWorksheet.CellFontName=Courier");
 		__worksheet_props.add("JWorksheet.CellFontStyle=Plain");
 		__worksheet_props.add("JWorksheet.CellFontSize=11");
 		__worksheet_props.add("JWorksheet.ColumnHeaderFontName=Arial");
 		__worksheet_props.add("JWorksheet.ColumnHeaderFontStyle=Plain");
 		__worksheet_props.add("JWorksheet.ColumnHeaderFontSize=11");
 		__worksheet_props.add("JWorksheet.HeaderBackground=LightGray");
		__worksheet_props.add("JWorksheet.ShowRowHeader=false");
 		__worksheet_props.add("JWorksheet.ShowPopupMenu=true");
 		__worksheet_props.add("JWorksheet.SelectionMode=ExcelSelection");
	}
	//make worksheet
	Vector v = new Vector();
	String arr[] = {"",""};
	v.add(arr);

	try {
		RiversideDB_StationWeights_TableModel tm =
		new RiversideDB_StationWeights_TableModel( __dmi, v );
			
		RiversideDB_StationWeights_CellRenderer crr =
		new RiversideDB_StationWeights_CellRenderer(tm);
 		__weights_JWorksheet = new JWorksheet (
		crr, tm, __worksheet_props );

 		__weights_worksheet_widths = crr.getColumnWidths();
	}
	catch ( Exception e ) {
		Message.printWarning( 2, routine, e );
 		__weights_JWorksheet = new JWorksheet( 0, 0, 
 		__worksheet_props );
	}

	JScrollPane sel_inputTS_JScrollPane = new JScrollPane(
 	__weights_JWorksheet);
	sel_inputTS_JScrollPane.setVerticalScrollBarPolicy(
		JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
	sel_inputTS_JScrollPane.setPreferredSize( __worksheet_dim );
	sel_inputTS_JScrollPane.setMinimumSize( __worksheet_dim );

	//button to move time series from the "all" list to the
	//"selected" list
 	__move_inputTS_right_JButton = new SimpleJButton(
 	__move_inputTS_right_JButton_string,
 	__move_inputTS_right_JButton_string, this );

	//button to remove a TS from the selected list
 	__remove_selected_inputTS_JButton = new SimpleJButton(
 	__remove_selected_inputTS_JButton_string,
 	__remove_selected_inputTS_JButton_string, this );

	//jlabel for properties
	//"BLEND_DURATION";
	JLabel prop_1_JLabel = new JLabel(
 	__props_1_mat_JLabel_string + ":" );
	JLabel prop_1_desc = new JLabel(
 	__props_1_mat_desc );
	prop_1_JLabel.setToolTipText("Optional: WIndow used to blend " +
	"the last observations" );

	//"DIURNAL_VARIATION";
	JLabel prop_2_JLabel = new JLabel(
 	__props_2_mat_JLabel_string + ":" );
	JLabel prop_2_desc = new JLabel(
 	__props_2_mat_desc );
	prop_2_JLabel.setToolTipText("<html>Temperature variation for each "+
	"hour in the day (0.0 is min and 1.0 is max)<br>" +
	"Generally set to: <br>" +
	".5 .4 .4 .3 .2 .1 0 .1 .2 .3 .4 .5 .7 .8 .9 1 1 .9 .9 .8 .8 .7 .6 .6 "+
	"</html>" );

	// "SAVE_TRANSFORMED_INPUT_TS";
	JLabel prop_3_JLabel = new JLabel(
 	__props_3_mat_JLabel_string + ":" );
	JLabel prop_3_desc = new JLabel(
 	__props_3_mat_desc );
	prop_3_JLabel.setToolTipText("<html>Optional: Save the intermediate " +
	"time series to the database<br>when an output time series is of " +
	"different interval than the input time series and a <br>CHANGEINT " +
	"reduction is (automatically) performed.</html>");


	//vector for comoboboxes for properties
	Vector prop_1_vect = new Vector();
	// ideally should have 2 comboboxes:  
	//1 with: DAY and HOUR  and other: 1-12
	prop_1_vect.addElement( "1DAY" );
	prop_1_vect.addElement( "2DAY" );
	prop_1_vect.addElement( "3DAY" );
	prop_1_vect.addElement( "4DAY" );
	prop_1_vect.addElement( "5DAY" );
	prop_1_vect.addElement( "6DAY" );
	prop_1_vect.addElement( "7DAY" );
	prop_1_vect.addElement( "8DAY" );
	prop_1_vect.addElement( "9DAY" );
	prop_1_vect.addElement( "10DAY" );
	prop_1_vect.addElement( "11DAY" );
	prop_1_vect.addElement( "12DAY" );
	prop_1_vect.addElement( "1HOUR" );
	prop_1_vect.addElement( "2HOUR" );
	prop_1_vect.addElement( "3HOUR" );
	prop_1_vect.addElement( "4HOUR" );
	prop_1_vect.addElement( "5HOUR" );
	prop_1_vect.addElement( "6HOUR" );
	prop_1_vect.addElement( "7HOUR" );
	prop_1_vect.addElement( "8HOUR" );
	prop_1_vect.addElement( "9HOUR" );
	prop_1_vect.addElement( "10HOUR" );
	prop_1_vect.addElement( "11HOUR" );
	prop_1_vect.addElement( "12HOUR" );

	/*
	Vector prop_2_vect = new Vector();
	prop_2_vect.addElement( ".5 .4 .4 .3 .2 .1 0 .1 .2 .3 .4 .5 .7 .8 .9 1 1 .9 .9 .8 .8 .7 .6 .6");
	*/
	Vector prop_3_vect = new Vector();
	prop_3_vect.addElement( DEFAULT_STRING + " - FALSE" );
	prop_3_vect.addElement("TRUE");

	//jcomboboxes for properties
 	__props_1_mat_JComboBox =
	new SimpleJComboBox( prop_1_vect );

	/*
 	__props_2_mat_JComboBox =
	new SimpleJComboBox( prop_2_vect );
	*/
 	__props_2_mat_JTextField =
	new JTextField (".5 .4 .4 .3 .2 .1 0 .1 .2 .3 .4 .5 .7 .8 .9 1 1 .9 .9 .8 .8 .7 .6 .6");

 	__props_3_mat_JComboBox =
	new SimpleJComboBox( prop_3_vect );

	try {

		int x = 0;
		int y = 0;
		//all inputTS label
		JGUIUtil.addComponent(
		ts_panel, all_inputTS_JLabel,
		x, y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

		//all inputTS list
		JGUIUtil.addComponent(
		ts_panel, all_inputTS_JScrollPane,
		x, ++y, 1, 2, 1, 0, __insets,
		GridBagConstraints.BOTH,
		GridBagConstraints.WEST );

		//move right button
		JGUIUtil.addComponent(
		ts_panel, __move_inputTS_right_JButton,
		++x, ++y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.CENTER );

		--y;
		//label for selected time series
		JGUIUtil.addComponent(
		ts_panel, inputTS_JLabel,
		++x, --y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

		/*
		//List of selected time series
		JGUIUtil.addComponent(
		ts_panel, inputTS_JScrollPane,
		x, ++y, 1, 2, 1, 0, __insets,
		GridBagConstraints.BOTH,
		GridBagConstraints.EAST );
		*/
		//worksheet of selected time series
		JGUIUtil.addComponent(
		ts_panel, sel_inputTS_JScrollPane,
		x, ++y, 1, 2, 1, 0, __insets,
		GridBagConstraints.BOTH,
		GridBagConstraints.EAST );

		//button to delete a selected time series
		JGUIUtil.addComponent(
		ts_panel, __remove_selected_inputTS_JButton,
		++x, ++y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.EAST );

		//Insets insets = new Insets ( 15, 5, 10, 5 );
		x=0;
		++y;
		++y;
		JGUIUtil.addComponent(
		props_panel, prop_1_JLabel,
		x, ++y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.EAST );

		JGUIUtil.addComponent(
		props_panel, __props_1_mat_JComboBox,
		++x, y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

		JGUIUtil.addComponent(
		props_panel, prop_1_desc,
		++x, y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

		x=0;
		JGUIUtil.addComponent(
		props_panel, prop_2_JLabel,
		x, ++y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.EAST );

		JGUIUtil.addComponent(
		props_panel, __props_2_mat_JTextField,
		++x, y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

		JGUIUtil.addComponent(
		props_panel, prop_2_desc,
		++x, y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

		x=0;
		JGUIUtil.addComponent(
		props_panel, prop_3_JLabel,
		x, ++y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.EAST );

		JGUIUtil.addComponent(
		props_panel, __props_3_mat_JComboBox,
		++x, y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

		JGUIUtil.addComponent(
		props_panel, prop_3_desc,
		++x, y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

		//put 2 panels together in main panel
		JGUIUtil.addComponent(
		panel, ts_panel,
		0, 0, 1, 1, 1, 0, __insets,
		GridBagConstraints.BOTH,
		GridBagConstraints.CENTER );

		JGUIUtil.addComponent(
		panel, props_panel,
		0, 1, 1, 1, 1, 0, __insets,
		GridBagConstraints.BOTH,
		GridBagConstraints.CENTER );
	}
	catch ( Exception e) {
		Message.printWarning( 2, routine,
		"Error laying out the Input Time Series " +
		"panel for type: " + __proc_mat_str );
		Message.printWarning( 2, routine, e );
	}
	return panel;
} //end assemble_inputTS_MAT_panel

/**
Assembles panel to display Input Time Series for time series
type: powerfunc.
@return Assembled JPanel.
*/
protected JPanel assemble_inputTS_powerfunc_panel ( ) {
	String routine = __class + ".assemble_inputTS_powerfunc_panel";
	JPanel panel = new JPanel();
	panel.setLayout( new GridBagLayout() );

	JPanel ts_panel = new JPanel();
	ts_panel.setLayout( new GridBagLayout() );

	JPanel props_panel = new JPanel();
	props_panel.setLayout( new GridBagLayout() );

	//make border for all inputTS panels
	Border ts_titled_border=BorderFactory.createTitledBorder( __inputTS_JPanel_string );

	ts_panel.setBorder( ts_titled_border);

	//label for left list (list of all inputTS possiblities)
	JLabel all_inputTS_JLabel = new JLabel( __all_inputTS_JList_string + ":");
	all_inputTS_JLabel.setToolTipText("List of all available time series");
	//list of all possibilities
 	__all_inputTS_ListModel = new DefaultListModel();
 	__all_inputTS_JList = new JList(
 	__all_inputTS_ListModel );
 	__all_inputTS_JList.setVisibleRowCount(5);
 	__all_inputTS_JList.setSelectionMode(
	ListSelectionModel.MULTIPLE_INTERVAL_SELECTION );

	JScrollPane all_inputTS_JScrollPane = new JScrollPane(
 	__all_inputTS_JList);
	all_inputTS_JScrollPane.setVerticalScrollBarPolicy(
		JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
	all_inputTS_JScrollPane.setPreferredSize( __scroll_dim );
	all_inputTS_JScrollPane.setMinimumSize( __scroll_dim );

	//label for the selected inputTS
	JLabel inputTS_JLabel = new JLabel( __inputTS_JList_string + ":");
	inputTS_JLabel.setToolTipText("List of selected time series");
	//list for selected input TS
 	__sel_inputTS_ListModel = new DefaultListModel();
 	__sel_inputTS_JList = new JList(
 	__sel_inputTS_ListModel );
 	__sel_inputTS_JList.setVisibleRowCount(5);

	JScrollPane inputTS_JScrollPane = new JScrollPane(
 	__sel_inputTS_JList);
	inputTS_JScrollPane.setVerticalScrollBarPolicy(
		JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
	inputTS_JScrollPane.setPreferredSize( __scroll_dim );

	//button to move time series from the "all" list to the
	//"selected" list
 	__move_inputTS_right_JButton = new SimpleJButton(
 	__move_inputTS_right_JButton_string,
 	__move_inputTS_right_JButton_string, this );

	//button to remove a TS from the selected list
 	__remove_selected_inputTS_JButton = new SimpleJButton(
 	__remove_selected_inputTS_JButton_string,
 	__remove_selected_inputTS_JButton_string, this );

	try {
		int x = 0;
		int y = 0;
		//all inputTS label
		JGUIUtil.addComponent(
		ts_panel, all_inputTS_JLabel,
		x, y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

		//all inputTS list
		JGUIUtil.addComponent(
		ts_panel, all_inputTS_JScrollPane,
		x, ++y, 1, 2, 1, 0, __insets,
		GridBagConstraints.BOTH,
		GridBagConstraints.WEST );

		//move right button
		JGUIUtil.addComponent(
		ts_panel, __move_inputTS_right_JButton,
		++x, ++y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.CENTER );

		--y;
		//label for selected time series
		JGUIUtil.addComponent(
		ts_panel, inputTS_JLabel,
		++x, --y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

		//List of selected time series
		JGUIUtil.addComponent(
		ts_panel, inputTS_JScrollPane,
		x, ++y, 1, 2, 1, 0, __insets,
		GridBagConstraints.BOTH,
		GridBagConstraints.EAST );

		//button to delete a selected time series
		JGUIUtil.addComponent(
		ts_panel, __remove_selected_inputTS_JButton,
		++x, ++y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.EAST );

		//put 2 panels together in main panel
		JGUIUtil.addComponent(
		panel, ts_panel,
		0, 0, 1, 1, 1, 0, __insets,
		GridBagConstraints.BOTH,
		GridBagConstraints.CENTER );
	}
	catch ( Exception e) {
		Message.printWarning( 2, routine,
		"Error laying out the Input Time Series " +
		"panel for type: " + __proc_powerfunc_str );
		Message.printWarning( 2, routine, e );
	}
	return panel;
} //end assemble_inputTS_powerfunc_panel

/**
Assembles panel to display Input Time Series for time series
type: shapefile.
@return Assembled JPanel.
*/
protected JPanel assemble_inputTS_shapefile_panel ( ) {
	String routine = __class + ".assemble_inputTS_shapefile_panel";
	JPanel panel = new JPanel();
	panel.setLayout( new GridBagLayout() );

	JPanel ts_panel = new JPanel();
	ts_panel.setLayout( new GridBagLayout() );

	//make border for all inputTS panels
	Border ts_titled_border=
	BorderFactory.createTitledBorder( __inputTS_JPanel_string );

	//set panel title
	ts_panel.setBorder( ts_titled_border);

	//label for left list (list of all inputTS possiblities)
	JLabel all_inputTS_JLabel = new JLabel( __all_inputTS_JList_string + ":");
	all_inputTS_JLabel.setToolTipText("List of all available time series");

	//list of all possibilities
 	__all_inputTS_ListModel = new DefaultListModel();
 	__all_inputTS_JList = new JList(
 	__all_inputTS_ListModel );
 	__all_inputTS_JList.setVisibleRowCount(5);
 	__all_inputTS_JList.setSelectionMode(
	ListSelectionModel.MULTIPLE_INTERVAL_SELECTION );

	JScrollPane all_inputTS_JScrollPane = new JScrollPane(
 	__all_inputTS_JList);
	all_inputTS_JScrollPane.setVerticalScrollBarPolicy(
		JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
	all_inputTS_JScrollPane.setPreferredSize( __scroll_dim );
	all_inputTS_JScrollPane.setMinimumSize( __scroll_dim );

	//label for the selected inputTS
	JLabel inputTS_JLabel = new JLabel( __inputTS_JList_string + ":");
	inputTS_JLabel.setToolTipText("List of selected time series");
	//list for selected input TS
 	__sel_inputTS_ListModel = new DefaultListModel();
 	__sel_inputTS_JList = new JList(
 	__sel_inputTS_ListModel );
 	__sel_inputTS_JList.setVisibleRowCount(5);

	JScrollPane inputTS_JScrollPane = new JScrollPane(
 	__sel_inputTS_JList);
	inputTS_JScrollPane.setVerticalScrollBarPolicy(
		JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
	inputTS_JScrollPane.setPreferredSize( __scroll_dim );

	//button to move time series from the "all" list to the
	//"selected" list
 	__move_inputTS_right_JButton = new SimpleJButton(
 	__move_inputTS_right_JButton_string,
 	__move_inputTS_right_JButton_string, this );
	
	//button to remove a TS from the selected list
 	__remove_selected_inputTS_JButton = new SimpleJButton(
 	__remove_selected_inputTS_JButton_string,
 	__remove_selected_inputTS_JButton_string, this );
	
	try {

		int x = 0;
		int y = 0;
		//all inputTS label
		JGUIUtil.addComponent(
		ts_panel, all_inputTS_JLabel,
		x, y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

		//all inputTS list
		JGUIUtil.addComponent(
		ts_panel, all_inputTS_JScrollPane,
		x, ++y, 1, 2, 1, 0, __insets,
		GridBagConstraints.BOTH,
		GridBagConstraints.WEST );

		//move right button
		JGUIUtil.addComponent(
		ts_panel, __move_inputTS_right_JButton,
		++x, ++y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.CENTER );

		--y;
		//label for selected time series
		JGUIUtil.addComponent(
		ts_panel, inputTS_JLabel,
		++x, --y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

		//List of selected time series
		JGUIUtil.addComponent(
		ts_panel, inputTS_JScrollPane,
		x, ++y, 1, 2, 1, 0, __insets,
		GridBagConstraints.BOTH,
		GridBagConstraints.EAST );

		//button to delete a selected time series
		JGUIUtil.addComponent(
		ts_panel, __remove_selected_inputTS_JButton,
		++x, ++y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.EAST );

		//put 2 panels together in main panel
		JGUIUtil.addComponent(
		panel, ts_panel,
		0, 0, 1, 1, 1, 0, __insets,
		GridBagConstraints.BOTH,
		GridBagConstraints.CENTER );
	}
	catch ( Exception e) {
		Message.printWarning( 2, routine,
		"Error laying out the Input Time Series " +
		"panel for type: " + __proc_shapefile_str );
		Message.printWarning( 2, routine, e );
	}
	return panel;
} //end assemble_inputTS_shapefile_panel

/**
Assembles panel to display Input Time Series for time series
type: stagedischargerating.
@return Assembled JPanel.
*/
protected JPanel assemble_inputTS_stagedischargerating_panel ( ) {
	String routine = __class + ".assemble_inputTS_stagedischargerating_panel";
	JPanel panel = new JPanel();
	panel.setLayout( new GridBagLayout() );

	JPanel ts_panel = new JPanel();
	ts_panel.setLayout( new GridBagLayout() );

	JPanel props_panel = new JPanel();
	props_panel.setLayout( new GridBagLayout() );

	//make border for  inputTS panel and props panel
	Border ts_titled_border=
	BorderFactory.createTitledBorder( __inputTS_JPanel_string );

	//add titled border to panel
	ts_panel.setBorder( ts_titled_border);

	Border props_titled_border=
	BorderFactory.createTitledBorder( __props_JLabel_string );

	//add titled border to panel
	props_panel.setBorder( props_titled_border);

	//label for left list (list of all inputTS possiblities)
	JLabel all_inputTS_JLabel = new JLabel( __all_inputTS_JList_string + ":");
	all_inputTS_JLabel.setToolTipText("List of all available time series");

	//list of all possibilities
 	__all_inputTS_ListModel = new DefaultListModel();
 	__all_inputTS_JList = new JList(
 	__all_inputTS_ListModel );
 	__all_inputTS_JList.setVisibleRowCount(5);
 	__all_inputTS_JList.setSelectionMode(
	ListSelectionModel.MULTIPLE_INTERVAL_SELECTION );

	JScrollPane all_inputTS_JScrollPane = new JScrollPane(
 	__all_inputTS_JList);
	all_inputTS_JScrollPane.setVerticalScrollBarPolicy(
		JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
	all_inputTS_JScrollPane.setPreferredSize( __scroll_dim );
	all_inputTS_JScrollPane.setMinimumSize( __scroll_dim );

	//label for the selected inputTS
	JLabel inputTS_JLabel = new JLabel( __inputTS_JList_string + ":");
	inputTS_JLabel.setToolTipText("List of selected time series");
	//list for selected input TS
 	__sel_inputTS_ListModel = new DefaultListModel();
 	__sel_inputTS_JList = new JList(
 	__sel_inputTS_ListModel );
 	__sel_inputTS_JList.setVisibleRowCount(5);

	JScrollPane inputTS_JScrollPane = new JScrollPane(
 	__sel_inputTS_JList);
	inputTS_JScrollPane.setVerticalScrollBarPolicy(
		JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
	inputTS_JScrollPane.setPreferredSize( __scroll_dim );

	//button to move time series from the "all" list to the
	//"selected" list
 	__move_inputTS_right_JButton = new SimpleJButton(
 	__move_inputTS_right_JButton_string,
 	__move_inputTS_right_JButton_string, this );

	//button to remove a TS from the selected list
 	__remove_selected_inputTS_JButton = new SimpleJButton(
 	__remove_selected_inputTS_JButton_string,
 	__remove_selected_inputTS_JButton_string, this );

	//Labels for properties
	//"CONVERSION";
/* Obsolete	
	JLabel prop_1_JLabel = new JLabel(
 	__props_1_stagedischargerating_JLabel_string + ":" );
	JLabel prop_1_desc = new JLabel(
 	__props_1_stagedischargerating_desc );
	prop_1_JLabel.setToolTipText("Optional: Select conversion type." );
*/	
	//"MAX_ALERT_DATA_AGE";
	JLabel prop_2_JLabel = new JLabel(
 	__props_2_stagedischargerating_JLabel_string + ":" );
	JLabel prop_2_desc = new JLabel(
 	__props_2_stagedischargerating_desc );
	prop_2_JLabel.setToolTipText("Optional: Specify the interval that " +
	"will be searched for a value to carry forward when MISSING data "+
	"is encountered." );

	//"SAVE_TRANSFORMED_INPUT_TS";
	JLabel prop_3_JLabel = new JLabel(
 	__props_3_stagedischargerating_JLabel_string + ":" );
	JLabel prop_3_desc = new JLabel(
 	__props_3_stagedischargerating_desc );
	prop_3_JLabel.setToolTipText("<html>Optional: Save the intermediate " +
	"time series to the database<br>when an output time series is of " +
	"different interval than the input time series and a <br>CHANGEINT " +
	"reduction is (automatically) performed.</html>");

	//Vectors for properties
	Vector prop_1_vect = new Vector();
	prop_1_vect.addElement( "TO_DISCHARGE" );
	prop_1_vect.addElement( "TO_STAGE" );

	Vector prop_2_vect = new Vector();
	prop_2_vect.addElement( DEFAULT_STRING + " - 2DAY" );
	for ( int i=1;i<32; i++ ) {
		if ( i != 2 ) {
			prop_2_vect.addElement(i + "DAY" );
		}
	}

	Vector prop_3_vect = new Vector();
	prop_3_vect.addElement( DEFAULT_STRING + " - FALSE" );
	prop_3_vect.addElement( "TRUE" );

	//JComboBoxes for properties
 	__props_1_stagedischargerating_JComboBox =
	new SimpleJComboBox( prop_1_vect );
	//should not allow users to change from TO_DISCHARGE
 	JGUIUtil.setEnabled(__props_1_stagedischargerating_JComboBox, false );
	
 	__props_2_stagedischargerating_JComboBox =
	new SimpleJComboBox( prop_2_vect );

 	__props_3_stagedischargerating_JComboBox =
	new SimpleJComboBox( prop_3_vect );

	try {
		int x = 0;
		int y = 0;
		//all inputTS label
		JGUIUtil.addComponent(
		ts_panel, all_inputTS_JLabel,
		x, y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

		//all inputTS list
		JGUIUtil.addComponent(
		ts_panel, all_inputTS_JScrollPane,
		x, ++y, 1, 2, 1, 0, __insets,
		GridBagConstraints.BOTH,
		GridBagConstraints.WEST );

		//move right button
		JGUIUtil.addComponent(
		ts_panel, __move_inputTS_right_JButton,
		++x, ++y, 1, 1, 1, 0, __insets,
		//++x, --y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.CENTER );

		--y;
		//label for selected time series
		JGUIUtil.addComponent(
		ts_panel, inputTS_JLabel,
		++x, --y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

		//List of selected time series
		JGUIUtil.addComponent(
		ts_panel, inputTS_JScrollPane,
		x, ++y, 1, 2, 1, 0, __insets,
		GridBagConstraints.BOTH,
		GridBagConstraints.EAST );

		//button to delete a selected time series
		JGUIUtil.addComponent(
		ts_panel, __remove_selected_inputTS_JButton,
		//++x, --y, 1, 1, 1, 0, __insets,
		++x, ++y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.EAST );

		x=0;
		++y;
		++y;
/*Obsolete		
		JGUIUtil.addComponent(
		props_panel, prop_1_JLabel,
		x, ++y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.EAST );

		JGUIUtil.addComponent(
		props_panel, __props_1_stagedischargerating_JComboBox,
		++x, y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

		JGUIUtil.addComponent(
		props_panel, prop_1_desc,
		++x, y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );
*/
		x=0;
		JGUIUtil.addComponent(
		props_panel, prop_2_JLabel,
		x, ++y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.EAST );

		JGUIUtil.addComponent(
		props_panel, __props_2_stagedischargerating_JComboBox,
		++x, y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

		JGUIUtil.addComponent(
		props_panel, prop_2_desc,
		++x, y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

		x=0;
		JGUIUtil.addComponent(
		props_panel, prop_3_JLabel,
		x, ++y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.EAST );

		JGUIUtil.addComponent(
		props_panel, __props_3_stagedischargerating_JComboBox,
		++x, y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

		JGUIUtil.addComponent(
		props_panel, prop_3_desc,
		++x, y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

		//put 2 panels together in main panel
		JGUIUtil.addComponent(
		panel, ts_panel,
		0, 0, 1, 1, 1, 0, __insets,
		GridBagConstraints.BOTH,
		GridBagConstraints.CENTER );

		JGUIUtil.addComponent(
		panel, props_panel,
		0, 1, 1, 1, 1, 0, __insets,
		GridBagConstraints.BOTH,
		GridBagConstraints.CENTER );

	}
	catch ( Exception e) {
		Message.printWarning( 2, routine,
		"Error laying out the Input Time Series " +
		"panel for type: " + __proc_stagedischargerating_str );
		Message.printWarning( 2, routine, e );
	}
	return panel;
} //end assemble_inputTS_stagedischargerating_panel

/**
Assembles the top portion of the Reductions (process) JPanel that
contains:
<P><UL>
<LI>Processor ComboBox</LI>
<LI>Order ComboBox</LI>
<LI>Active ComboBox</LI>
</UL></P>
@return Assembled JPanel.
*/
protected JPanel assemble_top_panel ( ) {
	String routine = __class + ".assemble_top_panel";

	JPanel panel = new JPanel();
	panel.setLayout( new GridBagLayout() );

	//Processor label
	JLabel processor_JLabel = new JLabel( "Processor:" );
 	__processor_JTextField = new JTextField( 45 );
	processor_JLabel.setToolTipText("Processor type (uneditable)" );

	//trim description
	if ( __processor_type.length() + __processor_desc.length() > 50 ) {
 		__processor_desc = __processor_desc.substring(
		0, 50-( __processor_type.length()) ) + "...";
	}
 	JGUIUtil.setEnabled(__processor_JTextField, false );
 	__processor_JTextField.setText( __processor_type + " - " + __processor_desc );

	//Order JLabel
	JLabel order_JLabel = new JLabel( "Processing Order:");
	order_JLabel.setToolTipText("Select processing order" );
	//Order JComboBox
	Vector order_vect = new Vector();
	order_vect.addElement("1");
	order_vect.addElement("2");
	order_vect.addElement("3");
	order_vect.addElement("4");
	order_vect.addElement("5");
	order_vect.addElement("5");
	order_vect.addElement("6");
	order_vect.addElement("7");
	order_vect.addElement("8");
	order_vect.addElement("9");
	order_vect.addElement("10");
	order_vect.addElement("11");
	order_vect.addElement("12");
	order_vect.addElement("13");
	order_vect.addElement("14");
	order_vect.addElement("15");
	order_vect.addElement("16");
	order_vect.addElement("17");
	order_vect.addElement("18");
	order_vect.addElement("19");
	order_vect.addElement("20");
	order_vect.addElement("101");
	order_vect.addElement("103");
	order_vect.addElement("105");
	order_vect.addElement("201");
 	__order_JComboBox = new SimpleJComboBox( order_vect );

	//active Label
	JLabel active_JLabel = new JLabel( "Active:" );
	active_JLabel.setToolTipText("Select Y to perform processing" );
	//active JComboBox
	Vector active_vect = new Vector();
	active_vect.addElement( "Y - Perform Processing" );
	active_vect.addElement( "N - Do Not Perform Processing" );
 	__active_JComboBox = new SimpleJComboBox( active_vect );

	try {
		//ASSEMBLE GUI PANEL
		int y = 0;
		int x = 0;

		//Process label
		JGUIUtil.addComponent(
		panel, processor_JLabel,
		x, y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.EAST );

		//Process combobox
		JGUIUtil.addComponent(
		panel, __processor_JTextField,
		++x, y, 4, 1, 1, 0, __insets,
		GridBagConstraints.BOTH,
		GridBagConstraints.WEST );

		//Order label
		x=0;
		JGUIUtil.addComponent(
		panel, order_JLabel,
		x, ++y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.EAST );

		//Order combobox
		JGUIUtil.addComponent(
		panel, __order_JComboBox,
		++x, y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

		//Active label
		JGUIUtil.addComponent(
		panel, active_JLabel,
		++x, y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.EAST );

		//Active combobox
		JGUIUtil.addComponent(
		panel, __active_JComboBox,
		++x, y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );
		//GridBagConstraints.WEST );
	}
	catch ( Exception e ) {
		Message.printWarning( 2, routine,
		"Error laying out top portion of panel." );
		Message.printWarning( 2, routine, e);
	}

	//clean up
	order_vect = null;
	active_vect = null;

	return panel;
} //end assemble_top_panel

/**
Assembles the output time series JPanel that contains:
<P><UL>
<LI>JList of all available Ouput Time series</LI>
<LI>JTextField to emphasize and display the Selected Time Series</LI>
</UL></P>
@return Assembled JPanel
*/
protected JPanel assemble_outputTS_panel ( ) {
	String routine = __class + ".assemble_outputTS_panel";

	JPanel panel = new JPanel();
	panel.setLayout( new GridBagLayout() );

	//add titled border
	Border titled_border= BorderFactory.createTitledBorder("Output Time Series" );

	panel.setBorder( titled_border);

	//Selected output Time Series label
	JLabel outputTS_JLabel = new JLabel( "Selected Output Time Series:" ) ;
	outputTS_JLabel.setToolTipText("Output time series (uneditable)" );

	//Selected output Time Series TextField
 	__outputTS_JTextField = new JTextField( 30 );
 	__outputTS_JTextField.setEditable( false );
 	__outputTS_JTextField.setBackground( Color.lightGray );
	try {
		int x=0;
		int y=0;

		JGUIUtil.addComponent(
		panel, outputTS_JLabel,
		//++x, --y, 1, 1, 1, 0, __insets,
		x, y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );
		//GridBagConstraints.EAST );

		JGUIUtil.addComponent(
		panel, __outputTS_JTextField,
		x, ++y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );
		//GridBagConstraints.EAST );
	}
	catch ( Exception e) {
		Message.printWarning( 2, routine,
		"Error laying out the Output Time Series " +
		"panel." );
		Message.printWarning( 2, routine, e );
	}
	return panel;
} //end assemble_outputTS_panel


/**
This method simply goes through all the fields in the GUI and checks that 
each fields is: <ul> <li>filled in if it is a required field </li>
<li>contains valid values (for JTextFields, for example)</li>
</ul>If an invalid entry is encountered, the method displays a warning message,
indicating the fields with invalid values. (Prints one error message at the end indicating any fields that need to
be filled in before a save can occur.)
</ul>
@exception Exception thrown if a required filled does not
have a value.
*/
protected void checkRequiredInput() throws Exception {
	String routine = __class + ".checkRequiredInput";

	StringBuffer buffer = new StringBuffer();
	//nothing can be null except the "Selected" input time series
	//since everything else is in a drop-down list.
	
	//get input Time Series.
	Object[] arr_gui_inputTS = null;
	if ( __sel_inputTS_ListModel != null ) {
		arr_gui_inputTS= 
 		__sel_inputTS_ListModel.toArray();
	}
	else if( __weights_JWorksheet != null ) {
		
		// map and mat have weights so are in tables.
		Vector data_vect = __weights_JWorksheet.getAllData();
		if ( data_vect != null ) {
			arr_gui_inputTS = data_vect.toArray();
		}
	}
		
	if ( arr_gui_inputTS.length <= 0 ) {
		Message.printWarning( 1, routine, "Unable to update database " +
		"since there are no input time series.", this );
		buffer.append( "Unable to update database " +
		"since there are no input time series. \n" );
	}

	if ( buffer.length() >0 ) {
		buffer.append( "Please specify all required fields or cancel." );
		JOptionPane.showMessageDialog( this, 
		buffer.toString(), "Warning", JOptionPane.WARNING_MESSAGE);

		throw new Exception ( 
		"Please specify all required fields or cancel." );
	}
	buffer = null;

}//end checkRequieredInput

/**
This method does the following:<ul>
<li>calls <i>checkRequiredInput</i> which makes sure all the required fields in the GUI are filled out and have valid entries</li>
<li>calls <i>update_RiversideDB_objects</i> which is called to 
<b>create</b> and update the <i><b>__gui_RTi_MeasReduction</b></i> and 
<i> <b>__gui_RTi_MeasType</b></i> objects in memory, mark them dirty, 
and add messages to the <i>__dirty_vect</i> Vector.
</li>
<li>creates a confirmation message if the <i>__gui</i> versions are dirty, 
prompting the user to verify if they want to save their changes
(all the changes are listed out from the <i>__dirty_vect</i>)</li>
<li>updates the database by calling, <i>update_database</i></li>
<li>closes the GUI and destroys it</li>
</ul>
*/
public void closeGUI() {
	String routine = __class + ".closeGUI";

	boolean blnUpdated=true;
	//required fields
	try {
		checkRequiredInput();
	}
	catch ( Exception e ) {
		//then there was an error so do not 
		//update object in memory or in database.
		Message.printWarning( 2, routine, e );

		blnUpdated= false;
	}

	//update the object in memory
	if ( blnUpdated ) {
		try {
			update_RiversideDB_objects();
		}
		catch( Exception e ) {
			Message.printWarning( 2, routine, e );
			blnUpdated=false;
		}
	}

	if( blnUpdated)  {
		if(( __gui_RTi_MeasType.isDirty()) || 
 		__gui_RTi_MeasReduction.isDirty() )  {
			//prompt user if they want to save their
			//changes to the database.
			int x = 0;
			x = new ResponseJDialog ( this, "Save changes",
				"Save your changes before closing?", 
				ResponseJDialog.YES | ResponseJDialog.NO
				| ResponseJDialog.CANCEL).response();
	
			if ( x == ResponseJDialog.YES ) {
				//update database itself
				try {
					//update database itself
					update_database();
				}
				catch( Exception e ) {
					Message.printWarning( 2, routine, e );
					blnUpdated=false;
				}

				windowManagerClose();
			}
			else if ( x == ResponseJDialog.NO ) {
				windowManagerClose();
			}
		}
		else { //no changes, so just close.
			windowManagerClose();
		}
	}
	/*
	else {
		if ( blnUpdated ) {
			windowManagerClose();
		}
	}
	*/
}

/**
Finalizes and cleans up.
*/
protected void finalize() throws Throwable
{
 	__insets = null;
 	__dmi = null;
 	__close_JButton = null;
 	__cancel_JButton = null;
 	__apply_JButton = null;
 	
 	// Finalize the base RiversideDB_EditorBase_JFrame class
	super.finalize();
}

/**
Returns a vector containing the Reduction processes possible for
the time series (type) selected in the JTree.
@return Vector of processes
*/
protected Vector getProcessChoices() {
	String routine = __class + ".getProcessChoices";

	Vector proc_vect = new Vector();

	//get Time series type
	String sel_ts_type = null;
	TSIdent sel_tsident = null;
	try {
		sel_tsident =  new TSIdent( __preselected_TSID_string );
	}
	catch ( Exception e ) {
		Message.printWarning( 2, routine, e);
		sel_tsident = null;
	}
	if ( sel_tsident != null ) {
		sel_ts_type = sel_tsident.getType();
	}
	int ind = -999;
	ind = sel_ts_type.indexOf("-") ;
	if ( ind > 0 ) {
		sel_ts_type = (sel_ts_type.substring( 0, ind )).trim();
	}
	//get vector of ProcessType choices - the list
	//is limited by the type of timeseries choosen
	int size = 0;
	if ( __RTi_MeasReductionType_vect != null ) {
		size = __RTi_MeasReductionType_vect.size();
	}
	RiversideDB_MeasReductionType mrt = null;
	String desc= null;
	String mrtype= null;
	for ( int i=0; i<size; i++ ) {
		mrt = (RiversideDB_MeasReductionType) 
 		__RTi_MeasReductionType_vect.elementAt(i);
		if ( mrt == null ) {
			continue;
		}
		mrtype = mrt.getType();
		desc = mrt.getDescription();
		if ( mrtype.length() + desc.length() > 50 ) {
			desc = desc.substring(0, 50-mrtype.length()) + "...";
		}

		if (( mrtype.equalsIgnoreCase( "FILLREPEAT" ) ) ||
		( mrtype.equalsIgnoreCase("CHANGEINT" )) ) {
			proc_vect.addElement( 
			mrtype + " - " +desc );
		}
		else if ( mrtype.equalsIgnoreCase("ChangeDataType" )) {
			//add PTPX only
			if( sel_ts_type.equals( "PTPX") ) {
				proc_vect.addElement( 
				mrtype + " - " +desc );
			}
		}
		else if ( mrtype.equalsIgnoreCase("StageDischargeRating" ) ) {
			//add STG, SQIN, QIN, SSTG
			if( ( sel_ts_type.equalsIgnoreCase( "STG") ) ||
			( sel_ts_type.equalsIgnoreCase( "SQIN") ) ||
			( sel_ts_type.equalsIgnoreCase( "QIN") ) ||
			( sel_ts_type.equalsIgnoreCase( "SSTG") ) ) {
				proc_vect.addElement( 
				mrtype + " - " +desc );
			}
		}

		else if ( mrtype.equalsIgnoreCase( "MAP" ) ) {
			//MAP- types PTPX and MAP
			if(  sel_ts_type.equalsIgnoreCase( "PTPX") ) {
				proc_vect.addElement( 
				mrtype + " - " +desc );
			}
		}
		else if ( mrtype.equalsIgnoreCase( "MAT" ) ) {
			//MAT - types TAIN TAVG MAT
			if( ( sel_ts_type.equalsIgnoreCase( "TAIN") ) ||
			( sel_ts_type.equalsIgnoreCase( "TAVG") ) ){
				proc_vect.addElement( 
				mrtype + " - " +desc );
			}
		}
		else if ( mrtype.equalsIgnoreCase( "MAPX" ) ) {
			// MAPX - types MAPX and QPF
			if( ( sel_ts_type.equalsIgnoreCase( "MAPX") ) ||
			( sel_ts_type.equalsIgnoreCase( "QPF") ) ){
				proc_vect.addElement( 
				mrtype + " - " +desc );
			}
		}
		
		else if ( mrtype.equalsIgnoreCase( "SHAPEFILE" ) ) {
		// SHAPEFILE - types MAPX and QPF
			if( ( sel_ts_type.equalsIgnoreCase( "MAPX") ) ||
			( sel_ts_type.equalsIgnoreCase( "QPF") ) ){
				proc_vect.addElement( 
				mrtype + " - " +desc );
			}
		}
		
		else if ( mrtype.equalsIgnoreCase( "FILLFLOODMONITOR" ) ) {
			//FILLFloodMonitor - types SSTG, SQIN,
			//if( ( sel_ts_type.equalsIgnoreCase( "SSTG") ) ||
			//( sel_ts_type.equalsIgnoreCase( "SQIN") )  
			//( sel_ts_type.equalsIgnoreCase( "SQME") ) ||
			//( sel_ts_type.equalsIgnoreCase( "PELE") ) ||
			//( sel_ts_type.equalsIgnoreCase( "RQME") ) ) {}
			if ( sel_ts_type.equalsIgnoreCase( "FLOODMONITOR") ) {
				proc_vect.addElement( 
				mrtype + " - " +desc );
			}
		}
		mrt = null;
		desc = null;
	}//end for loop

	return proc_vect;
}//end getProcessChoices

/**
Returns a String containing the Description for the Reduction processes
passed in.
@return String with Description of MeasReductionType
*/
protected String getProcessorDescription( String proc_type ) {
	int size = 0;
	if ( __RTi_MeasReductionType_vect != null ) {
		size = __RTi_MeasReductionType_vect.size();
	}
	RiversideDB_MeasReductionType mrt = null;
	String desc= null;
	String type= null;
	for ( int i=0; i<size; i++ ) {
		mrt = (RiversideDB_MeasReductionType) 
 		__RTi_MeasReductionType_vect.elementAt(i);
		if ( mrt == null ) {
			continue;
		}
		type = mrt.getType();
		desc = mrt.getDescription();

		if ( type.equalsIgnoreCase( proc_type ) ) {
			//found the matching process, get its description
			if ( type.length() + desc.length() > 50 ) {
				desc = desc.substring(0, 
				50-(type.length()) ) + "...";
			}
			break;
		}
	}
	return desc;
}//end getProcessorDescription


/**
Method reads the properties for the MeasType object passed 
in and returns the properties in a Vector of Vectors in the
format of: item at (0)="Property Name" and at (1)="Property Value".
@param RiversideDB_MeasReduction object to get properties from.
@return Vector of vectors containing the properties for the
RiversideDB_MeasReduction object passed in. Format of Vector:
item at (0)="Property Name" and at (1)="Property Value".
*/
protected Vector getVectorOfProperties( RiversideDB_MeasReduction mr ) {
	String routine = __class + ".getVectorOfProperties";

	//get the properties string for the MeasReduction object
	//for comparison to the CURRENT values set in the GUI
	String tmp_props_str = null;
	tmp_props_str = mr.getProperties();
	if ( Message.isDebugOn ){
		Message.printDebug( 4, routine, "Property string for selected MeasReduction object is: \"" +
		tmp_props_str + "\"." );
	}
	//the Properties string is a list of properties, seperated by
	// ";" and consisting of PropertyName=PropertyValue pairs:
	//For ex: "Prop1=Value1; Prop2=Value2; Prop3=Value3"

	//make Vector of Vectors to hold the properties for 
	//the MeasReduction object -each item in the Vector is another
	//vector with PropertyName as element 0 and PropertyValue as element 1
	Vector all_props_vect = new Vector();
	Vector tmp_props_vect = null;
	if ( tmp_props_str != null ) {
		//break up string based on ";"s
		if ( tmp_props_str.indexOf( ";" ) > 0 ) {
			//break it up based on ";"
			tmp_props_vect = StringUtil.breakStringList(
			tmp_props_str, ";", StringUtil.DELIM_SKIP_BLANKS );
		}
		else {
			// Have just 1 property-- add it to vector as is.
			tmp_props_vect = new Vector();
			tmp_props_vect.addElement( tmp_props_str );
		}
	}
	else {
		// There are no properties set, so add an empty vector
	    tmp_props_vect = new Vector();
		tmp_props_vect.addElement( new Vector() );
	}

	// Have a vector containing Strings - each string in format : "Propertyname=PropertyValue"
	//Break this up further so that each string in turn is converted to its own vector where
	//vector.elementAt(0) = property name and vector.elmentAt(i) = property value.
	int tmp_num = 0;
	if ( tmp_props_vect != null ) {
		tmp_num = tmp_props_vect.size();
	}
	String str_with_eq = null;
	String str_name= null;
	String str_val= null;
	for ( int i=0; i<tmp_num; i++ )  {
		str_with_eq = ( String) tmp_props_vect.elementAt(i);
		//break this string up based on the equal sign
		int eq_ind = -999;
		eq_ind = str_with_eq.indexOf("=");
		if ( eq_ind > 0 ) {
			str_name = (str_with_eq.substring(0, eq_ind)).trim();
			str_val = (str_with_eq.substring(eq_ind+1)).trim();
		}
		//now make this a new vector
		Vector brokenup_vect = new Vector();
		brokenup_vect.addElement( str_name );
		brokenup_vect.addElement( str_val );
		//now add this vector to the all_props_vet
		all_props_vect.addElement( brokenup_vect );
	}
	return all_props_vect;
} //end getVectorOfProperties

/**
This method is called from the constructor to create and layout the
GUI components.  It calls the method: <i>create_main_panel</i>
which creates the GUI components and put them together in a 
<i>GridBagLayout</i>. It does not worry about setting correct values
in the components' fields, but just gets the components set up.  
The main components in the GUI consists of:
<ul><li>JPanel that contains general information pertinent to the MeasReduction 
object at the top of the GUI</li>
<li>a panel added at the bottom that includes the standard buttons for: 
<ul><li>apply</li><li>close</li><li>cancel</li></ul></li></ul>
At the end of <i>init_layout_gui</i>, a 
call to <i>update_gui_fields</i> is made which fills in all the 
fields of the GUI according to the MeasReduction object currently being 
worked with.
*/
private void init_layout_GUI( ) {
	String routine = __class + ".init_layout_GUI";

	//Create overall Main Panel
	JPanel main_panel = null;
	main_panel = new JPanel();
	main_panel.setLayout( new GridBagLayout() );

	JPanel top_panel = null;
	top_panel = assemble_top_panel();

	JPanel outputTS_panel = null;
	outputTS_panel = assemble_outputTS_panel();

	//now make the input Time Series panels... since there
	//are differnet versions of these for different processes
	//(map, mat, etc ) make a different one for each type.. Add
	//them all, setting only 1 visible at a time.

	if ( __processor_type.equalsIgnoreCase( __proc_changedatatype_str ) ) {
 		__inputTS_JPanel =
		assemble_inputTS_changedatatype_panel( );
	}

	else if ( __processor_type.equalsIgnoreCase( __proc_changeint_str ) ) {
 		__inputTS_JPanel =
		assemble_inputTS_changeint_panel();
	}

	else if ( __processor_type.equalsIgnoreCase( __proc_fillfloodmonitor_str ) ) {
 		__inputTS_JPanel =
		assemble_inputTS_fillfloodmonitor_panel( );
	}

	else if ( __processor_type.equalsIgnoreCase( __proc_fillrepeat_str ) ) {
 		__inputTS_JPanel =
		assemble_inputTS_fillrepeat_panel( );
	}

	else if ( __processor_type.equalsIgnoreCase( __proc_map_str ) ) {
 		__inputTS_JPanel =
		assemble_inputTS_map_panel( );
	}

	else if ( __processor_type.equalsIgnoreCase( __proc_mapx_str ) ) {
 		__inputTS_JPanel =
		assemble_inputTS_mapx_panel( );
	}

	else if ( __processor_type.equalsIgnoreCase( __proc_mat_str ) ) {
 		__inputTS_JPanel =
		assemble_inputTS_mat_panel( );
	}

	else if ( __processor_type.equalsIgnoreCase( __proc_shapefile_str ) ) {
 		__inputTS_JPanel =
		assemble_inputTS_shapefile_panel( );
	}

	else if ( __processor_type.equalsIgnoreCase( __proc_powerfunc_str ) ) {
 		__inputTS_JPanel =
		assemble_inputTS_powerfunc_panel( );
	}
	else if ( __processor_type.equalsIgnoreCase( 
 	__proc_stagedischargerating_str ) ) {
 		__inputTS_JPanel =
		assemble_inputTS_stagedischargerating_panel( );
	}

	//close panel
	JPanel close_JPanel = new JPanel();
	close_JPanel.setLayout( new GridBagLayout() );

 	__close_JButton = new SimpleJButton( "Close", this );
 	__cancel_JButton = new SimpleJButton( "Cancel", this );
 	__apply_JButton = new SimpleJButton( "Apply", this );

	JGUIUtil.addComponent( 
		close_JPanel, __apply_JButton,
		0, 0, 1, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.EAST );

	JGUIUtil.addComponent( 
		close_JPanel, __close_JButton,
		1, 0, 1, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.CENTER );
	JGUIUtil.addComponent( 
		close_JPanel, __cancel_JButton,
		2, 0, 1, 1, 0.0, 0.0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

	//Layout GUI
	try {
		int y =0;

		JGUIUtil.addComponent(
		main_panel, top_panel,
		0, y, 1, 1, 1, 0, __insets,
		GridBagConstraints.NONE,
		GridBagConstraints.WEST );

		JGUIUtil.addComponent(
		main_panel, outputTS_panel,
		0, ++y, 1, 1, 1, 0, __insets,
		GridBagConstraints.BOTH,
		GridBagConstraints.CENTER );

		//add in input panel
		JGUIUtil.addComponent(
		main_panel, __inputTS_JPanel,
		0, ++y, 1, 1, 1, 0, __insets,
		GridBagConstraints.BOTH,
		GridBagConstraints.CENTER );

		//add close Panel
		JGUIUtil.addComponent(
		main_panel, close_JPanel,
		0, ++y, 1, 1, 1, 0, __insets,
		GridBagConstraints.EAST,
		GridBagConstraints.CENTER );
	}
	catch ( Exception e ) {
		Message.printWarning( 2, routine,
			"Error laying out the Main portion of the "+
			"graphical display for Reduction Time Series.");
		Message.printWarning( 2, routine, e );
	}

	//NOW that the specific panels have
	//been created, fill in the values for all the FIELDS!
	update_GUI_fields();

	//pack and set visible
	getContentPane().add( "Center",	main_panel );
	pack();
	JGUIUtil.center(this );
	setVisible( true );

	//update widths of worksheets
	if ( __weights_worksheet_widths != null ) {
		if ( __weights_JWorksheet != null  ) {
 			__weights_JWorksheet.setColumnWidths(
 			__weights_worksheet_widths);
		}
		if ( __weights_JWorksheet != null  ) {
 			__weights_JWorksheet.setColumnWidths(
 			__weights_worksheet_widths);
		}
	}

} //end init_layout_GUI


/**
Method looks at the selected time series in the left list of
"all" timeseries and checks to see if it can be added
to the right list of "selected" time series, based on the 
criteria of the different reduction types.
Called by actionPerformed when "move_right" button pressed.
*/
protected void move_right() {
	String routine = __class + ".move_right";
	//get selected time series from the list of
	//all input time series and place it in the list of "Selected"
	Object[] selTS_to_move = 
 	__all_inputTS_JList.getSelectedValues();

	//go through each item selected to make sure it is not
	//already in the "Selected" list
	for ( int i=0; i< selTS_to_move.length; i++ ) {
		if ( (String) selTS_to_move[i] == null ) {
			continue;
		}
		//see if right "list" is JList or JWorksheet
		if( ( __sel_inputTS_JList != null ) && 
		( __sel_inputTS_ListModel.indexOf(
		(String) selTS_to_move[i]) >= 0 ) ) {
			//then it already exists, so don't add
			continue;
		}
		else if( ( __weights_JWorksheet != null ) && 
		( __weights_JWorksheet.getRowCount() > 0 ) &&
		( __weights_JWorksheet.find( 
		(String) selTS_to_move[i], 1, 0, 
		JWorksheet.FIND_EQUAL_TO ) >= 0 )  ) {

			//then it already exists, so don't add
			continue;
		}
		//now look at more details.

		//changedatatype- any ts can be added
		if( __processor_type.equalsIgnoreCase( __proc_changedatatype_str ) ) {
 			__sel_inputTS_ListModel.addElement(
			selTS_to_move[i] );
		}
		else if( __processor_type.equalsIgnoreCase( __proc_changeint_str ) ) {
			
			if ( ( __sel_inputTS_ListModel.size() > 0 ) ||
			( selTS_to_move.length > 1 ) )  {
				Message.printWarning( 1, routine, 
				"The \"ChangeInterval\" reduction " +
				"method can only have 1 input time series.", 
				this );
			}
			else {
				//make sure that DataType and location match.
				//If they do, we have to make sure that 
				//the Dimension matches too...

				String to_move_loc = null;
				String to_move_type = null;
				TSIdent to_move_tsid = null;
				String presel_ts_loc = null;
				String presel_ts_type = null;
				TSIdent presel_ts_tsid = null;
	
				//Make sure Time Series to move into the
				//right list has same TYPE and Location 
				//as Preselected time series
				try {
					to_move_tsid = new TSIdent(
					(String)selTS_to_move[i] );
				} 
				catch ( Exception e ) { 
					Message.printWarning( 2, routine, e); 
					to_move_tsid = null; 
				}
				if ( to_move_tsid != null ) {
					to_move_loc= to_move_tsid.getLocation();
					to_move_type= to_move_tsid.getType();
				}

				try {
					presel_ts_tsid = new TSIdent( 
 					__preselected_TSID_string );
				}
				catch ( Exception e ) {
					Message.printWarning( 2, routine, e);
					presel_ts_tsid = null;
				}
				if ( presel_ts_tsid != null ) {
					presel_ts_loc = presel_ts_tsid.
					getLocation();
					presel_ts_type = presel_ts_tsid.
					getType();
				}
				
				if ( !presel_ts_loc.equalsIgnoreCase( to_move_loc ) ) {
					Message.printWarning( 1, routine, 
					"The Input Time Series " +
					"must have the same location " +
					"(\"" + presel_ts_loc + "\") " +
					"as the output time series.", this );
					continue;
				}
				if ( !presel_ts_type.equalsIgnoreCase( to_move_type ) ) {
					Message.printWarning( 1, routine, 
					"The Input Time Series " +
					"must have the same data type " +
					"(\"" + presel_ts_type + "\") " + 
					"as the output time series.", this );
					continue;
				}

				//if all criteria have been met, 
				//move the ts over to the "Selected" list!
 				__sel_inputTS_ListModel.addElement(
				selTS_to_move[i] );
			}
		}
		else if( __processor_type.equalsIgnoreCase( 
 		__proc_fillfloodmonitor_str )) {
 			__sel_inputTS_ListModel.addElement(
			selTS_to_move[i] );
		}
		else if( __processor_type.equalsIgnoreCase( __proc_fillrepeat_str ) ){

			//first see if there is something in the right hand
			//list - if so, do not let them move anything because
			//there can only be 1 input Time Series
			if ( ( __sel_inputTS_ListModel.size() > 0 ) ||
			( selTS_to_move.length > 1 ) )  {
				Message.printWarning( 1, routine, 
				"The \"FillRepeat\" reduction " +
				"method can only have 1 input time series.", 
				this );
			}
			else {
 				__sel_inputTS_ListModel.addElement(
				selTS_to_move[i] );
			}
		}
		else if( __processor_type.equalsIgnoreCase( __proc_map_str ) ) {
			//MAP and MAT uses JWorksheet for list of selected TS

 			__weights_JWorksheet.addRow(
			new String[] { (String)selTS_to_move[i],
			"-999" } );
		}
		else if( __processor_type.equalsIgnoreCase( __proc_mapx_str ) ){
	
			//first see if there is something in the right hand
			//list - if so, do not let them move anything because
			//there can only be 1 input Time Series
			if ( ( __sel_inputTS_ListModel.size() > 0 ) ||
			( selTS_to_move.length > 1 ) )  {
				Message.printWarning( 1, routine, 
				"The \"MAPX\" reduction " +
				"method can only have 1 input time series.", 
				this );
			}
			else {
 				__sel_inputTS_ListModel.addElement(
				selTS_to_move[i] );
			}
		}
		else if( __processor_type.equalsIgnoreCase( __proc_mat_str ) ) {
			//MAP and MAT uses JWorksheet for list of selected TS

 			__weights_JWorksheet.addRow(
			new String[] { (String)selTS_to_move[i],
			"-999" } );
		}
		else if( __processor_type.equalsIgnoreCase( __proc_shapefile_str ) ) {

 			__sel_inputTS_ListModel.addElement( selTS_to_move[i] );
		}
		else if( __processor_type.equalsIgnoreCase( __proc_powerfunc_str ) ) {
 			__sel_inputTS_ListModel.addElement( selTS_to_move[i] );
		}
		else if( __processor_type.equalsIgnoreCase( 
 			__proc_stagedischargerating_str ) ) {
			//first see if there is something in the right hand
		//list 	- if so, do not let them move anything because
			//there can only be 1 input Time Series
			if ( ( __sel_inputTS_ListModel.size() > 0 ) || ( 
			selTS_to_move.length > 1 ) )  {
				Message.printWarning( 1, routine, 
				"The \"StageDischargeRating\" reduction " +
				"method can only have 1 input time series.", 
				this );
			}
			else {
 				__sel_inputTS_ListModel.addElement( selTS_to_move[i] );
			}
		}
	} //end loop
}//end move_right

/**
This method: <ul>
<li>makes a confirmation message to verify that the user wants to save the 
changes (and lists out all the changes from the <i>__dirty_vect</i>) <b>if</b>
a new MeasReduction was <b>not</b> created (if a new MeasReduction was created, 
we do not want to re-confirm every change)</li>
<li>writes the <i>__gui</i> version of the objects to the database</li>
<li>if the objects were successfully written to the database, the 
<i>__gui</i> objects are marked as <b>not</b> dirty 
( <i>setDirty(false)</i></li>
<li><i>__dirty_vect</i> is cleared out</li>
<li>if we created a new MeasReduction object (<i>__bln_new_object == true</i>),
update the node on the JTree in the main application to read (for create method)
"REDUCTION". </li> </ul>
@exception Exception thrown if error encountered.
*/
protected void update_database( ) throws Exception {
	String routine = __class + ".update_database";

	__dmi.setDumpSQLOnError( true );
	//holds messages from __dirty_vect
	StringBuffer b = new StringBuffer();
	for ( int i=0; i< __dirty_vect.size(); i++ ) {
		if ( i == ( __dirty_vect.size()-1) ) {
			b.append( (String) __dirty_vect.elementAt(i) );
		}
		else{
			b.append( (String) __dirty_vect.elementAt(i) + "\n" );
		}
	}

	//if we are running in cautious mode and if we 
	//are changing an already existing object ( not a completely new one),
	//then prompt the user before writing to the database
	if( ( __cautious_mode ) && ( ! __bln_new_object ) ) {
		if (( __gui_RTi_MeasType.isDirty()) || 
		( __gui_RTi_MeasReduction.isDirty() ) ) {

			//write out a confirmation message.
			int x = new ResponseJDialog( 
			this, "Confirm Changes to be saved to database", 
			"Confirm Changes:\n" +b.toString(),
			ResponseJDialog.YES | ResponseJDialog.NO ).
			response();
	
			if ( x == ResponseJDialog.YES ) {
				Message.printStatus( 1, routine, 
				"Saving changes to the database. ");
	
				//write to log file
				Message.printStatus( 5, routine, 
				"User confirmed changes: " +b.toString() ); 
	
			}	
			else {
				//write to log file
				Message.printStatus( 5, routine, 
				"User denied changes: " +b.toString() ); 
				//empty out dirty vector
 				__dirty_vect.clear();

				throw new Exception (
				"User choose not to write changes "+
				"back to database." );
			}
		}
	}

	//MeasType is dirty if we are changing a TS from 
	//UNKOWN create method to REDUCTION create-method
	if ( __gui_RTi_MeasType.isDirty() ) {
		if ( Message.isDebugOn ) {
			Message.printDebug( 2, routine,
			"Writing MeasType object to the database." );
		}
		try {
 			__dmi.writeMeasType( __gui_RTi_MeasType );
 			__gui_RTi_MeasType.setDirty( false );
		}
		catch ( Exception e ) {
			Message.printWarning( 2, routine, e );
			Message.printWarning( 2, routine,
			"Unable to write MeasType object " +
			"to the database.", this );

 			__gui_RTi_MeasType.setDirty( true );
		}

		//if MeasType was dirty, meant that the
		//create method was changed from UNKNOWN to 
		//REDUCTION -- update JTree to reflect this change.
 		updateReductionNode( __db_RTi_MeasType,
 				     __gui_RTi_MeasType );
	}
	else {
		Message.printStatus( 3, routine,
		"No changes were made to the MeasType object to update." );
	}

	if ( __gui_RTi_MeasReduction.isDirty() ) {
		if ( Message.isDebugOn ) {
			Message.printDebug( 2, routine,
			"Writing MeasReduction object to the database." );
		}
		try {
 			__dmi.writeMeasReduction( __gui_RTi_MeasReduction );
 			__gui_RTi_MeasReduction.setDirty( false );
		}
		catch ( Exception e ) {
			Message.printWarning( 2, routine, e );
			Message.printWarning( 1, routine,
			"Unable to write MeasReduction object " +
			"to the database.", this );

 			__gui_RTi_MeasReduction.setDirty( true );
		}
	}
	else {
		Message.printStatus( 3, routine,
		"No changes were made to the MeasReduction object to update." );
	}

	//Fill with MeasReducRelation table with  
	//items in the GUI_rti_MeasReducRelation_vect for the 
	//output MeasType that we are dealing with.
	int size = 0;
	if( __gui_RTi_MeasReducRelation_vect != null ) {
		size = __gui_RTi_MeasReducRelation_vect.size();
	}

	RiversideDB_MeasReducRelation mrr = null;
	for ( int i=0; i<size; i++ ) {
		mrr = (RiversideDB_MeasReducRelation )
 		__gui_RTi_MeasReducRelation_vect.elementAt(i);
		if ( mrr == null ) {
			continue;
		}
		if ( mrr.isDirty() ) {
			if ( Message.isDebugOn ) {
				Message.printDebug( 2, routine,
				"Writing MeasReducRelation objects "+
				"to the database." );
			}
			// do delete to delete all related items in there
			if ( ( i == 0 ) && ( __db_MeasType_num > 0 ) ){
				//Delete  all MeasReducRelation objects for the 
				// output MeasType that we are dealing with.
				int del = 0;
				try {
					del = __dmi.
					deleteMeasReducRelationForOutputMeasType_num(
 					__db_MeasType_num  );
				}
				catch ( Exception e ) {
					Message.printWarning( 2, 
					routine, e );
					throw new Exception ( 
					"Unable to delete " +
					"MeasReducRelation objects " +
					"from database" );
				}
				if ( Message.isDebugOn) {
					Message.printDebug( 2, 
					routine, "call to: " +
					"deleteMeasReducRelationForOutputMeasType_num(" +
 					__db_MeasType_num + 
					"), deleted: " + del + 
					" objects." );
				}
				
			}
			//write new items
			try {
 				__dmi.writeMeasReducRelation( mrr );
				mrr.setDirty( false );
			}
			catch ( Exception e ) {
				Message.printWarning( 2, routine, e );
				Message.printWarning( 2, routine, 
				"Unable to write new MeasReducRelation " +
				"objects to the database." );
			}
		}
	}

	//empty out dirty vector
 	__dirty_vect.clear();
	//update global vector
	try {
 		__db_RTi_MeasReducRelation_vect = __dmi.
		readMeasReducRelationListForOutputMeasType_num(
 		__db_MeasType_num );
		//_gui_RTi_MeasReducRelation_vect = __dmi.
		//readMeasReducRelationListForOutputMeasType_num(
		//_db_MeasType_num );
	}
	catch ( Exception e ) {
		Message.printWarning( 2, routine, e);
		Message.printWarning( 2, routine,
		"Unable to get list of MeasReducRelation Objects");
	}
	try {
		//get MeasReduction objects vector
 		//__RTi_MeasReduction_vect = __dmi.readMeasReductionList();
	}
	catch ( Exception e ) {
		Message.printWarning( 2, routine, e );
	}
} //end update_database

/**
This method:<ul>
<li><b>creates the <i>__gui</i> versions of the objects!</b> This includes: <ul><li>__gui_RTi_MeasReduction</li><li>__gui_RTi_MeasType</li></ul> The 
<i>__gui</i> versions are created in this method by copying the <i>__db</i> 
versions (which were originally created and set up in the constructor)</li>
<li>calls the <i>verify_xxx</i> methods. These include:<ul>
<li><i>verify_top_fields()</i></li>
<li><i>verify_inputTS_fields()</i></li>
<li><i>verify_outputTS_fields()</i></li>
The <i>verify_xxx</i> methods:<ul><li> fill in the <i>__gui</i> verions of the objects
in memory with the values that are currently set in the GUI</li>
<li>compares the values in the <i>__gui</i> version of the objects to the 
<i>__db</i> version of the objects.  If the <i>__gui</i> versions differ 
from the <i>__db</i> verions:<ul>
<li>the <i>__gui</i> versions are marked dirty (<i>.setDirty(true)</i>)</li>
<li>messages are added to the <i>__dirty_vect</i> indicating how the 
<i>__gui</i> differs from the <i>__db</i> version (the <i>__db</i> version 
remember, represents how the object is in the database itself) </li></ul>
</li></ul></ul>
@param Exception thrown if error encountered.
*/
protected void update_RiversideDB_objects() throws Exception {
	String routine = __class + ".update_RiversideDB_objects";

 	__gui_RTi_MeasType = new RiversideDB_MeasType( __db_RTi_MeasType );
 	__gui_RTi_MeasReduction = new RiversideDB_MeasReduction( 
 	__db_RTi_MeasReduction );

	int s = 0;
	if ( __db_RTi_MeasReducRelation_vect != null ){
		s = __db_RTi_MeasReducRelation_vect.size();
	}

	for ( int i=0; i<s; i++ ) {
 		__gui_RTi_MeasReducRelation_vect.addElement(
 		__db_RTi_MeasReducRelation_vect.elementAt(i) );
	}

	//get all fields from the TimeSeries GUI
	try {
		verify_top_fields();
	}
	catch ( Exception e ) {
		Message.printWarning( 2, routine, e);
		Message.printWarning( 2, routine,
		"Unable to validate top fields in MeasReduction GUI." );
		throw new Exception( 
		"Unable to validate top fields in MeasReduction GUI." );
	}

	//Since nothing is editable with the output time series,
	//do not need to check it.

	//verify inputTS fields
	try {
		verify_inputTS_fields();
	}
	catch ( Exception e ) {
		Message.printWarning( 2, routine, e);
		Message.printWarning( 2, routine,
		"Unable to validate input time series fields in " +
		"MeasReduction GUI." );
		throw new Exception(
		"Unable to validate input time series fields in " +
		"MeasReduction GUI." );
	}

} //end update_RiversideDB_objects

/**
This method: <ul><li>determines if the current user, already known to the DMI,
has write permissions.  If the user does not have write permissions, the 
<b>apply</b> and <b>close</b> buttons are disabled, leaving only the 
<b>cancel</b> button enabled.</li><li>Fills in all the GUI fields according
to the data in the MeasReduction (and related MeasType) objects.</li></ul>
*/
protected void update_GUI_fields( ) {
	String routine = __class + ".update_GUI_fields";

	//check to see which buttons are enabled
	if ( ! __canWriteMeasReduction ) {
 		JGUIUtil.setEnabled(__apply_JButton, false );
 		JGUIUtil.setEnabled(__close_JButton, false );
	}

	///////// TOP Panel /////////////
	//Processor does not change

	//get the order
	long order_long = -999;
	order_long = __db_RTi_MeasReduction.getCreate_order();
	try{
		JGUIUtil.selectTokenMatches(
 		__order_JComboBox, true, " - ", 0, 0,
		String.valueOf(order_long),"" );
	}
	catch ( Exception e ) {
		Message.printWarning( 50, routine, e );
	}

	//get the Active state
	String act_str = null;
	if ( __dmi.isDatabaseVersionAtLeast( RiversideDB_DMI._VERSION_030000_20041001) ) {
 		act_str = __db_RTi_MeasReduction.getIsActive();
	} else {
		act_str = __db_RTi_MeasReduction.getActive  ();	
	}
	try{
		JGUIUtil.selectTokenMatches(
 		__active_JComboBox, true, " - ", 0, 0,
		act_str,"" );
	}
	catch ( Exception e ) {
		Message.printWarning( 50, routine, e );
	}

	//update list of output time series-- list depends on
	//what TYPE of process is choses in the processor_JComboBox
	update_outputTS_panel();

	update_inputTS_panel();

} //end update_GUI_fields

/**
Updates the JList that holds all the input time series available.
*/
protected void update_inputTS_panel( ) {
	String routine = __class + ".update_inputTS_panel";

	//input time series list depends on what is selected
	//in the output TS list, and what type of processor
	//is being used.
	//String sel_outputTS_str = __outputTS_JTextField.getText();

	//We already have the MeasType object for the selected 
	//output time series ( __db_RTi_MeasType)
	//and  the MeasType_num for the selected output timeseries
	//( __db_MeasType_num)

	//vector holds the list of MeasType objects in the Selected list
	Vector inputTS_MeasType_vect = new Vector();
	int s = 0;
	if ( __db_RTi_MeasReducRelation_vect != null ) {
		s = __db_RTi_MeasReducRelation_vect.size();
	}
	//now go through and pull out input time series - (if we are adding 
	//a new Reduction node (AKA, changing from UNKOWN TO REDUCTION
	//Create_method), there will not be any items in the Vector 
	// __db_RTi_MeasReducRelation_vect)
	//Also pull out weights
	RiversideDB_MeasReducRelation mrr = null;
	//vector holds list of MeasTypeNums
	//Vector inputTS_measTypeNums_vect = new Vector();
	long out_mt_num = -999;
	long in_mt_num = -999;
	RiversideDB_MeasType rti_mt = null;
	double weight = -999;
	Vector worksheet_data_vect = new Vector();

	//go through vector of MeasReducRelation objects to pull out the
	//candidates for the inputTS_MeasType_vect Vector
	
	for ( int i=0; i<s; i++ ) {
		mrr = (RiversideDB_MeasReducRelation)
 		__db_RTi_MeasReducRelation_vect.elementAt(i);

		if ( mrr == null ) {
			continue;
		}
		//get Output and Input Time Series meastype nums
		out_mt_num = mrr.getOutputMeasType_num();

		//if the output time series number matches the
		//MeasType number for the Selected Time Series,
		//then we have found the matching MeasReducRelation Object
		//and can get its Input Time Series number
		if ( out_mt_num != __db_MeasType_num ) {
			//we didn't find a match, so continue looping
			continue;
		}
		//pull out the ImportMeasType_num
		in_mt_num = mrr.getInputMeasType_num();
		weight = mrr.getWeight();

		if ( Message.isDebugOn ) {
			Message.printDebug( 4, routine,
			"Going through Vector of " +
			"MeasReducRelation objects, " +
			"Output MeasType number (" + i + ") is: " +
			out_mt_num + " and matching Input " +
			"MeasType_num is: " + in_mt_num + 
			" and weight = " + weight );
		}
		if ( Message.isDebugOn ) {
			try{
				Message.printDebug( 5, routine,
				"MeasType for Output Time Series out_mt_num " + 
				out_mt_num + " is: " +
 				__dmi.readMeasTypeForMeasType_num(out_mt_num) );
				Message.printDebug( 5, routine,
				"MeasType for Input Time Series in_mt_num " + 
				out_mt_num + " is: " +
 				__dmi.readMeasTypeForMeasType_num(in_mt_num) );
			}
			catch( Exception e ) { 
				Message.printWarning(2,"",e); 
			}
		}
		
		//use input meastypeNum to get the measType object for the
		//INPUT time series
		try {
			rti_mt = __dmi.readMeasTypeForMeasType_num( in_mt_num);
		}
		catch ( Exception e ) {
			Message.printWarning( 2, routine, e);
		}
		if ( rti_mt == null ) {
			continue;
		}

		if ( ( __processor_type.equalsIgnoreCase ( __proc_map_str ) ) ||
		( __processor_type.equalsIgnoreCase ( __proc_mat_str ) ) ) {
			//then we need to get weights too
			//convert to TSIDENT just to send to jWorksheet
			TSIdent tsid= null; 
			try {
				tsid = rti_mt.toTSIdent();
			}
			catch( Exception e ){
				Message.printWarning( 2, routine, e );
			}
	
			double wt = -999;
			wt = mrr.getWeight();
	
			//add Vector with row data to worksheet Vector
			//worksheet_vect.addElement(v);
			String []arr = { tsid.toString(),
					String.valueOf(wt) };
			tsid = null;

			worksheet_data_vect.addElement( arr );
		}

		//add MeasType object to vector
		inputTS_MeasType_vect.addElement( rti_mt );
		mrr = null;
		rti_mt = null;
	}

	//get size of vector that contains Selected Input Time Series
	int input_size =0;
	if ( inputTS_MeasType_vect != null ) {
		input_size = inputTS_MeasType_vect.size();
	}

	//get the Properties for the selected MeasReduction Object
	Vector all_props_vect = null;
	all_props_vect = getVectorOfProperties( __db_RTi_MeasReduction );

	int props_size =0;
	if ( all_props_vect != null ) {
		props_size = all_props_vect.size();
	}
	if ( Message.isDebugOn ) {
		Message.printDebug( 3, routine, 
		"Number of total input time series to choose from is: " +
		input_size);
		Message.printDebug( 3, routine, 
		"Number of total properties for seleced MeasReduction object " +
		"is: " + props_size );
	}

	//make Vector of possible input TS, based on the process type
	Vector unsorted_v = new Vector();
	Vector sorted_v = null;
	if ( __processor_type.equalsIgnoreCase ( __proc_changedatatype_str ) ) {
		Vector all_RTi_MeasType_vect = new Vector();
		Vector v = null;
		//input TS: PTPA and PTPX with no IRREG
		try {
			v = __dmi.readMeasTypeListForData_type("PTPA");
		}
		catch ( Exception e ) {
			Message.printWarning( 2, routine, e);
		}
		//add vectors
		all_RTi_MeasType_vect = addVectors( v, all_RTi_MeasType_vect );
		v= null;
		try {
			v = __dmi.readMeasTypeListForData_type("PTPX");
		}
		catch ( Exception e ) {
			Message.printWarning( 2, routine, e);
		}
		//add vectors
		all_RTi_MeasType_vect = addVectors( v, all_RTi_MeasType_vect );
		v= null;

		int allTS_size = 0;
		if ( all_RTi_MeasType_vect != null ) {
			allTS_size = all_RTi_MeasType_vect.size();
		}

		RiversideDB_MeasType mt = null;
		TSIdent tsid = null;
		for (int i=0; i<allTS_size; i++ ) {
			mt = (RiversideDB_MeasType) all_RTi_MeasType_vect.
			elementAt(i);
			try {
				tsid = mt.toTSIdent();
			}
			catch ( Exception e) {
				Message.printWarning( 2, routine, e );
				tsid = null;
			}
			String tsid_str = null;
			if ( tsid == null ) {
				continue;
			}
			tsid_str = tsid.toString();
			tsid = null;
			if ( ! tsid_str.equalsIgnoreCase( __preselected_TSID_string ) ) {
				unsorted_v.addElement( tsid_str );
			}
			mt = null;
		}


		//Properties: update all comboBoxes to 
		//select the NONE option if there is one. 
 		__props_1_changedatatype_JComboBox.
		setSelectedItem( "FLASE" );
 		__props_2_changedatatype_JComboBox.
		setSelectedItem( "0" );
 		__props_3_changedatatype_JComboBox.
		setSelectedItem( "REGULAR" );
 		__props_4_changedatatype_JComboBox.
		setSelectedItem( "2DAY" );
 		__props_5_changedatatype_JComboBox.
		setSelectedItem( "FALSE" );

		//see if combobox 4 should be disabled 
		// if TimeSeries not have transmit protocol of 
		//Alert, disable
//MORGAN__ CHANGE THIS
//WHEN TRANSMIT PROT 
//MOVED FROM TS
		mt = null;
		try {
			mt = __dmi.readMeasTypeForMeasType_num( 
 			__db_MeasType_num );
		}
		catch ( Exception e ) {
			Message.printWarning( 2, routine, e);
		}
		String trans_str = null;
		if ( mt !=null ) {
			trans_str = mt.getTransmitProtocol();
			mt = null;
		}
		if ( !trans_str.equalsIgnoreCase( "ALERT") ) {
 			JGUIUtil.setEnabled(
			__props_4_changedatatype_JComboBox, false );
		}

		//go through vector of properties to see if it contains
		//any of the properties associated with 
		//changedatatype process
		String prop_str = null;
		String prop_value_str = null;
		v = null;
		for ( int i=0; i<props_size; i++ ) {
			v = (Vector) all_props_vect.elementAt(i);	
			prop_str = (String) v.elementAt(0);
			if ( prop_str == null ) {
				continue;
			}
			else if ( prop_str.equalsIgnoreCase( 
 				__props_1_changedatatype_JLabel_string ) ) {
				//then get its value to set in the
				//combobox/
				prop_value_str = (String)v.elementAt(1);
 				__props_1_changedatatype_JComboBox.
				setSelectedItem( prop_value_str );
			}
			else if ( prop_str.equalsIgnoreCase( 
 			__props_2_changedatatype_JLabel_string ) ) {
				//then get its value to set in the
				//combobox/
				prop_value_str = (String)v.elementAt(1);
 				__props_2_changedatatype_JComboBox.
				setSelectedItem( prop_value_str );

			}
			else if ( prop_str.equalsIgnoreCase( 
 			__props_3_changedatatype_JLabel_string ) ) {
				//then get its value to set in the
				//combobox/
				prop_value_str = (String)v.elementAt(1);
 				__props_3_changedatatype_JComboBox.
				setSelectedItem( prop_value_str );

			}
			else if ( prop_str.equalsIgnoreCase( 
 			__props_4_changedatatype_JLabel_string ) ) {
				prop_value_str = (String)v.elementAt(1);
 				__props_4_changedatatype_JComboBox.
				setSelectedItem( prop_value_str );
			}
			else if ( prop_str.equalsIgnoreCase( 
 			__props_5_changedatatype_JLabel_string ) ) {
				//then get its value to set in the
				//combobox/
				prop_value_str = (String)v.elementAt(1);
 				__props_5_changedatatype_JComboBox.
				setSelectedItem( prop_value_str );

			}
		}

	}
	else if ( __processor_type.equalsIgnoreCase ( __proc_changeint_str ) ) {
			
		//input TS: ALL TS, but the time series have to be 
		//of the Same Datatype and and same location as 
		//the selected timeseries (the output time series)
		TSIdent sel_tsid = null;
		String sel_type = null;
		String sel_loc = null;
		try {
			sel_tsid =  new TSIdent(
 			__preselected_TSID_string );
		}
		catch ( Exception e ) {
			Message.printWarning( 2, routine, e);
			sel_tsid = null;
		}
		if ( sel_tsid != null ) {
			sel_type = sel_tsid.getType();
			sel_loc = sel_tsid.getLocation();
		}

		//get LIst of ALL time series 
		Vector all_RTi_MeasType_vect = null;
		try {
			all_RTi_MeasType_vect =
 			__dmi.readMeasTypeList();
		}
		catch ( Exception e ) {
			Message.printWarning( 2, routine, e);
		}
		int allTS_size = 0;
		if ( all_RTi_MeasType_vect != null ) {
			allTS_size = all_RTi_MeasType_vect.size();
		}
		RiversideDB_MeasType mt = null;
		TSIdent tsid = null;
		for (int i=0; i<allTS_size; i++ ) {
			mt = (RiversideDB_MeasType)
			all_RTi_MeasType_vect.elementAt(i);
			if ( mt== null ) {
				continue;
			}
			//get TSIDENT
			try {
				tsid = mt.toTSIdent();
			}
			catch ( Exception e) {
				Message.printWarning( 2, routine, e );
				tsid = null;
			}
			if ( tsid == null ) {
				continue;
			}
			if (( tsid.getType().equalsIgnoreCase( sel_type) ) && 
			( tsid.getLocation().equalsIgnoreCase( sel_loc ) ) &&
			( ! (tsid.toString()).equalsIgnoreCase( 
 			__preselected_TSID_string ) ) ) {
				unsorted_v.addElement( tsid.toString() );
			}
			mt = null;
		}

		//update Properties
		//update all comboBoxes to select the NONE option if
		//there is one or to select the default option
 		__props_1_changeint_JComboBox.setSelectedItem( "FALSE" );
 		__props_2_changeint_JComboBox.setSelectedItem( "2DAY" );
 		//__props_3_changeint_JTextField.setText( "" );
 		//__props_4_changeint_JComboBox.setSelectedItem( xx );

		//see if combobox 2 should be disabled (MAX_ALERT) 
		// if TimeSeries not have transmit protocol of Alert, disable
//MORGAN__ CHANGE THIS
//WHEN TRANSMIT PROT 
//MOVED FROM TS
		mt = null;
		try {
			mt = __dmi.readMeasTypeForMeasType_num( 
 			__db_MeasType_num );
		}
		catch ( Exception e ) {
			Message.printWarning( 2, routine, e);
		}
		String trans_str = "";
		if ( mt !=null ) {
			trans_str = mt.getTransmitProtocol();
			mt = null;
		}
		if ( !trans_str.equalsIgnoreCase( "ALERT") ) {
 			JGUIUtil.setEnabled(__props_2_changeint_JComboBox, false );
		}

		//go through vector of properties to see if it contains
		//any of the properties associated with changedatatype process
		String prop_str = null;
		String prop_value_str = null;
		Vector v = null;
		for ( int i=0; i<props_size; i++ ) {
			v = (Vector) all_props_vect.elementAt(i);	
			prop_str = (String) v.elementAt(0);
			if ( prop_str == null ) {
				continue;
			}
			else if ( prop_str.equalsIgnoreCase( 
 			__props_1_changeint_JLabel_string ) ) {
				//then get its value to set in the
				//combobox/
				prop_value_str = (String)v.elementAt(1);

 				__props_1_changeint_JComboBox.
				setSelectedItem( prop_value_str );

			}
			else if ( prop_str.equalsIgnoreCase( 
 			__props_2_changeint_JLabel_string ) ) {
				prop_value_str = (String)v.elementAt(1);
 				__props_2_changeint_JComboBox.
				setSelectedItem( prop_value_str );
			}
/*OBSOLUTE		else if ( prop_str.equalsIgnoreCase( 
				__props_3_changeint_JLabel_string ) ) {
				prop_value_str = (String)v.elementAt(1);
 				__props_3_changeint_JTextField.
				setText( prop_value_str );
			}
*/
			else if ( prop_str.equalsIgnoreCase( 
 			__props_4_changeint_JLabel_string ) ) {
				prop_value_str = (String)v.elementAt(1);
 				__props_4_changeint_JComboBox.
				setSelectedItem( prop_value_str );
			}
		}
	}
	else if ( __processor_type.equalsIgnoreCase ( __proc_fillfloodmonitor_str ) ) {
		//now update list
		//input TS: SSTG,SQIN,SQME,RQME,PELE with no irreg

		//get LIst of ALL time series with the correct data types
		Vector all_RTi_MeasType_vect = new Vector();
		Vector v = null;
		try {
			v = __dmi.readMeasTypeListForData_type("SSTG");
		}
		catch ( Exception e ) {
			Message.printWarning( 2, routine, e);
		}
		//add to all_RTi_MeasType_vect
		addVectors( v, all_RTi_MeasType_vect );
		v= null;

		try {
			v = __dmi.readMeasTypeListForData_type("SQIN");
		}
		catch ( Exception e ) {
			Message.printWarning( 2, routine, e);
		}
		//add to all_RTi_MeasType_vect
		addVectors( v, all_RTi_MeasType_vect );

		try {
			v = __dmi.readMeasTypeListForData_type("SQME");
		}
		catch ( Exception e ) {
			Message.printWarning( 2, routine, e);
		}
		//add to all_RTi_MeasType_vect
		addVectors( v, all_RTi_MeasType_vect );

		v= null;
		try {
			v = __dmi.readMeasTypeListForData_type("RQME");
		}
		catch ( Exception e ) {
			Message.printWarning( 2, routine, e);
		}
		//add to all_RTi_MeasType_vect
		addVectors( v, all_RTi_MeasType_vect );
		v= null;

		try {
			v = __dmi.readMeasTypeListForData_type("PELE");
		}
		catch ( Exception e ) {
			Message.printWarning( 2, routine, e);
		}
		//add to all_RTi_MeasType_vect
		addVectors( v, all_RTi_MeasType_vect );
		v= null;

		try {
			v = __dmi.readMeasTypeListForData_type("FloodMonitor");
		}
		catch ( Exception e ) {
			Message.printWarning( 2, routine, e);
		}
		//add to all_RTi_MeasType_vect
		all_RTi_MeasType_vect = 
		addVectors( v, all_RTi_MeasType_vect );
		v= null;

		int allTS_size = 0;
		if ( all_RTi_MeasType_vect != null ) {
			allTS_size = all_RTi_MeasType_vect.size();
		}

		RiversideDB_MeasType mt = null;
		TSIdent tsid = null;
		for (int i=0; i<allTS_size; i++ ) {
			mt = (RiversideDB_MeasType) all_RTi_MeasType_vect.
			elementAt(i);

			try {
				tsid = mt.toTSIdent();
			}
			catch ( Exception e) {
				Message.printWarning( 2, routine, e );
				tsid = null;
			}
			String tsid_str = null;
			if ( tsid == null ) {
				continue;
			}
			tsid_str = tsid.toString();
			if ( ! tsid.getInterval().equalsIgnoreCase("IRREG")) {
				if ( ! tsid_str.equalsIgnoreCase( 
 				__preselected_TSID_string ) )  {
					unsorted_v.addElement( tsid_str );
				}
			}
			tsid = null;
		}

		//update Properties
		//update all comboBoxes to select the NONE option if
		//there is one or to select the default option
 		__props_1_fillfloodmonitor_JComboBox.setSelectedItem( 
		"SIMULATION.ZERO_QPF_SCENARIO" );

		//go through vector of properties to see if it contains
		//any of the properties associated with changedatatype process
		String prop_str = null;
		String prop_value_str = null;
		v = null;
		for ( int i=0; i<props_size; i++ ) {
			v = (Vector) all_props_vect.elementAt(i);	
			prop_str = (String) v.elementAt(0);
			if ( prop_str == null ) {
				continue;
			}
/*Obsolete		else if ( prop_str.equalsIgnoreCase( 
 			__props_1_fillfloodmonitor_JLabel_string ) ) {
				//then get its value to set in the
				//combobox/
				prop_value_str = (String)v.elementAt(1);

 				__props_1_fillfloodmonitor_JComboBox.
				setSelectedItem( prop_value_str );
				//set the selection in the JComboBox
			}
*/			
			else if ( prop_str.equalsIgnoreCase( 
 			__props_2_fillfloodmonitor_JLabel_string ) ) {
				//then get its value to set in the
				//combobox/
				prop_value_str = (String)v.elementAt(1);
				try{
					JGUIUtil.selectTokenMatches(
 					__props_2_fillfloodmonitor_JComboBox,
					true, " - ", 0, 0, prop_value_str, "" );
				}
				catch ( Exception e ) {
					Message.printWarning( 50, routine, e );
				}

			}
		}
	}
	else if ( __processor_type.equalsIgnoreCase ( __proc_fillrepeat_str ) ) {
		//list all time series.
		Vector all_RTi_MeasType_vect = null;
		try {
			all_RTi_MeasType_vect =
 			__dmi.readMeasTypeList();
		}
		catch ( Exception e ) {
			Message.printWarning( 2, routine, e);
		}
		int allTS_size = 0;
		if ( all_RTi_MeasType_vect != null ) {
			allTS_size = all_RTi_MeasType_vect.size();
		}

		RiversideDB_MeasType mt = null;
		TSIdent tsid = null;
		for (int i=0; i<allTS_size; i++ ) {
			mt = (RiversideDB_MeasType)
			 all_RTi_MeasType_vect.elementAt(i);
			if ( mt== null ) {
				continue;
			}
			try {
				tsid = mt.toTSIdent();
			}
			catch ( Exception e) {
				Message.printWarning( 2, routine, e );
				tsid = null;
			}
			String tsid_str = null;
			if ( tsid == null ) {
				continue;
			}
			tsid_str = tsid.toString();
			tsid = null;
			if ( ! tsid_str.equalsIgnoreCase( __preselected_TSID_string ) ) {
				unsorted_v.addElement( tsid_str );
			}
			mt = null;
		}
		//no properties for fillrepeat
	}
	else if ( __processor_type.equalsIgnoreCase ( __proc_map_str ) ) {
		//input TS:PTPX
		Vector all_RTi_MeasType_vect = new Vector();
		Vector v = null;
		try {
			v = __dmi.readMeasTypeListForData_type("PTPX");
		}
		catch ( Exception e ) {
			Message.printWarning( 2, routine, e);
		}
		all_RTi_MeasType_vect = addVectors( v, all_RTi_MeasType_vect );
		v= null;

		int allTS_size = 0;
		if ( all_RTi_MeasType_vect != null ) {
			allTS_size = all_RTi_MeasType_vect.size();
		}

 		__all_inputTS_ListModel.clear();
		//now update list
		RiversideDB_MeasType mt = null;
		TSIdent tsid = null;
		for (int i=0; i<allTS_size; i++ ) {
			mt = (RiversideDB_MeasType) all_RTi_MeasType_vect.
			elementAt(i);
			try {
				tsid = mt.toTSIdent();
			}
			catch ( Exception e) {
				Message.printWarning( 2, routine, e );
				tsid = null;
			}
			String tsid_str = null;
			if ( tsid == null ) {
				continue;
			}
			tsid_str = tsid.toString();

			if( (!tsid.getInterval().equalsIgnoreCase("IRREG") ) &&
			( ! tsid_str.equalsIgnoreCase( 
 			__preselected_TSID_string ) ) ) {
				unsorted_v.addElement( tsid_str );
			}
		}

		//update Properties
		//update all comboBoxes to select the NONE option if
		//there is one or to select the default option
 		//__props_1_map_JComboBox.setSelectedItem( "-999" );
 		__props_2_map_JComboBox.setSelectedItem( "TRUE" );

 		//false is default ... 
		//__props_3_map_JComboBox.setSelectedItem( "FALSE" );

		//go through vector of properties to see if it contains
		//any of the properties associated with changedatatype process
		String prop_str = null;
		String prop_value_str = null;
		v = null;
		for ( int i=0; i<props_size; i++ ) {
			v = (Vector) all_props_vect.elementAt(i);	
			prop_str = (String) v.elementAt(0);
			if ( prop_str == null ) {
				continue;
			}
			else if ( prop_str.equalsIgnoreCase( 
 			__props_1_map_JLabel_string ) ) {

				//then get its value to set in the combobox/
				prop_value_str = (String)v.elementAt(1);

 				__props_1_map_JComboBox.
				setSelectedItem( prop_value_str );

			}
			else if ( prop_str.equalsIgnoreCase( 
 			__props_2_map_JLabel_string ) ) {
				//then get its value to set in the combobox/
				prop_value_str = (String)v.elementAt(1);

 				__props_2_map_JComboBox.
				setSelectedItem( prop_value_str );
			}
			else if ( prop_str.equalsIgnoreCase( 
 			__props_3_map_JLabel_string ) ) {
				//then get its value to set in the combobox/
				prop_value_str = (String)v.elementAt(1);
				try{
					JGUIUtil.selectTokenMatches(
 					__props_3_map_JComboBox,
					true, " - ", 0, 0,
					prop_value_str, "" );
				}
				catch ( Exception e ) {
					Message.printWarning( 50, routine, e );
				}

			}
		}
	}
	else if ( __processor_type.equalsIgnoreCase ( __proc_mapx_str ) ) {

		//input TS: XMRG and MAPX
		Vector all_RTi_MeasType_vect = new Vector();
		
		Vector v = null;
		try {
			v = __dmi.readMeasTypeListForData_type("QPF");
		}
		catch ( Exception e ) {
			Message.printWarning( 2, routine, e);
		}
		all_RTi_MeasType_vect = addVectors( v, all_RTi_MeasType_vect );
		
		v = null;
		try {
			v = __dmi.readMeasTypeListForData_type("MAPX");
		}
		catch ( Exception e ) {
			Message.printWarning( 2, routine, e);
		}
		all_RTi_MeasType_vect = addVectors( v, all_RTi_MeasType_vect );
		
		v = null;
		int allTS_size = 0;
		if ( all_RTi_MeasType_vect != null ) {
			allTS_size = all_RTi_MeasType_vect.size();
		}
		
		// Get the Table Number tn from Table table for TSLookup
		RiversideDB_Tables rdb_t = null;
		try {
			 rdb_t = __dmi.readTablesForTable_name("TSLookup");
		} catch (Exception e) {
			;
		}
		long tn = rdb_t.getTable_num();
		
		// Get the interval ti from the input __db_RTi_MeasType
		TSIdent inputTSid = null;
		try {
			inputTSid = __db_RTi_MeasType.toTSIdent();
		} catch (Exception e) {
			;
		}
		String inputInterval = inputTSid.getInterval();

		RiversideDB_MeasType mt = null;
		TSIdent tsid = null;
		for (int i=0; i<allTS_size; i++ ) {
			mt = (RiversideDB_MeasType) all_RTi_MeasType_vect.elementAt(i);
			try {
				tsid = mt.toTSIdent();
			}
			catch ( Exception e) {
				Message.printWarning( 2, routine, e );
				tsid = null;
			}
			String tsid_str = null;
			if ( tsid == null ) {
				continue;
			}
			
			// Only add tsid_str to unsorted_v if mt->Table_num1 equals
			// tn and the interval ti matches
			long tableNum = mt.getTable_num1();
			
			tsid_str = tsid.toString();
			
			if ( !tsid_str.equalsIgnoreCase(__preselected_TSID_string)
 			    && tsid.getInterval().equalsIgnoreCase(inputInterval)
 			    && tableNum == tn ) {
				unsorted_v.addElement( tsid_str );
			}
			
			tsid = null;
		}

		//update Properties
		//update all comboBoxes to select the NONE option if
		//there is one or to select the default option
 		__props_1_mapx_JComboBox.setSelectedItem( "FALSE" );
 		//__props_2_mapx_JComboBox.setSelectedItem( "FALSE" );

		//go through vector of properties to see if it contains
		//any of the properties associated with changedatatype process
		String prop_str = null;
		String prop_value_str = null;
		v = null;
		for ( int i=0; i<props_size; i++ ) {
			v = (Vector) all_props_vect.elementAt(i);	
			prop_str = (String) v.elementAt(0);
			if ( prop_str == null ) {
				continue;
			}
			else if ( prop_str.equalsIgnoreCase( 
 			__props_1_mapx_JLabel_string ) ) {
				//then get its value to set in the
				//combobox/
				prop_value_str = (String)v.elementAt(1);
 				__props_1_mapx_JComboBox.
				setSelectedItem( prop_value_str );
			}
/*			else if ( prop_str.equalsIgnoreCase( 
 			__props_2_mapx_JLabel_string ) ) {
				//then get its value to set in the
				//combobox/
				prop_value_str = (String)v.elementAt(1);
				try{
					JGUIUtil.selectTokenMatches(
 					__props_2_mapx_JComboBox,
					true, " - ", 0, 0,
					prop_value_str, "" );
				}
				catch ( Exception e ) {
					Message.printWarning( 50, routine, e );
				}
			}
*/
		}
	}
	else if ( __processor_type.equalsIgnoreCase ( __proc_mat_str ) ) {
		Message.printStatus( 15, routine, 
		"Updating input time series for process " + 
 		__proc_mat_str );

		//clear list
 		__all_inputTS_ListModel.clear();
		//now update list

		//input TS:TAIN, TAVG, MAT
		//get LIst of ALL time series with the correct data types
		Vector all_RTi_MeasType_vect = new Vector();
		Vector v = null;
		try {
			v = __dmi.readMeasTypeListForData_type("TAIN");
		}
		catch ( Exception e ) {
			Message.printWarning( 2, routine, e);
		}
		//add to all_RTi_MeasType_vect
		all_RTi_MeasType_vect = addVectors( v, all_RTi_MeasType_vect );
		v= null;
		try {
			v = __dmi.readMeasTypeListForData_type("TAVG");
		}
		catch ( Exception e ) {
			Message.printWarning( 2, routine, e);
		}
		all_RTi_MeasType_vect = addVectors( v, all_RTi_MeasType_vect );
		v= null;

		//get size
		int allTS_size = 0;
		if ( all_RTi_MeasType_vect != null ) {
			allTS_size = all_RTi_MeasType_vect.size();
		}

		//clear list
 		__all_inputTS_ListModel.clear();
		//now update list
		RiversideDB_MeasType mt = null;
		TSIdent tsid = null;
		for (int i=0; i<allTS_size; i++ ) {
			mt = (RiversideDB_MeasType) all_RTi_MeasType_vect.
			elementAt(i);
			try {
				tsid = mt.toTSIdent();
			}
			catch ( Exception e) {
				Message.printWarning( 2, routine, e );
				tsid = null;
			}
			String tsid_str = null;
			if ( tsid == null ) {
				continue;
			}
			tsid_str = tsid.toString();

			if( (!tsid.getInterval().equalsIgnoreCase("IRREG") ) &&
			( ! tsid_str.equalsIgnoreCase( 
 			__preselected_TSID_string ) ) ) {
				unsorted_v.addElement( tsid_str );
			}
		}

		//update Properties
		//update all comboBoxes to select the NONE option if
		//there is one or to select the default option
 		__props_1_mat_JComboBox.setSelectedItem( "1DAY" );
 		//__props_2_mat_JComboBox.setSelectedItem( "0.5" );
 		//__props_3_mat_JComboBox.setSelectedItem( "0.5" );

		//go through vector of properties to see if it contains
		//any of the properties associated with changedatatype process
		String prop_str = null;
		String prop_value_str = null;
		v = null;
		for ( int i=0; i<props_size; i++ ) {
			v = (Vector) all_props_vect.elementAt(i);	
			prop_str = (String) v.elementAt(0);
			if ( prop_str == null ) {
				continue;
			}
			else if ( prop_str.equalsIgnoreCase( 
 			__props_1_mat_JLabel_string ) ) {
				//then get its value to set in the
				//combobox/
				prop_value_str = (String)v.elementAt(1);
 				__props_1_mat_JComboBox.
				setSelectedItem( prop_value_str );
			}
			if ( prop_str.equalsIgnoreCase( 
 			__props_2_mat_JLabel_string ) ) {
				//then get its value to set in the
				//combobox/
				prop_value_str = (String)v.elementAt(1);
 				__props_2_mat_JTextField.
				setText( prop_value_str );
				//setSelectedItem( prop_value_str );
			}
			if ( prop_str.equalsIgnoreCase( 
 			__props_3_mat_JLabel_string ) ) {
				prop_value_str = (String)v.elementAt(1);
				try{
					JGUIUtil.selectTokenMatches(
 					__props_3_mat_JComboBox,
					true, " - ", 0, 0,
					prop_value_str, "" );
				}
				catch ( Exception e ) {
					Message.printWarning( 50, routine, e );
				}
			}
		}
	}
	
	else if ( __processor_type.equalsIgnoreCase ( __proc_shapefile_str ) ) {
		
		//input TS: XMRG and MAPX
		Vector all_RTi_MeasType_vect = new Vector();
		
		Vector v = null;
		try {
			v = __dmi.readMeasTypeListForData_type("QPF");
		}
		catch ( Exception e ) {
			Message.printWarning( 2, routine, e);
		}
		all_RTi_MeasType_vect = addVectors( v, all_RTi_MeasType_vect );
		
		v = null;
		try {
			v = __dmi.readMeasTypeListForData_type("MAPX");
		}
		catch ( Exception e ) {
			Message.printWarning( 2, routine, e);
		}
		all_RTi_MeasType_vect = addVectors( v, all_RTi_MeasType_vect );
		
		v = null;
		int allTS_size = 0;
		if ( all_RTi_MeasType_vect != null ) {
			allTS_size = all_RTi_MeasType_vect.size();
		}
		
		// Get the Table Number tn from Table table for TSLookup
		RiversideDB_Tables rdb_t = null;
		try {
			 rdb_t = __dmi.readTablesForTable_name("TSLookup");
		} catch (Exception e) {
			;
		}
		long tn = rdb_t.getTable_num();
		
		// Get the interval ti from the input __db_RTi_MeasType
		TSIdent inputTSid = null;
		try {
			inputTSid = __db_RTi_MeasType.toTSIdent();
		} catch (Exception e) {
			;
		}
		String inputInterval = inputTSid.getInterval();

		RiversideDB_MeasType mt = null;
		TSIdent tsid = null;
		for (int i=0; i<allTS_size; i++ ) {
			mt = (RiversideDB_MeasType) all_RTi_MeasType_vect.elementAt(i);
			try {
				tsid = mt.toTSIdent();
			}
			catch ( Exception e) {
				Message.printWarning( 2, routine, e );
				tsid = null;
			}
			String tsid_str = null;
			if ( tsid == null ) {
				continue;
			}
			
			// Only add tsid_str to unsorted_v if mt->Table_num1 equals
			// tn and the interval ti matches
			long tableNum = mt.getTable_num1();
			
			tsid_str = tsid.toString();
			
			if ( !tsid_str.equalsIgnoreCase(__preselected_TSID_string)
 			    && tsid.getInterval().equalsIgnoreCase(inputInterval)
 			    && tableNum == tn ) {
				unsorted_v.addElement( tsid_str );
			}
			
			Message.printWarning( 2, routine, "Input interval "
			  +  inputInterval + "  table num = " + tableNum );
			
			
			tsid = null;
		}		
	}
	
	else if ( __processor_type.equalsIgnoreCase ( __proc_powerfunc_str ) ) {
		//to implement
	}
	
	else if ( __processor_type.equalsIgnoreCase (
 	__proc_stagedischargerating_str ) ) {

		//input TS: STG,SQIN, SSTG, QIN
		Vector all_RTi_MeasType_vect = new Vector();
		Vector v = null;
		try {
			v = __dmi.readMeasTypeListForData_type("STG");
		}
		catch ( Exception e ) {
			Message.printWarning( 2, routine, e);
		}
		//add to all_RTi_MeasType_vect
		all_RTi_MeasType_vect = addVectors( v, all_RTi_MeasType_vect );
		v= null;
		try {
			v = __dmi.readMeasTypeListForData_type("SSTG");
		}
		catch ( Exception e ) {
			Message.printWarning( 2, routine, e);
		}
		//add to all_RTi_MeasType_vect
		all_RTi_MeasType_vect = addVectors( v, all_RTi_MeasType_vect );
		v= null;

		try {
			v = __dmi.readMeasTypeListForData_type("SQIN");
		}
		catch ( Exception e ) {
			Message.printWarning( 2, routine, e);
		}
		//add to all_RTi_MeasType_vect
		all_RTi_MeasType_vect = addVectors( v, all_RTi_MeasType_vect );
		v= null;

		try {
			v = __dmi.readMeasTypeListForData_type("QIN");
		}
		catch ( Exception e ) {
			Message.printWarning( 2, routine, e);
		}
		//add to all_RTi_MeasType_vect
		all_RTi_MeasType_vect = addVectors( v, all_RTi_MeasType_vect );
		v= null;

		//get size
		int allTS_size = 0;
		if ( all_RTi_MeasType_vect != null ) {
			allTS_size = all_RTi_MeasType_vect.size();
		}

		RiversideDB_MeasType mt = null;
		TSIdent tsid = null;
		//clear list
 		__all_inputTS_ListModel.clear();
		//now update list
		for (int i=0; i<allTS_size; i++ ) {
			mt = (RiversideDB_MeasType) 
			all_RTi_MeasType_vect.elementAt(i);

			try {
				tsid = mt.toTSIdent();
			}
			catch ( Exception e) {
				Message.printWarning( 2, routine, e );
				tsid = null;
			}
			String tsid_str = null;
			if ( tsid == null ) {
				continue;
			}
			tsid_str = tsid.toString();
			tsid = null;
			//add to vector
			if ( ! tsid_str.equalsIgnoreCase( 
 			__preselected_TSID_string ) ) {
				unsorted_v.addElement( tsid_str);
			}
		}

		//update Properties
		//required fields... no default value to pre-select
		//see if combobox 2 should be disabled 
		// if TimeSeries not have transmit protocol of Alert, disable
//MORGAN__ CHANGE THIS
//WHEN TRANSMIT PROT 
//MOVED FROM TS
		mt = null;
		try {
			mt = __dmi.readMeasTypeForMeasType_num( 
 			__db_MeasType_num );
		}
		catch ( Exception e ) {
			Message.printWarning( 2, routine, e);
		}
		String trans_str = null;
		if ( mt !=null ) {
			trans_str = mt.getTransmitProtocol();
			mt = null;
		}
		if ( !trans_str.equalsIgnoreCase( "ALERT") ) {
 		JGUIUtil.setEnabled(
		__props_2_stagedischargerating_JComboBox, false );
		}

		//go through vector of properties to see if it contains
		//any of the properties associated with changedatatype process
		String prop_str = null;
		String prop_value_str = null;
		v = null;
		for ( int i=0; i<props_size; i++ ) {
			v = (Vector) all_props_vect.elementAt(i);	
			prop_str = (String) v.elementAt(0);
			if ( prop_str == null ) {
				continue;
			}
/*Obsolete		else if ( prop_str.equalsIgnoreCase( 
 			__props_1_stagedischargerating_JLabel_string ) ) {
				//then get its value to set in the
				//combobox/
				prop_value_str = (String)v.elementAt(1);
 				__props_1_stagedischargerating_JComboBox.
				setSelectedItem( prop_value_str );
			}
*/			
			else if ( prop_str.equalsIgnoreCase( 
 			__props_2_stagedischargerating_JLabel_string ) ) {
				prop_value_str = (String)v.elementAt(1);
 				__props_2_stagedischargerating_JComboBox.
				setSelectedItem( prop_value_str );
			}

			else if ( prop_str.equalsIgnoreCase( 
 			__props_3_stagedischargerating_JLabel_string ) ) {
				//then get its value to set in the
				//combobox/
				prop_value_str = (String)v.elementAt(1);
 				__props_3_stagedischargerating_JComboBox.
				setSelectedItem( prop_value_str );
				//set the selection in the JComboBox
			}
		}
	}

//AMl
	//
	Message.printStatus( 15, routine, 
	"Updating input time series for process " + __processor_type );
	//Now we have an unsorted vector of all input TS possibilities...
	//sort the vector of All possible input TS
	if ( unsorted_v.size() > 0 ) {
		sorted_v = StringUtil.sortStringList( unsorted_v,
		StringUtil.SORT_ASCENDING, null, false, true );
	}
	else {
		sorted_v = new Vector();
	}

	unsorted_v = null;
	int allTS_size = 0;
	if ( sorted_v != null ) {	
		allTS_size = sorted_v.size();
	}
	
	//clear "ALL TS" Jlist
 	__all_inputTS_ListModel.clear();

	//update "ALL TS" JList
	for ( int i=0; i<allTS_size; i++ ) {
 		__all_inputTS_ListModel.
		addElement( sorted_v.elementAt(i) );
	}

	//if the right-hand "selected" list is a JList
	if ( __sel_inputTS_JList != null ) {
		//clear list "Selected" Time Series
 		__sel_inputTS_ListModel.clear();

		//update the selected Input Time Series List
		RiversideDB_MeasType mt = null;
		TSIdent tsid = null;
		String tsid_str = null;
		for ( int i=0; i<input_size; i++ ) {
			mt = (	RiversideDB_MeasType )
			inputTS_MeasType_vect.elementAt(i);
			//now get TSIdent from this and add to list
			try {
				tsid = mt.toTSIdent();
			}
			catch ( Exception e) {
				Message.printWarning( 2, routine, e );
				tsid = null;
			}
			tsid_str = null;
			if ( tsid == null ) {
				continue;
			}
			tsid_str = tsid.toString();
			tsid = null;
 			__sel_inputTS_ListModel.
			addElement( tsid_str );

			//also, select it in in the list of 
			//all timeseries
 			__all_inputTS_JList.setSelectedValue(
			tsid_str, true );

			mt = null;
		}
		
	}
	//else right-hand "selected ts" list is a JWorksheet
	else if ( __weights_JWorksheet != null ) {

		//clear (right-hand) worksheet of selected ts
		//_sel_inputTS_ListModel.clear();
 		__weights_JWorksheet.clear();
		
		//update the selected Input Time Series List
		for ( int i=0; i<input_size; i++ ) {
			//to update worksheet, we need not only the
			//tsid, but also the weight. To get weight,
			//get MeasReducRelation object...

			//update worksheet
 			__weights_JWorksheet.addRow( (String[])
			worksheet_data_vect.elementAt(i) );

		}

	}

	//if nothing is selected in the list of "ALL TS",
	//then we are creating a new Reduction.
	//Try to select the output TS.
	int[] arr_selTS;
	arr_selTS= __all_inputTS_JList.getSelectedIndices();
	if ( arr_selTS.length <= 0 ) {
		//try and select outputTS
 		__all_inputTS_JList.
		setSelectedValue( __preselected_TSID_string, true );
	}

	inputTS_MeasType_vect = null;

} //end update_inputTS_panel

/**
Updates the JList that holds all the output time series
available.
*/
protected void update_outputTS_panel( ) {
	String routine = __class + ".update_outputTS_panel";

	//get time series we are working on and place its 
	//name in the output JTExtField
	TSIdent tsident = null;

	try {
		tsident = new TSIdent( __preselected_TSID_string );
	}
	catch ( Exception e ) {
		Message.printWarning( 2, routine, e);
		tsident = null;
	}

	//clean out the JTextField before re-filling it
 	__outputTS_JTextField.setText("");

	if ( tsident != null ) {
 		__outputTS_JTextField.setText( tsident.toString() );
	}

} //end update_outputTS_panel()


/**
Verifies and stores all the information in the top of interface.
The method <ul><li> fills in the <i>__gui</i> verions of the objects
in memory with the values that are currently set in the GUI</li>
<li>compares the values in the <i>__gui</i> version of the objects to the 
<i>__db</i> version of the objects.  If the <i>__gui</i> versions differ 
from the <i>__db</i> verions:<ul>
<li>the <i>__gui</i> versions are marked dirty (<i>.setDirty(true)</i>)</li>
<li>messages are added to the <i>__dirty_vect</i> indicating how the 
<i>__gui</i> differs from the <i>__db</i> version (the <i>__db</i> version 
remember, represents how the object is in the database itself) </li></ul>
</li></ul></ul>
@exception Exception thrown if error encountered
*/
public void verify_top_fields() throws Exception {

	try {
	//Processor field can't be changed.
	String db_process =null;
	db_process =( __db_RTi_MeasReduction.getMethod()).toUpperCase();

	//compare to original to see if it matches
	//what is currently in the database for this TS.
	if ( ! db_process.equalsIgnoreCase( __processor_type ) ) {
		//then update object and set dirty
		 __gui_RTi_MeasReduction.setDirty(true);
 		__dirty_vect.addElement(
		"Change Process from \"" + db_process + "\" to \"" +
 		__processor_type + "\"");

 		__gui_RTi_MeasReduction.setMethod( __processor_type );
	}

	//Order ComboBox
	String gui_order_str = null;
	long gui_order = -999;
	long db_order = -999;
	db_order = __db_RTi_MeasReduction.getCreate_order();

	gui_order_str = ((String) __order_JComboBox.getSelected()).trim();
	//change to an int
	if ( StringUtil.isInteger( gui_order_str ) ) {
		gui_order = StringUtil.atol( gui_order_str );
	}

	//compare to original
	if ( db_order != gui_order ) {
		//then update object and set dirty
 		__gui_RTi_MeasReduction.setDirty(true);
 		__dirty_vect.addElement(
		"Change Processing Order from \"" + db_order + "\" to \"" +
		gui_order + "\"");

 		__gui_RTi_MeasReduction.setCreate_order(
		gui_order );
	}


	String gui_act = null;
	gui_act = (String) __active_JComboBox.getSelected();
	String db_act = null;
	if ( __dmi.isDatabaseVersionAtLeast(RiversideDB_DMI._VERSION_030000_20041001) ) {
 		db_act = __db_RTi_MeasReduction.getIsActive().toUpperCase();
	} else {
		db_act = __db_RTi_MeasReduction.getActive().toUpperCase();	
	}

	//remove description if it has one
	int ind =-999;
	ind = gui_act.indexOf("-");
	if ( ind > 0 ) {
		gui_act = (gui_act.substring( 0, ind )).trim();
	}

	//compare to original to see if it matches
	if ( ! db_act.equalsIgnoreCase( gui_act ) ){
		//then update object and set dirty
 		__gui_RTi_MeasReduction.setDirty(true);
 		__dirty_vect.addElement(
		"Change Active (Y/N) from \"" + db_act + 
		"\" to \"" + gui_act + "\"");
		if ( __dmi.isDatabaseVersionAtLeast(RiversideDB_DMI._VERSION_030000_20041001) ) {
 			__gui_RTi_MeasReduction.setIsActive( gui_act );
		} else {	
			__gui_RTi_MeasReduction.setActive  ( gui_act );
		}
	}

	}
	catch (Exception e ) {
		throw new Exception ("Unable to validate top " +
		"fields in MeasReduction GUI." );
	}

} //end verify_top_fields

/**
Verifies and stores all the information in the OUTPUT TS panel of the interface.
The method <ul><li> fills in the <i>__gui</i> verions of the objects
in memory with the values that are currently set in the GUI</li>
<li>compares the values in the <i>__gui</i> version of the objects to the 
<i>__db</i> version of the objects.  If the <i>__gui</i> versions differ 
from the <i>__db</i> verions:<ul>
<li>the <i>__gui</i> versions are marked dirty (<i>.setDirty(true)</i>)</li>
<li>messages are added to the <i>__dirty_vect</i> indicating how the 
<i>__gui</i> differs from the <i>__db</i> version (the <i>__db</i> version 
remember, represents how the object is in the database itself) </li></ul>
</li></ul></ul>
@exception Exception if error occurs when validating the output 
time series field.
*/
public void verify_outputTS_fields() throws Exception {
	//SHOULD not need to check this... it is uneditable.
	//outputTS_str = __outputTS_JTextField.getText();

} //end verify_outputTS_fields

/**
Verifies and stores all the information in the INPUT TS panel of the interface,
specifically, information regarding the input time series and their
weights.  The method <ul><li> fills in the <i>__gui</i> verions of the objects
in memory with the values that are currently set in the GUI</li>
<li>compares the values in the <i>__gui</i> version of the objects to the 
<i>__db</i> version of the objects.  If the <i>__gui</i> versions differ 
from the <i>__db</i> verions:<ul>
<li>the <i>__gui</i> versions are marked dirty (<i>.setDirty(true)</i>)</li>
<li>messages are added to the <i>__dirty_vect</i> indicating how the 
<i>__gui</i> differs from the <i>__db</i> version (the <i>__db</i> version 
remember, represents how the object is in the database itself) </li></ul>
</li></ul></ul>
@exception Exception if error occurs when validating the update 
time series objects.
*/
public void verify_inputTS_fields() throws Exception {
	String routine = __class + ".verify_inputTS_fields";
 
	Vector gui_inputTS_vect = new Vector();
	Vector gui_weight_vect = new Vector();

	//what we need to check for changes between the
	//object state in the database vs. the current 
	//state represented in the GUI are:
	//1)the input time series 
	//2)properties
	//the properties are checked as we go through the inputTS panel...
	//the input Time Series are checked at the end, after having 
	//gone through the inputTS panel.

	//inputTS- get list of inputTS and compare to original list.
	//based on the process, we know what inputTS list to look at.

	//holds the current list of the inputTS associated with
	//the MeasReduction object 
	Vector db_inputTS_tsid_vect = new Vector();
	Vector db_inputTS_weight_vect = new Vector();

	Vector db_inputTS_MeasType_vect = new Vector();
	int s = 0;
	if ( __db_RTi_MeasReducRelation_vect != null ) {
		s = __db_RTi_MeasReducRelation_vect.size();
	}
	//the size of the MeasReducRelation_vect could be 0 
	//(if we are creating a new Reduction, it will be 0)

	//now go through and pull out input time series
	RiversideDB_MeasReducRelation mrr = null;
	//vector holds list of MeasTypeNums
	long mt_num = -999;
	RiversideDB_MeasType mt = null;
	for ( int i=0; i<s; i++ ) {
		mrr = (RiversideDB_MeasReducRelation)
 		__db_RTi_MeasReducRelation_vect.elementAt(i);
		if ( mrr == null ) {
			continue;
		}
		//get Input Time Series meastype nums
		mt_num = mrr.getInputMeasType_num();
		//use meastypeNum to get the measType object
		try {
			mt = __dmi.readMeasTypeForMeasType_num( mt_num);
		}
		catch ( Exception e ) {
			Message.printWarning( 2, routine, e);
		}
		if ( mt == null ) {
			continue;
		}
		//add TSID from MeasType object to vector
		db_inputTS_MeasType_vect.addElement( mt );
		//if using MAP or MAT, then WEIGHT field is used

		if ( ( __processor_type.equalsIgnoreCase(
 		__proc_map_str ) )  || ( __processor_type.equalsIgnoreCase(
 		__proc_mat_str ) ) ) {
			//add weight (in same order)
			db_inputTS_weight_vect.addElement( String.valueOf(
			mrr.getWeight()) );
		}
		TSIdent tsid = null;
		try {
			tsid = mt.toTSIdent();
		}
		catch ( Exception e) {
			Message.printWarning( 2, routine, e );
			tsid = null;
		}
		String tsid_str = null;
		if ( tsid != null ) {
			tsid_str = tsid.toString();
		}
		tsid = null;
		db_inputTS_tsid_vect.addElement( tsid_str );

		mrr = null;
		mt = null;
	}

	//get size of vector that contains Selected Input Time Series
	//int db_inputTS_size =0;
	//if ( db_inputTS_tsid_vect != null ) {
	//	db_inputTS_size = db_inputTS_tsid_vect.size();
	//}

	//holds the input Time series selected in the GUI
	Object[] arr_gui_inputTS = null;
	// the items in this array get transferred to the
	//global variable: gui_inputTS_vect
	//to compare to the original list of inputTS for the object.
	 
	//clean out the old gui_inputTS_vect so can fill it
	//with any new data from the "Selected" input Time Series list.
	gui_inputTS_vect.clear();

	//PROPERTIES
	String gui_props_str =null;

	//CHANGEDATATYPE
	//String inputTS_type = null;
	if ( __processor_type.equalsIgnoreCase(
 	__proc_changedatatype_str ) ) {
		//what we need to check for changes between the
		//object state in the database vs. the current 
		//state represented in the GUI are:
		//1)the input time series 
		//2)properties

		Message.printStatus(1, routine,
		"Verifying MeasReduction Properties for " + 
 		__proc_changedatatype_str + " process." );

		//inputTS_type = __proc_changedatatype_str;

		//Input Time Series in the "selected" list in GUI
		arr_gui_inputTS=
 		__sel_inputTS_ListModel.toArray();

		if ( arr_gui_inputTS.length <= 0 ) {
			Message.printWarning( 1, routine, 
			"Unable to update database " +
			"since there are no input time series.", this );
			throw new Exception ( "Unable to update database " +
			"since there are no input time series." );
		}

		for ( int i=0; i<arr_gui_inputTS.length; i++ ) {
			gui_inputTS_vect.addElement(
			arr_gui_inputTS[i] );

		}
		if ( Message.isDebugOn ) {
			Message.printDebug( 4, routine,
			"Items in the list of selected input time series: " +
			gui_inputTS_vect.toString() );
		}

		//get properties
		
		String gui_prop_1 = null;
		gui_prop_1 = (String) __props_1_changedatatype_JComboBox.
		getSelected();
		//trim off the description if there is one
		int ind = -999;
		ind = gui_prop_1.indexOf("-");
		if ( ind > 0 ) {
			gui_prop_1= (gui_prop_1.substring( 0, ind)).trim();
		}
		if ( Message.isDebugOn ) {
			Message.printDebug( 3, routine,
			"prop_1 for " + __proc_changedatatype_str +
			" is: \"" + gui_prop_1 + "\"." );
		}

		String gui_prop_2 = null;
		gui_prop_2 = (String) __props_2_changedatatype_JComboBox.
		getSelected();
		//trim off the description if there is one
		ind = -999;
		ind = gui_prop_2.indexOf("-");
		if ( ind > 0 ) {
			gui_prop_2= (gui_prop_2.substring( 0, ind)).trim();
		}
		if ( Message.isDebugOn ) {
			Message.printDebug( 3, routine,
			"prop_2 for " + __proc_changedatatype_str +
			" is: \"" + gui_prop_2 + "\"." );
		}

		String gui_prop_3 = null;
		gui_prop_3 = (String) __props_3_changedatatype_JComboBox.
		getSelected();
		//trim off the description if there is one
		ind = -999;
		ind = gui_prop_3.indexOf("-");
		if ( ind > 0 ) {
			gui_prop_3= (gui_prop_3.substring( 0, ind)).trim();
		}
		if ( Message.isDebugOn ) {
			Message.printDebug( 3, routine,
			"prop_3 for " + __proc_changedatatype_str +
			" is: \"" + gui_prop_3 + "\"." );
		}

		String gui_prop_4 = null;
		gui_prop_4 = (String) __props_4_changedatatype_JComboBox.
		getSelected();
		//trim off the description if there is one
		ind = -999;
		ind = gui_prop_4.indexOf("-");
		if ( ind > 0 ) {
			gui_prop_4= (gui_prop_4.substring( 0, ind)).trim();
		}
		if ( Message.isDebugOn ) {
			Message.printDebug( 3, routine,
			"prop_4 for " + __proc_changedatatype_str +
			" is: \"" + gui_prop_4 + "\"." );
		}

		String gui_prop_5 = null;
		gui_prop_5 = (String) __props_5_changedatatype_JComboBox.
		getSelected();
		//trim off the description if there is one
		ind = -999;
		ind = gui_prop_5.indexOf("-");
		if ( ind > 0 ) {
			gui_prop_5= (gui_prop_5.substring( 0, ind)).trim();
		}
		if ( Message.isDebugOn ) {
			Message.printDebug( 3, routine,
			"prop_5 for " + __proc_changedatatype_str +
			" is: \"" + gui_prop_5 + "\"." );
		}

		//assemble current properties string
		gui_props_str =null;
		if ( ! gui_prop_1.startsWith( DEFAULT_STRING ) ) {
			gui_props_str = 
 			__props_1_changedatatype_JLabel_string + 
			"="+ gui_prop_1;
		}
		if ( ! gui_prop_2.startsWith( DEFAULT_STRING ) ) {
			if ( gui_props_str != null  ) {
				gui_props_str = gui_props_str + ";" +
 				__props_2_changedatatype_JLabel_string + 
				"=" + gui_prop_2;
			}
			else {
				gui_props_str =
 				__props_2_changedatatype_JLabel_string + 
				"=" + gui_prop_2;
			}
		}
		if ( ! gui_prop_3.startsWith( DEFAULT_STRING ) ) {
			if ( gui_props_str != null  ) {
				gui_props_str = gui_props_str + ";" +
 				__props_3_changedatatype_JLabel_string + 
				"=" + gui_prop_3;
			}
			else {
				gui_props_str =
 				__props_3_changedatatype_JLabel_string + 
				"=" + gui_prop_3;
			}

		}
		if ( ! gui_prop_4.startsWith( DEFAULT_STRING ) ) {
			if ( gui_props_str != null  ) {
				gui_props_str = gui_props_str + ";" +
 				__props_4_changedatatype_JLabel_string + 
				"=" + gui_prop_4;
			}
			else {
				gui_props_str = 
 				__props_4_changedatatype_JLabel_string + 
				"=" + gui_prop_4;
			}

		}
		if ( ! gui_prop_5.startsWith( DEFAULT_STRING ) ) {
			if ( gui_props_str != null  ) {
				gui_props_str = gui_props_str + ";" +
 				__props_5_changedatatype_JLabel_string + 
				"=" + gui_prop_5;
			} 
			else {
				gui_props_str =
 				__props_5_changedatatype_JLabel_string + 
				"=" + gui_prop_5;
			} 

		}
	} //end changedatatype

	//CHANGEINT
	else if ( __processor_type.equalsIgnoreCase(
 	__proc_changeint_str ) ) {

		Message.printStatus(1, routine,
		"Verifying MeasReduction Properties for " + 
 		__proc_changeint_str + " process." );

		//inputTS_type = __proc_changeint_str;

		arr_gui_inputTS=
 		__sel_inputTS_ListModel.toArray();

		if ( arr_gui_inputTS.length <= 0 ) {
			Message.printWarning( 1, routine, 
			"Unable to update database " +
			"since there are no input time series.", this );
			throw new Exception ("Unable to update database " +
			"since there are no input time series." );
		}
		for ( int i=0; i<arr_gui_inputTS.length; i++ ) {
			 gui_inputTS_vect.addElement(
			arr_gui_inputTS[i] );
		}

		if ( Message.isDebugOn ) {
			Message.printDebug( 4, routine,
			"Items in the list of selected input time series: " +
			gui_inputTS_vect.toString() );
		}

		//get properties
		
		String gui_prop_1 = null;
		gui_prop_1 = (String) __props_1_changeint_JComboBox.
		getSelected();
		//trim off the description if there is one
		int ind = -999;
		ind = gui_prop_1.indexOf("-");
		if ( ind > 0 ) {
			gui_prop_1= (gui_prop_1.substring( 0, ind)).trim();
		}
		//set global
		//_selected_props_1_changeint_JComboBox_string = prop_1;
		if ( Message.isDebugOn ) {
			Message.printDebug( 3, routine,
			"prop_1 for " + __proc_changeint_str +
			" is: \"" + gui_prop_1 + "\"." );
		}

		String gui_prop_2 = null;
		gui_prop_2 = (String) __props_2_changeint_JComboBox.
		getSelected();
		//trim off the description if there is one
		ind = -999;
		ind = gui_prop_2.indexOf("-");
		if ( ind > 0 ) {
			gui_prop_2= (gui_prop_2.substring( 0, ind)).trim();
		}
		if ( Message.isDebugOn ) {
			Message.printDebug( 3, routine,
			"prop_2 for " + __proc_changeint_str +
			" is: \"" + gui_prop_2 + "\"." );
		}

		//NEWDATATYPE
		String gui_prop_3 = null;
		gui_prop_3 = (String) (__props_3_changeint_JTextField.
		getText().trim());
		if ( gui_prop_3.length() <= 0 ) {
			gui_prop_3 = null;
		}

		//MAXMISSINGPERCENT
		String gui_prop_4 = null;
		gui_prop_4 = (String) __props_4_changeint_JComboBox.
		getSelected();
		if ( gui_prop_4.equalsIgnoreCase( "0" ) ) {
			gui_prop_4 = null;
		}

		//assemble current properties string
		gui_props_str =null;
		if ( ! gui_prop_1.startsWith( DEFAULT_STRING ) ) {
			gui_props_str = 
 			__props_1_changeint_JLabel_string + 
			"="+ gui_prop_1;
		}
		if ( ! gui_prop_2.startsWith( DEFAULT_STRING ) ) {
			if ( gui_props_str != null ) {
				gui_props_str = gui_props_str + ";" +
 				__props_2_changeint_JLabel_string + 
				"=" + gui_prop_2;
			}
			else {
				gui_props_str =
 				__props_2_changeint_JLabel_string + 
				"=" + gui_prop_2;
			}
		}
/*OBSOLETE	if ( gui_prop_3 != null ) {
			if ( gui_props_str == null ) {
				gui_props_str = 
 				__props_3_changeint_JLabel_string + 
				"=" + gui_prop_3;
			}
			else {
				gui_props_str = gui_props_str + ";" +
 				__props_3_changeint_JLabel_string + 
				"=" + gui_prop_3;
			}
		}
*/
		if ( gui_prop_4 != null ) {
			if ( gui_props_str == null ) {
				gui_props_str = 
 				__props_4_changeint_JLabel_string + 
				"=" + gui_prop_4;
			}
			else {
				gui_props_str = gui_props_str + ";" +
 				__props_4_changeint_JLabel_string + 
				"=" + gui_prop_4;
			}
		}

	} //end changeint

	//FILLFLOODMONITOR
	else if ( __processor_type.equalsIgnoreCase(
 	__proc_fillfloodmonitor_str ) ) {

		Message.printStatus(1, routine,
		"Verifying MeasReduction Properties for " + 
 		__proc_fillfloodmonitor_str + " process." );

		//inputTS_type = __proc_fillfloodmonitor_str;
		arr_gui_inputTS=__sel_inputTS_ListModel.toArray();

		if ( arr_gui_inputTS.length <= 0 ) {
			Message.printWarning( 1, routine, 
			"Unable to update database " +
			"since there are no input time series.", this );
			throw new Exception ("Unable to update database " +
			"since there are no input time series." );
		}
		for ( int i=0; i<arr_gui_inputTS.length; i++ ) {
			gui_inputTS_vect.addElement(
			arr_gui_inputTS[i] );
		}
		if ( Message.isDebugOn ) {
			Message.printDebug( 4, routine,
			"Items in the list of selected input time series: " +
			gui_inputTS_vect.toString() );
		}

		//get properties
		
		String gui_prop_1 = null;
		gui_prop_1 = (String) __props_1_fillfloodmonitor_JComboBox.
		getSelected();

		//trim off the description if there is one
		int ind = -999;
		ind = gui_prop_1.indexOf("-");
		if ( ind > 0 ) {
			gui_prop_1= (gui_prop_1.substring( 0, ind)).trim();
		}
		if ( Message.isDebugOn ) {
			Message.printDebug( 3, routine,
			"prop_1 for " + __proc_fillfloodmonitor_str +
			" is: \"" + gui_prop_1 + "\"." );
		}

		String gui_prop_2 = null;
		gui_prop_2 = (String) __props_2_fillfloodmonitor_JComboBox.
		getSelected();
		if ( gui_prop_2.startsWith(DEFAULT_STRING) ) {
			gui_prop_2 = null; //false
		}
		if ( Message.isDebugOn ) {
			Message.printDebug( 3, routine,
			"prop_2 for " + __proc_fillfloodmonitor_str +
			" is: \"" + gui_prop_2 + "\"." );
		}

		//assemble current properties string
		gui_props_str =null;
/*Obsolete
		if ( ! gui_prop_1.startsWith( DEFAULT_STRING ) ) {
			gui_props_str = 
 			__props_1_fillfloodmonitor_JLabel_string + 
			"="+ gui_prop_1;
		}
*/
		if (  gui_prop_2 != null ) {
			if (gui_props_str == null ) {
				gui_props_str = 
 				__props_2_fillfloodmonitor_JLabel_string + "=" +
				gui_prop_2;
			}
			else {
				gui_props_str = gui_props_str + ";" +
 				__props_2_fillfloodmonitor_JLabel_string + "=" +
				gui_prop_2;
			}
		}

	} //end fillfloodmonitor

	//FILLREPEAT
	else if ( __processor_type.equalsIgnoreCase(
 	__proc_fillrepeat_str ) ) {

		Message.printStatus(1, routine,
		"Verifying MeasReduction Properties for " + 
 		__proc_fillrepeat_str + " process." );

		//inputTS_type = __proc_fillrepeat_str;
		arr_gui_inputTS=__sel_inputTS_ListModel.toArray();

		if ( arr_gui_inputTS.length <= 0 ) {
			Message.printWarning( 1, routine, 
			"Unable to update database " +
			"since there are no input time series.", this );
			throw new Exception ("Unable to update database " +
			"since there are no input time series." );
		}
		for ( int i=0; i<arr_gui_inputTS.length; i++ ) {
			gui_inputTS_vect.addElement(
			arr_gui_inputTS[i]);
		}
		if ( Message.isDebugOn ) {
			Message.printDebug( 4, routine,
			"Items in the list of selected input time series: " +
			gui_inputTS_vect.toString() );
		}

		//no properties
			
	}//end fillrepeat

	//MAP
	else if ( __processor_type.equalsIgnoreCase(
 	__proc_map_str ) ) {
		//MAP AND MAT have weights associated with the ts
		Message.printStatus(1, routine,
		"Verifying MeasReduction Properties for " + 
 		__proc_map_str + " process." );

		//inputTS_type = __proc_map_str;
		//arr_gui_inputTS=_sel_inputTS_ListModel.toArray();
		Vector data_vect = __weights_JWorksheet.getAllData();
		gui_weight_vect.clear();
		gui_inputTS_vect.clear();
		for (int i=0; i<data_vect.size();i++ ) {
			String [] arr_worksheet = (String []) 
			data_vect.elementAt(i);
			//put TSID in Vector
			gui_inputTS_vect.addElement( arr_worksheet[0] );
			//put weight in Vector
			gui_weight_vect.addElement( String.valueOf(
			arr_worksheet[1]) );
		}
		if ( gui_inputTS_vect.size() <= 0 ) {
			Message.printWarning( 1, routine, 
			"Unable to update database " +
			"since there are no input time series.", this );
			throw new Exception ("Unable to update database " +
			"since there are no input time series." );
		}

		if ( Message.isDebugOn ) {
			Message.printDebug( 4, routine,
			"Items in the list of selected input time series: " +
			gui_inputTS_vect.toString() );
		}

		//get properties
		//String to hold new properties ( since the properties
		//is ONE field in the data base that consists of 
		//several potential properties:  (PROPNAME=PROPVALUE;)
		
		String gui_prop_1 = null;
		gui_prop_1 = (String) __props_1_map_JComboBox.
		getSelected();
		//trim off the description if there is one
		int ind = -999;
		ind = gui_prop_1.indexOf("-");
		if ( ind > 0 ) {
			gui_prop_1= (gui_prop_1.substring( 0, ind)).trim();
		}
		if ( gui_prop_1.indexOf( DEFAULT_STRING ) >= 0  ) {
			gui_prop_1 = "-999";
		}

		if ( Message.isDebugOn ) {
			Message.printDebug( 3, routine,
			"prop_1 for " + __proc_map_str +
			" is: \"" + gui_prop_1 + "\"." );
		}

		String gui_prop_2 = null;
		gui_prop_2 = (String) __props_2_map_JComboBox.
		getSelected();
		//trim off the description if there is one
		ind = -999;
		ind = gui_prop_2.indexOf("-");
		if ( ind > 0 ) {
			gui_prop_2= (gui_prop_2.substring( 0, ind)).trim();
		}
		if ( Message.isDebugOn ) {
			Message.printDebug( 3, routine,
			"prop_2 for " + __proc_map_str +
			" is: \"" + gui_prop_2 + "\"." );
		}

		String gui_prop_3 = null;
		gui_prop_3 = (String) __props_3_map_JComboBox.
		getSelected();
		//trim off the description if there is one
		if ( gui_prop_3.startsWith( DEFAULT_STRING ) ) {
			//gui_prop_3 = "FALSE";
			gui_prop_3 = null;
		}
		if ( Message.isDebugOn ) {
			Message.printDebug( 3, routine,
			"prop_3 for " + __proc_map_str +
			" is: \"" + gui_prop_3 + "\"." );
		}

		//assemble current properties string
		gui_props_str =null;
		if ( ! gui_prop_1.startsWith( DEFAULT_STRING ) ) {
			gui_props_str = 
 			__props_1_map_JLabel_string + 
			"="+ gui_prop_1;
		}
		if ( ! gui_prop_2.startsWith( DEFAULT_STRING ) ) {
			if ( gui_props_str != null ) {
				gui_props_str = gui_props_str + ";" +
 				__props_2_map_JLabel_string + 
				"=" + gui_prop_2;
			}
			else {
				gui_props_str = __props_2_map_JLabel_string + 
				"=" + gui_prop_2;
			}
		}
		if ( gui_prop_3 != null ) {
			if ( gui_props_str != null ) {
				gui_props_str = gui_props_str + ";" +
 				__props_3_map_JLabel_string + 
				"=" + gui_prop_3;
			}
			else {
				gui_props_str = __props_3_map_JLabel_string + 
				"=" + gui_prop_3;
			}
		}
	}//end map

	//MAPX
	else if ( __processor_type.equalsIgnoreCase(
 	__proc_mapx_str ) ) {

		Message.printStatus(1, routine,
		"Verifying MeasReduction Properties for " + 
 		__proc_mapx_str + " process." );

		//inputTS_type = __proc_mapx_str;
		arr_gui_inputTS=__sel_inputTS_ListModel.toArray();

		if ( arr_gui_inputTS.length <= 0 ) {
			Message.printWarning( 1, routine, 
			"Unable to update database " +
			"since there are no input time series.", this );
			throw new Exception ("Unable to update database " +
			"since there are no input time series." );
		}
		for ( int i=0; i<arr_gui_inputTS.length; i++ ) {
			gui_inputTS_vect.addElement(
			arr_gui_inputTS[i] );
		}
		if ( Message.isDebugOn ) {
			Message.printDebug( 4, routine,
			"Items in the list of selected input time series: " +
			gui_inputTS_vect.toString() );
		}

		//get properties
		
		String gui_prop_1 = null;
		gui_prop_1 = (String) __props_1_mapx_JComboBox.
		getSelected();
		//trim off the description if there is one
		int ind = -999;
		ind = gui_prop_1.indexOf("-");
		if ( ind > 0 ) {
			gui_prop_1= (gui_prop_1.substring( 0, ind)).trim();
		}
		//_selected_props_1_mapx_JComboBox_string = prop_1;
		if ( Message.isDebugOn ) {
			Message.printDebug( 3, routine,
			"prop_1 for " + __proc_mapx_str +
			" is: \"" + gui_prop_1 + "\"." );
		}

		String gui_prop_2 = null;
		gui_prop_2 = (String) __props_2_mapx_JComboBox.
		getSelected();
		if ( gui_prop_2.startsWith(DEFAULT_STRING ) ) {
			gui_prop_2 = null;  //false
		}


		//_selected_props_1_mapx_JComboBox_string = prop_1;
		if ( Message.isDebugOn ) {
			Message.printDebug( 3, routine,
			"prop_1 for " + __proc_mapx_str +
			" is: \"" + gui_prop_1 + "\"." );
		}

		//assemble current properties string
		gui_props_str =null;
		if ( ! gui_prop_1.startsWith( DEFAULT_STRING ) ) {
			gui_props_str = 
 			__props_1_mapx_JLabel_string + 
			"="+ gui_prop_1;
		}
/*Obsolete	if ( gui_prop_2 != null ) {
			if ( gui_props_str != null ) {
				gui_props_str = gui_props_str + ";" +
 				__props_2_mapx_JLabel_string + 
				"="+ gui_prop_2;
			}
			else {
				gui_props_str = __props_2_mapx_JLabel_string + 
				"="+ gui_prop_2;
			}
		}
*/		


	}//end mapx

	//MAT
	else if ( __processor_type.equalsIgnoreCase(
 	__proc_mat_str ) ) {

		//MAP AND MAT have weights associated with the ts
		Message.printStatus(1, routine,
		"Verifying MeasReduction Properties for " + 
 		__proc_mat_str + " process." );

		//inputTS_type = __proc_mat_str;
		//arr_gui_inputTS=
		//_sel_inputTS_ListModel.toArray();
		Vector data_vect = __weights_JWorksheet.getAllData();
		
		gui_weight_vect.clear();
		gui_inputTS_vect.clear();
		for (int i=0; i<data_vect.size();i++ ) {
			String [] arr_worksheet = (String []) 
			data_vect.elementAt(i);
			//put TSID in Vector
			gui_inputTS_vect.addElement( arr_worksheet[0] );
			//put weight in Vector
			gui_weight_vect.addElement( arr_worksheet[1] );
		}

		if ( gui_inputTS_vect.size() <= 0 ) {
			Message.printWarning( 1, routine, 
			"Unable to update database " +
			"since there are no input time series.", this );
			throw new Exception ("Unable to update database " +
			"since there are no input time series." );
		}
		if ( Message.isDebugOn ) {
			Message.printDebug( 4, routine,
			"Items in the list of selected input time series: " +
			gui_inputTS_vect.toString() );
		}

		//get properties
		
		String gui_prop_1 = null;
		gui_prop_1 = (String) __props_1_mat_JComboBox.
		getSelected();
		//trim off the description if there is one
		int ind = -999;
		ind = gui_prop_1.indexOf("-");
		if ( ind > 0 ) {
			gui_prop_1= (gui_prop_1.substring( 0, ind)).trim();
		}
		//_selected_props_1_mat_JComboBox_string = gui_prop_1;
		if ( Message.isDebugOn ) {
			Message.printDebug( 3, routine,
			"prop_1 for " + __proc_mat_str +
			" is: \"" + gui_prop_1 + "\"." );
		}

		String gui_prop_2 = null;
		/*
		gui_prop_2 = (String) __props_2_mat_JComboBox.
		getSelected();
		*/
		gui_prop_2 = (String) __props_2_mat_JTextField.
		getText();

		//trim off the description if there is one
		ind = -999;
		ind = gui_prop_2.indexOf("-");
		if ( ind > 0 ) {
			gui_prop_2= (gui_prop_2.substring( 0, ind)).trim();
		}
		if ( Message.isDebugOn ) {
			Message.printDebug( 3, routine,
			"prop_2 for " + __proc_mat_str +
			" is: \"" + gui_prop_2 + "\"." );
		}

		String gui_prop_3 = null;
		gui_prop_3 = (String) __props_3_mat_JComboBox.
		getSelected();
		if ( gui_prop_3.startsWith(DEFAULT_STRING ) ) {
			gui_prop_3 = null;//false
		}
		//_selected_props_1_mat_JComboBox_string = gui_prop_1;
		if ( Message.isDebugOn ) {
			Message.printDebug( 3, routine,
			"prop_3 for " + __proc_mat_str +
			" is: \"" + gui_prop_3 + "\"." );
		}

		//assemble current properties string
		gui_props_str =null;
		if ( ! gui_prop_1.startsWith( DEFAULT_STRING ) ) {
			gui_props_str = 
 			__props_1_mat_JLabel_string + 
			"="+ gui_prop_1;
		}
		if ( ! gui_prop_2.startsWith( DEFAULT_STRING ) ) {
			if ( gui_props_str != null ) {
				gui_props_str = gui_props_str + ";" +
 				__props_2_mat_JLabel_string + 
				"=" + gui_prop_2;
			}
			else {
				gui_props_str = __props_2_mat_JLabel_string + 
				"=" + gui_prop_2;
			}
		}
		if ( gui_prop_3 != null ) {
			if ( gui_props_str != null ) {
				gui_props_str = gui_props_str + ";" +
 				__props_3_mat_JLabel_string + 
				"=" + gui_prop_3;
			}
			else {
				gui_props_str = __props_3_mat_JLabel_string + 
				"=" + gui_prop_3;
			}
		}

	} //end mat

	//SHAPEFILE
	else if ( __processor_type.equalsIgnoreCase(
 	__proc_shapefile_str ) ) {

	}//end shapefile

	//POWERFUNC
	else if ( __processor_type.equalsIgnoreCase(
 	__proc_powerfunc_str ) ) {

	} //end powerfunc

	//STAGEDISCHARGERATING
	else if ( __processor_type.equalsIgnoreCase(
 	__proc_stagedischargerating_str ) ) {

		Message.printStatus(1, routine,
		"Verifying MeasReduction Properties for " + 
 		__proc_stagedischargerating_str + " process." );

		//inputTS_type = __proc_stagedischargerating_str;
		arr_gui_inputTS=__sel_inputTS_ListModel.toArray();

		if ( arr_gui_inputTS.length <= 0 ) {
			Message.printWarning( 1, routine, 
			"Unable to update database " +
			"since there are no input time series.", this );
			throw new Exception ("Unable to update database " +
			"since there are no input time series." );
		}
		for ( int i=0; i<arr_gui_inputTS.length; i++ ) {
			gui_inputTS_vect.addElement(
			arr_gui_inputTS[i] );
		}
		if ( Message.isDebugOn ) {
			Message.printDebug( 4, routine,
			"Items in the list of selected input time series: " +
			gui_inputTS_vect.toString() );
		}

		//get properties
		
		String gui_prop_1 = null;
		gui_prop_1 = (String) __props_1_stagedischargerating_JComboBox.
		getSelected();
		//trim off the description if there is one
		int ind = -999;
		ind = gui_prop_1.indexOf("-");
		if ( ind > 0 ) {
			gui_prop_1= (gui_prop_1.substring( 0, ind)).trim();
		}
		if ( Message.isDebugOn ) {
			Message.printDebug( 3, routine,
			"prop_1 for " + __proc_stagedischargerating_str +
			" is: \"" + gui_prop_1 + "\"." );
		}

		String gui_prop_2 = null;
		gui_prop_2 = (String) __props_2_stagedischargerating_JComboBox.
		getSelected();
		//trim off the description if there is one
		ind = -999;
		ind = gui_prop_2.indexOf("-");
		if ( ind > 0 ) {
			gui_prop_2= (gui_prop_2.substring( 0, ind)).trim();
		}
		if ( Message.isDebugOn ) {
			Message.printDebug( 3, routine,
			"prop_2 for " + __proc_stagedischargerating_str +
			" is: \"" + gui_prop_2 + "\"." );
		}

		String gui_prop_3 = null;
		gui_prop_3 = (String) __props_3_stagedischargerating_JComboBox.
		getSelected();
		//trim off the description if there is one
		ind = -999;
		ind = gui_prop_3.indexOf("-");
		if ( ind > 0 ) {
			gui_prop_3= (gui_prop_3.substring( 0, ind)).trim();
		}
		if ( Message.isDebugOn ) {
			Message.printDebug( 3, routine,
			"gui_prop_3 for " + __proc_stagedischargerating_str +
			" is: \"" + gui_prop_3 + "\"." );
		}

		//assemble current properties string
		gui_props_str =null;
/*Obsolete		if ( ! gui_prop_1.startsWith( DEFAULT_STRING ) ) {
			gui_props_str = 
 			__props_1_stagedischargerating_JLabel_string + 
			"="+ gui_prop_1;
		}
*/
		if ( ! gui_prop_2.startsWith( DEFAULT_STRING ) ) {
			if ( gui_props_str != null ) {
				gui_props_str = gui_props_str + ";" +
 				__props_2_stagedischargerating_JLabel_string + 
				"=" + gui_prop_2;
			}
			else {
				gui_props_str = 
 				__props_2_stagedischargerating_JLabel_string + 
				"=" + gui_prop_2;
			}
		}
		if ( ! gui_prop_3.startsWith( DEFAULT_STRING ) ) {
			if ( gui_props_str != null ) {
				gui_props_str = gui_props_str + ";" +
 				__props_3_stagedischargerating_JLabel_string + 
				"=" + gui_prop_3;
			}
			else {
				gui_props_str = 
 				__props_3_stagedischargerating_JLabel_string + 
				"=" + gui_prop_3;
			}
		}

	}//end stagedischargerating

	//check the __selected vector of Time series against the
	//original vector of time series from the database:
	//db_inputTS_tsid_vect		
	//need to go through and check each
	//item against each other to see if the
	//list of inputTS has changed or not.
	Vector v_add_tsid = null;
	Vector v_rem_tsid = null;
	v_add_tsid = findAdditions( gui_inputTS_vect, db_inputTS_tsid_vect);
	v_rem_tsid = findRemovals( gui_inputTS_vect, db_inputTS_tsid_vect);
	if ( Message.isDebugOn ) {
		Message.printDebug( 3, routine, "v_add_tsid = " + 
		v_add_tsid.toString() +"; v_rem_tsid = " + v_rem_tsid.toString());
	}

	Vector v_add_wt = null;
	Vector v_rem_wt = null;
	v_add_wt = findAdditions( gui_weight_vect, db_inputTS_weight_vect);

	v_rem_wt = findRemovals( gui_weight_vect, db_inputTS_weight_vect);
	if ( Message.isDebugOn ) {
		Message.printDebug( 3, routine, "v_add_wt = " + 
		v_add_wt.toString() +"; v_rem_wt = " + v_rem_wt.toString());
	}

	if( ( (v_add_tsid.size() > 0 ) || (v_rem_tsid.size() > 0) ) || 
	( (v_add_wt.size() > 0 ) || (v_rem_wt.size() > 0) ) ) {
		//There are differnces between what was 
		//originally in the database and what is now in the GUI.
		//Need to update the MeasReducRelation objects- in memory
		//(will be updated in DB, in update_DB method)
		//clean out old vector in memory
 		__gui_RTi_MeasReducRelation_vect.clear();
	
		//then we need to wipe out the old MeasReducRelation_vect
		//and re-fill it, marking each object as dirty as we do.
		int size = 0;
		if ( gui_inputTS_vect != null ) {
			size =  gui_inputTS_vect.size();
		}
		for ( int k=0; k<size;k++) {
			RiversideDB_MeasReducRelation rti_mrr= 
			new RiversideDB_MeasReducRelation();

			rti_mrr.setOutputMeasType_num( __db_MeasType_num );

			//get Input Time Series
			//The vector  gui_inputTS_vect
			//contains objects - must convert them to
			//strings to use to get TSID and then MeasType 
			//and MeasType num
			RiversideDB_MeasType input_MeasType = null;
			String inputTS_str = ( String) gui_inputTS_vect.
			elementAt(k);
			try {
				input_MeasType = 
 				__dmi.readMeasTypeForTSIdent( inputTS_str );
			}
			catch ( Exception e ) {
				Message.printWarning( 2, routine, e);
				Message.printWarning( 2, routine,
				"Unable to read MeasType object for \"" +
				inputTS_str + "\"." );
			}

			//set WEIGHT
			rti_mrr.setInputMeasType_num( 
			input_MeasType.getMeasType_num() );

			double wt_dbl = -999;
			String wt_str= (String) gui_weight_vect.elementAt(k);
			if (( wt_str != null ) && (StringUtil.isDouble( wt_str ) ) ) {
				wt_dbl = StringUtil.atod( wt_str );
			}
			rti_mrr.setWeight( wt_dbl );

			//set DIRTY
			rti_mrr.setDirty( true );

			//MeasReducRelation is dirty so make MeasReduction dirty
 			__gui_RTi_MeasReduction.setDirty( true );

 			__dirty_vect.addElement(
			"Change in Input Time Series for Reduction,\n " + 
			"add: \"" + inputTS_str + "\" with weight: " 
			+ rti_mrr.getWeight() );

			//add to vector of MeasReducRelations
 			__gui_RTi_MeasReducRelation_vect.addElement(
			rti_mrr);

			input_MeasType = null;
			inputTS_str = null;
		}//end loop
	}//end if v_add or v_rem >0

	//check properties to see if they have changed.
	String db_props_str = null;
	db_props_str = __db_RTi_MeasReduction.getProperties();
	//current props string can be null- if all defaults are selected.
	if (( gui_props_str == null ) &&
	( DMIUtil.isMissing( db_props_str ) ) ) {
		//no change to the properties.
	}
	else if ( gui_props_str == null ) {
		//update 
 		__gui_RTi_MeasReduction.setDirty( true );

 		__dirty_vect.addElement(
		"Change Properties from \"" + db_props_str + 
		"\" to\n\"" + DMIUtil.MISSING_STRING + "\"");

 		__gui_RTi_MeasReduction.setProperties( 
		DMIUtil.MISSING_STRING );
	}
	else if ( ! gui_props_str.equalsIgnoreCase( db_props_str ) ) {
 		__gui_RTi_MeasReduction.setDirty( true );
 		__dirty_vect.addElement(
		"Change Properties from \"" + db_props_str + "\" to \n\"" +
		gui_props_str + "\"");
 		__gui_RTi_MeasReduction.setProperties( gui_props_str );
	}

} //end verify_inputTS_fields


/////////////////////////////////////////////////////////////////
////////////////////////  ACTIONS ///////////////////////////////
/////////////////////////////////////////////////////////////////
/**
The event handler manages action events.
@param event Event to handle.
*/
public void actionPerformed (ActionEvent event) {
	String routine = __class + ".actionPerformed";

	try {
	Object source = event.getSource();
	
	if ( source.equals( __apply_JButton ) ) {
		boolean blnUpdated = true;

		/*
		//REQUIRED Fields
		try {
			checkRequiredInput();
		}
		catch ( Exception e ) {
			//then there was an error so do not 
			//update object in memory or in database.
			Message.printWarning( 2, routine, e );
			blnUpdated= false;
		}
		*/
	
		//update the "GUI" object in memory
	//	if ( blnUpdated ) {
			try {
				update_RiversideDB_objects();
			}
			catch( Exception e ) {
				Message.printWarning( 2, routine, e );
				blnUpdated=false;
			}
	//	}
		if ( blnUpdated ) {
			try {
				//update database itself
				try {
					update_database();
				}
				catch ( Exception e ) {
					Message.printWarning( 2, routine, e );
				}
			}
			catch( Exception e ) {
				Message.printWarning( 2, routine, e );
				blnUpdated=false;
				//update the __gui_ versions to be the 
				//the memory version again since update failed.
 				__gui_RTi_MeasType = null;
 				__gui_RTi_MeasReduction = null;
 				__gui_RTi_MeasType = new RiversideDB_MeasType( 
 				__db_RTi_MeasType );
 				__gui_RTi_MeasReduction = 
				new RiversideDB_MeasReduction( 
 				__db_RTi_MeasReduction );

				//transfer stuff from 
				//_db_MeasReducRelation_vect to __gui_ version
				int s = 0;
				if ( __db_RTi_MeasReducRelation_vect != null ){
					s = __db_RTi_MeasReducRelation_vect.
					size();
				}

				for ( int i=0; i<s; i++ ) {
 					__gui_RTi_MeasReducRelation_vect.
					addElement(
 					__db_RTi_MeasReducRelation_vect.
					elementAt(i) );
				}
			}
		}

		if ( blnUpdated ) {
			//if we got this far, the database was updated,
			//so update objects in memory.  The __gui_ object 
			//was written to the database, so now the 
			//_db_ object should equal the __gui_ object
 			__db_RTi_MeasType = null;
 			__db_RTi_MeasReduction = null;
 			__db_RTi_MeasType = new RiversideDB_MeasType( 
 			__gui_RTi_MeasType );
 			__db_RTi_MeasReduction = new RiversideDB_MeasReduction( 
 			__gui_RTi_MeasReduction );
 			__db_RTi_MeasType.setDirty( false );
 			__db_RTi_MeasReduction.setDirty( false );
	
 			__gui_RTi_MeasType = null;
 			__gui_RTi_MeasReduction = null;

			//update MeasReducRelation vector -transfer GUI to db
			int s = 0;
			if ( __gui_RTi_MeasReducRelation_vect != null ){
				s = __gui_RTi_MeasReducRelation_vect.size();
			}
 			__db_RTi_MeasReducRelation_vect.clear();
			for ( int i=0; i<s; i++ ) {
 				__db_RTi_MeasReducRelation_vect.
				addElement(
 				__gui_RTi_MeasReducRelation_vect.
				elementAt(i) );
			}
 			__gui_RTi_MeasReducRelation_vect.clear();
		}
	}
	
	else if ( source.equals( __cancel_JButton ) ) {
		if( ( __cautious_mode ) && ( ! __bln_new_object ) 
		&& ( __dirty_vect.size() > 0 ) ) {
			//create and update __gui_ objects in memory
			//The only reason to do this is to provide the
			//user with a Confirm Cancel message.
			try {
				update_RiversideDB_objects();
			}
			catch( Exception e ) {
				Message.printWarning( 2, routine, e);

				windowManagerClose();
			}

			if ( ( __gui_RTi_MeasType.isDirty()) || 
			( __gui_RTi_MeasReduction.isDirty() ) ) {
				//holds messages from __dirty_vect
				StringBuffer b = new StringBuffer();
				for (int i=0;i< __dirty_vect.size(); i++ ) {
					b.append( (String) 
 					__dirty_vect.elementAt(i) + 
					"\n" );
				}
				//write out a confirmation message.
				int x = new ResponseJDialog( 
				this, "Cancel Changes",
				"Are you sure you want to " +
				"Cancel the following changes?\n" +
				b.toString(), 
				ResponseJDialog.YES | ResponseJDialog.NO ).
				response();
	
				if ( x == ResponseJDialog.YES ) {
					//write to log file
					Message.printStatus( 5, 
					routine, 
					"User canceled changes: " +
					b.toString() ); 

					windowManagerClose();

					//empty out dirty vector
 					__dirty_vect.clear();
		
				}	
				else {
					//do nothing.. leave GUI open
 					__dirty_vect.clear();
				}

				b = null;
			}
			else {
				//Nothing has been changed, so
				//just do a normal cancel- close gui
				windowManagerClose();
			}
		}
		else {
			//just do a normal cancel- close gui
			windowManagerClose();
		}

	}

	else if ( source.equals( __close_JButton ) ) {
		closeGUI();
	}
	
	else if ( source == __move_inputTS_right_JButton ) {
		move_right();
	}	
	else if ( source == __remove_selected_inputTS_JButton ) {
		//get time series in the Selected Input TS list and
		//remove them from that list
		//get their indices
		if ( __sel_inputTS_JList != null ) {
			int[] sel_ind = __sel_inputTS_JList.
			getSelectedIndices();
			int ind = 0;
			for ( int i=0; i< sel_ind.length; i++ ) {
				ind = sel_ind[i];
				if ( ind >= 0 ) {
 					__sel_inputTS_ListModel.
					removeElementAt( ind );
				}
			}
		}
		else if ( __weights_JWorksheet != null ) {
			int selRow = -999;
			selRow = __weights_JWorksheet.getSelectedRow();
			if ( selRow >= 0 ) {
				//remove it
 				__weights_JWorksheet.deleteRow( selRow);
			}
		}
	}


	source = null;
	} // End of try
	catch ( Exception e ) {
		if ( Message.isDebugOn ) {
			Message.printWarning ( 2, routine, e );
		}
	}
} //end actionPerformed

/**
Action for the ListSelectionListeners.
(Import: javax.swing.event.ListSelectionEvent and .ListSelectionListener.)
@param event  ListSelectionEvent to fire off the listener.
*/
public void valueChanged( ListSelectionEvent event ) {

} //end valueChanged


//WINDOW EVENTS
public void windowActivated ( WindowEvent e )
{
}

/**
This class is listening for GeoViewGUI closing so it can gracefully handle.
*/
public void windowClosed ( WindowEvent e )
{
}

/**
We don't want user to be able to close the GUI with the "x".
*/
public void windowClosing ( WindowEvent e ) {
	if ( __canWriteMeasReduction ) {
	 	closeGUI();
	}
	else {
		//just close as a cancel
		windowManagerClose();
	}
}

public void windowDeactivated ( WindowEvent e )
{
}

public void windowDeiconified ( WindowEvent e )
{
}

public void windowIconified ( WindowEvent e )
{
}

public void windowOpened ( WindowEvent e )
{
}

private void windowManagerClose() {
/*
	if (__bln_new_object) {
		_windowManager.closeWindow(
			_windowManager.WINDOW_REDUCTION );	
	}
	else {
	*/
		_windowManager.closeWindowInstance(
			_windowManager.WINDOW_REDUCTION ,
			new Long(__db_RTi_MeasReduction.getOutputMeasType_num()) );
//	}
}

/////////////////////////////////////////////////////////////////
/////////////////////// END ACTIONS /////////////////////////////
/////////////////////////////////////////////////////////////////

}// end RiversideDB_Reduction_JFrame class
